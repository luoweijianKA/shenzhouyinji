package resolver

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.70

import (
	"context"
	"fmt"
	"gateway/graph/generated"
	"gateway/graph/model"
	"strings"
	"time"

	aPB "gitlab.com/annoying-orange/shenzhouyinji/service/account/proto"
	mPB "gitlab.com/annoying-orange/shenzhouyinji/service/management/proto"
	tPB "gitlab.com/annoying-orange/shenzhouyinji/service/task/proto"
)

// User is the resolver for the user field.
func (r *userTaskResolver) User(ctx context.Context, obj *model.UserTask) (*model.Account, error) {
	if out, err := r.accountService.GetAccount(ctx, &aPB.AsKeyword{Value: obj.UserID}); err == nil {
		return r.NewAccount(out), nil
	}
	return nil, nil
}

// Task is the resolver for the task field.
func (r *userTaskResolver) Task(ctx context.Context, obj *model.UserTask) (model.Task, error) {
	camp, err := r.getUserCamp(ctx, obj.UserID, obj.EventID)
	if err != nil {
		return nil, err
	}

	optional := camp == nil || camp.CategoryId != obj.TaskCategory
	category, err := r.managementService.GetCategoryByID(ctx, &mPB.MsKeyword{Value: obj.TaskCategory})
	if err != nil {
		return nil, err
	}
	if category == nil {
		return nil, nil
	}

	completedTask := func(v string) *tPB.UserTask {
		var audit string
		if obj.Audit != nil {
			audit = *obj.Audit
		}
		return &tPB.UserTask{
			Id:            obj.ID,
			UserId:        obj.UserID,
			EventId:       obj.EventID,
			CampId:        obj.CampID,
			SceneryspotId: obj.SceneryspotID,
			TaskId:        obj.TaskID,
			TaskCategory:  obj.TaskCategory,
			Result:        obj.Result,
			Points:        int32(obj.Points),
			Status:        int32(obj.Status),
			Audit:         audit,
			CreateTime:    int32(obj.CreateTime),
		}
	}

	if category.Id == string(TaskCategoryTrek) {
		if v, err := r.taskService.GetTrek(ctx, &tPB.TsKeyword{Value: obj.TaskID}); err == nil {
			timestamp := int(time.Now().Unix())
			var redone, completed bool
			if task := completedTask(v.Id); task != nil {
				timestamp = int(task.CreateTime)
				redone = len(task.Audit) == 0 && task.Result != fmt.Sprintf("%v", v.Step)
				completed = task.Status == int32(TaskStatusCompleted)
			}
			return &model.TrekTask{
				ID:           v.Id,
				Name:         v.Name,
				CategoryID:   category.Id,
				CategoryName: category.Name,
				Points:       int(v.Points),
				Optional:     optional,
				Status:       int(v.Status),
				Timestamp:    timestamp,
				Redone:       &redone,
				Completed:    &completed,
				Step:         int(v.Step),
				Introduction: v.Introduction,
			}, nil
		}
	}

	if category.Id == string(TaskCategoryQuestion) {
		if v, err := r.taskService.GetQuestionBank(ctx, &tPB.TsKeyword{Value: obj.TaskID}); err == nil {
			timestamp := int(time.Now().Unix())
			var redone, completed bool
			if task := completedTask(v.Id); task != nil {
				timestamp = int(task.CreateTime)
				redone = len(task.Audit) == 0 && task.Result != v.Answer
				completed = task.Status == int32(TaskStatusCompleted)
			}
			return &model.QuestionTask{
				ID:           v.Id,
				Name:         v.Question,
				CategoryID:   category.Id,
				CategoryName: category.Name,
				Points:       int(v.Points),
				Optional:     optional,
				Status:       int(v.Status),
				Timestamp:    timestamp,
				Redone:       &redone,
				Completed:    &completed,
				Options:      strings.Split(v.Options, ";"),
			}, nil
		}
	}

	if category.Id == string(TaskCategoryGeocaching) {
		if v, err := r.taskService.GetGeocaching(ctx, &tPB.TsKeyword{Value: obj.TaskID}); err == nil {
			timestamp := int(time.Now().Unix())
			var redone, completed bool
			if task := completedTask(v.Id); task != nil {
				timestamp = int(task.CreateTime)
				redone = len(task.Audit) == 0 && task.Result != v.Id
				completed = task.Status == int32(TaskStatusCompleted)
			}
			return &model.GeocachingTask{
				ID:           v.Id,
				Name:         v.Name,
				CategoryID:   category.Id,
				CategoryName: category.Name,
				Points:       int(v.Points),
				Optional:     optional,
				Status:       int(v.Status),
				Timestamp:    timestamp,
				Redone:       &redone,
				Completed:    &completed,
				Images:       v.Images,
				Introduction: v.Introduction,
			}, nil
		}
	}

	if category.Id == string(TaskCategoryScreenshot) {
		if v, err := r.taskService.GetScreenshot(ctx, &tPB.TsKeyword{Value: obj.TaskID}); err == nil {
			timestamp := int(time.Now().Unix())
			var redone, completed bool
			if task := completedTask(v.Id); task != nil {
				timestamp = int(task.CreateTime)
				redone = len(task.Audit) == 0
				completed = task.Status == int32(TaskStatusCompleted)
			}
			return &model.ScreenshotTask{
				ID:           v.Id,
				Name:         v.Name,
				CategoryID:   category.Id,
				CategoryName: category.Name,
				Points:       int(v.Points),
				Optional:     optional,
				Status:       int(v.Status),
				Timestamp:    timestamp,
				Redone:       &redone,
				Completed:    &completed,
				Images:       v.Images,
				Introduction: v.Introduction,
			}, nil
		}
	}

	if category.Id == string(TaskCategoryPuzzle) {
		if v, err := r.taskService.GetPuzzle(ctx, &tPB.TsKeyword{Value: obj.TaskID}); err == nil {
			timestamp := int(time.Now().Unix())
			var redone, completed bool
			if task := completedTask(v.Id); task != nil {
				timestamp = int(task.CreateTime)
				redone = len(task.Audit) == 0 && task.Result != v.Images
				completed = task.Status == int32(TaskStatusCompleted)
			}
			puzzles := strings.Split(v.Images, ",")
			return &model.PuzzleTask{
				ID:           v.Id,
				Name:         v.Name,
				CategoryID:   category.Id,
				CategoryName: category.Name,
				Points:       int(v.Points),
				Optional:     optional,
				Status:       int(v.Status),
				Timestamp:    timestamp,
				Redone:       &redone,
				Completed:    &completed,
				Level:        len(puzzles),
				Countdown:    int(v.Countdown),
				Puzzles:      puzzles,
				Introduction: v.Introduction,
			}, nil
		}
	}

	return nil, nil
}

// UserTask returns generated.UserTaskResolver implementation.
func (r *Resolver) UserTask() generated.UserTaskResolver { return &userTaskResolver{r} }

type userTaskResolver struct{ *Resolver }
