package resolver

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.47

import (
	"context"
	"fmt"
	"gateway/graph/generated"
	"gateway/graph/model"
	"strings"
	"time"

	aPB "gitlab.com/annoying-orange/shenzhouyinji/service/account/proto"
	ePB "gitlab.com/annoying-orange/shenzhouyinji/service/event/proto"
	mPB "gitlab.com/annoying-orange/shenzhouyinji/service/management/proto"
	tPB "gitlab.com/annoying-orange/shenzhouyinji/service/task/proto"
	"go-micro.dev/v4/logger"
)

// Task is the resolver for the task field.
func (r *eventTaskResolver) Task(ctx context.Context, obj *model.EventTask) (model.Task, error) {
	category, err := r.managementService.GetCategoryByID(ctx, &mPB.MsKeyword{Value: obj.CategoryID})
	if err != nil {
		logger.Error(err)
		return nil, err
	}
	if category == nil {
		return nil, nil
	}

	if category.Id == string(TaskCategoryTrek) {
		v, err := r.taskService.GetTrek(ctx, &tPB.TsKeyword{Value: obj.TaskID})
		if err != nil {
			return nil, err
		}

		return &model.TrekTask{
			ID:           v.Id,
			Name:         v.Name,
			CategoryID:   category.Id,
			CategoryName: category.Name,
			Points:       int(v.Points),
			Optional:     false,
			Status:       int(TaskStatusPendding),
			Timestamp:    int(time.Now().Unix()),
			Step:         int(v.Step),
			Introduction: v.Introduction,
		}, nil
	}

	if category.Id == string(TaskCategoryQuestion) {
		v, err := r.taskService.GetQuestionBank(ctx, &tPB.TsKeyword{Value: obj.TaskID})
		if err != nil {
			return nil, err
		}

		return &model.QuestionTask{
			ID:           v.Id,
			Name:         v.Question,
			CategoryID:   category.Id,
			CategoryName: category.Name,
			Points:       int(v.Points),
			Optional:     false,
			Status:       int(TaskStatusPendding),
			Timestamp:    int(time.Now().Unix()),
			Options:      strings.Split(v.Options, ";"),
		}, nil
	}

	if category.Id == string(TaskCategoryGeocaching) {
		v, err := r.taskService.GetGeocaching(ctx, &tPB.TsKeyword{Value: obj.TaskID})
		if err != nil {
			return nil, err
		}

		return &model.GeocachingTask{
			ID:           v.Id,
			Name:         v.Name,
			CategoryID:   category.Id,
			CategoryName: category.Name,
			Points:       int(v.Points),
			Optional:     false,
			Status:       int(TaskStatusPendding),
			Timestamp:    int(time.Now().Unix()),
			Images:       v.Images,
			Introduction: v.Introduction,
		}, nil
	}

	if category.Id == string(TaskCategoryScreenshot) {
		v, err := r.taskService.GetScreenshot(ctx, &tPB.TsKeyword{Value: obj.TaskID})
		if err != nil {
			return nil, err
		}

		return &model.ScreenshotTask{
			ID:           v.Id,
			Name:         v.Name,
			CategoryID:   category.Id,
			CategoryName: category.Name,
			Points:       int(v.Points),
			Optional:     false,
			Status:       int(TaskStatusPendding),
			Timestamp:    int(time.Now().Unix()),
			Images:       v.Images,
			Introduction: v.Introduction,
		}, nil
	}

	if category.Id == string(TaskCategoryPuzzle) {
		v, err := r.taskService.GetPuzzle(ctx, &tPB.TsKeyword{Value: obj.TaskID})
		if err != nil {
			return nil, err
		}
		puzzles := strings.Split(v.Images, ",")

		return &model.PuzzleTask{
			ID:           v.Id,
			Name:         v.Name,
			CategoryID:   category.Id,
			CategoryName: category.Name,
			Points:       int(v.Points),
			Optional:     false,
			Status:       int(TaskStatusPendding),
			Timestamp:    int(time.Now().Unix()),
			Level:        len(puzzles),
			Countdown:    int(v.Countdown),
			Puzzles:      puzzles,
			Introduction: v.Introduction,
		}, nil
	}

	return nil, nil
}

// EventPassport is the resolver for the event_passport field.
func (r *passportResolver) EventPassport(ctx context.Context, obj *model.Passport) (*model.EventPassport, error) {
	up, err := r.eventService.GetUserPassport(ctx, &ePB.UserPassport{EventId: obj.EventID, PassportCode: obj.Code})
	if err != nil {
		return nil, err
	}

	return &model.EventPassport{
		ID:            up.Id,
		Code:          up.PassportCode,
		UserID:        &up.UserId,
		UserCampID:    &up.UserCampId,
		EventID:       up.EventId,
		Name:          up.RealName,
		Nric:          up.Nric,
		Phone:         up.Phone,
		Gender:        &up.Gender,
		Profession:    &up.Profession,
		ClaimCode:     &up.ClaimCode,
		ClaimBy:       &up.ClaimBy,
		ClaimTime:     int(up.ClaimTime),
		GuardianName:  &up.GuardianName,
		GuardianNric:  &up.GuardianNric,
		GuardianPhone: &up.GuardianPhone,
		Status:        int(up.Status),
	}, nil
}

// User is the resolver for the User field.
func (r *passportResolver) User(ctx context.Context, obj *model.Passport) (*model.Account, error) {
	up, err := r.eventService.GetUserPassport(ctx, &ePB.UserPassport{EventId: obj.EventID, PassportCode: obj.Code})
	if err != nil {
		return nil, err
	}
	if up != nil && len(up.UserId) > 0 {
		if out, err := r.accountService.GetAccount(ctx, &aPB.AsKeyword{Value: up.UserId}); err == nil {
			return r.NewAccount(out), nil
		}

	}
	return nil, nil
}

// Event is the resolver for the event field.
func (r *userPassportResolver) Event(ctx context.Context, obj *model.UserPassport) (*model.Event, error) {
	out, err := r.eventService.GetEvent(ctx, &ePB.EsKeyword{Value: obj.EventID})
	if err != nil {
		return nil, err
	}
	return r.NewEvent(out), nil
}

// Camp is the resolver for the camp field.
func (r *userPassportResolver) Camp(ctx context.Context, obj *model.UserPassport) (*model.Camp, error) {
	if obj.CampID == nil || len(*obj.CampID) == 0 {
		return nil, nil
	}

	out, err := r.eventService.GetCamp(ctx, &ePB.EsKeyword{Value: *obj.CampID})
	if err != nil {
		return nil, err
	}
	if out != nil {
		camp := model.Camp{
			ID:           out.Id,
			EventID:      out.EventId,
			Name:         out.Name,
			Introduction: &out.Introduction,
			Images:       &out.Images,
			Points:       int(out.Points),
			Status:       int(out.Status),
			CategoryID:   &out.CategoryId,
		}
		return &camp, nil
	}
	return nil, nil
}

// Messages is the resolver for the messages field.
func (r *userSwapResolver) Messages(ctx context.Context, obj *model.UserSwap) ([]map[string]interface{}, error) {
	if len(obj.Content) == 0 {
		return obj.Content, nil
	}

	accounts := make(map[string]*aPB.Account)

	getAccount := func(id string) *aPB.Account {
		if _, ok := accounts[id]; !ok {
			if out, err := r.accountService.GetAccount(ctx, &aPB.AsKeyword{Value: id}); err == nil {
				accounts[id] = out
			}
		}
		return accounts[id]
	}

	result := []map[string]interface{}{}
	for _, conent := range obj.Content {
		for k, v := range conent {
			msg := v.([]interface{})
			acc := getAccount(k)
			if acc != nil {
				result = append(result, map[string]interface{}{
					"userId":     acc.Id,
					"userName":   acc.WechatName,
					"userAvatar": acc.WechatAvatar,
					"msg":        msg[0],
					"timestamp":  msg[1],
				})
			}
		}
	}

	return result, nil
}

// EventTask returns generated.EventTaskResolver implementation.
func (r *Resolver) EventTask() generated.EventTaskResolver { return &eventTaskResolver{r} }

// Passport returns generated.PassportResolver implementation.
func (r *Resolver) Passport() generated.PassportResolver { return &passportResolver{r} }

// UserPassport returns generated.UserPassportResolver implementation.
func (r *Resolver) UserPassport() generated.UserPassportResolver { return &userPassportResolver{r} }

// UserSwap returns generated.UserSwapResolver implementation.
func (r *Resolver) UserSwap() generated.UserSwapResolver { return &userSwapResolver{r} }

type eventTaskResolver struct{ *Resolver }
type passportResolver struct{ *Resolver }
type userPassportResolver struct{ *Resolver }
type userSwapResolver struct{ *Resolver }

// !!! WARNING !!!
// The code below was going to be deleted when updating resolvers. It has been copied here so you have
// one last chance to move it out of harms way if you want. There are two reasons this happens:
//   - When renaming or deleting a resolver the old code will be put in here. You can safely delete
//     it when you're done.
//   - You have helper methods in this file. Move them out to keep these resolver files clean.
func (r *userSwapResolver) Content(ctx context.Context, obj *model.UserSwap) ([]map[string]interface{}, error) {
	panic(fmt.Errorf("not implemented: Content - content"))
}
