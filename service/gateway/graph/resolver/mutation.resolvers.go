package resolver

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.70

import (
	"bytes"
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"gateway/graph/auth"
	"gateway/graph/generated"
	"gateway/graph/model"
	ocr "gateway/graph/orc"
	"gateway/graph/utils"
	"io"
	"io/ioutil"
	"log"
	"math"
	"net/http"
	"os"
	"strconv"
	"strings"
	"time"

	"github.com/99designs/gqlgen/graphql"
	"github.com/disintegration/imaging"
	"github.com/gofrs/uuid"
	aPB "gitlab.com/annoying-orange/shenzhouyinji/service/account/proto"
	ePB "gitlab.com/annoying-orange/shenzhouyinji/service/event/proto"
	mPB "gitlab.com/annoying-orange/shenzhouyinji/service/management/proto"
	msgPB "gitlab.com/annoying-orange/shenzhouyinji/service/message/proto"
	sPB "gitlab.com/annoying-orange/shenzhouyinji/service/sceneryspot/proto"
	tPB "gitlab.com/annoying-orange/shenzhouyinji/service/task/proto"
	merr "go-micro.dev/v4/errors"
	"go-micro.dev/v4/logger"
	"go.mongodb.org/mongo-driver/bson"
)

// Logout is the resolver for the logout field.
func (r *mutationResolver) Logout(ctx context.Context) (*int, error) {
	cur := auth.ForContext(ctx)
	if cur != nil {
		r.DB.Collection("session").DeleteOne(ctx, bson.D{{Key: "key", Value: cur.Token}})
	}

	return nil, nil
}

// Login is the resolver for the login field.
func (r *mutationResolver) Login(ctx context.Context, input model.NewLogin) (*model.Login, error) {
	ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()

	req := &aPB.LoginReq{
		LoginId:  input.LoginID,
		Password: input.Password,
	}

	res, err := r.accountService.Login(ctx, req)
	if err != nil {
		detail := merr.Parse(err.Error()).Detail
		if detail == "record not found" {
			return nil, errors.New("账号或密码不正确，请重新输入")
		}
		if detail == "account suspended" {
			return nil, errors.New("账号已被禁用")
		}
		return nil, errors.New("账号无效，登录失败")
	}

	acc := aPB.Account{
		Id:      res.Id,
		LoginId: res.LoginId,
		Role:    res.Role,
	}

	token, _ := auth.GenerateToken(&acc)
	doc := bson.D{{Key: "key", Value: token.Key}, {Key: "value", Value: token.Value}, {Key: "expiresIn", Value: token.ExpiresIn}}
	r.DB.Collection("session").InsertOne(ctx, doc)

	return &model.Login{
		ID:          acc.Id,
		LoginID:     res.LoginId,
		Role:        model.Role(res.Role),
		Status:      1,
		AccessToken: token.Key,
	}, nil
}

// LoginWithWechat is the resolver for the loginWithWechat field.
func (r *mutationResolver) LoginWithWechat(ctx context.Context, code string) (*model.Login, error) {
	ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()

	if len(code) == 0 {
		return nil, errors.New("invalid code")
	}

	WECHAT_APPID := os.Getenv("WECHAT_APPID")
	WECHAT_SECRET := os.Getenv("WECHAT_SECRET")

	wechat_url := fmt.Sprintf("https://api.weixin.qq.com/sns/jscode2session?appid=%s&secret=%s&js_code=%s&grant_type=authorization_code", WECHAT_APPID, WECHAT_SECRET, code)
	log.Println("wx:" + wechat_url)
	wechat_res, wechat_err := http.Get(wechat_url)
	if wechat_err != nil {
		return nil, errors.New("invalid code")
	}

	defer func() { _ = wechat_res.Body.Close() }()

	w_session := new(model.WechetSession)
	jsonBytes, _ := json.Marshal(w_session)

	log.Println("wx:" + string(jsonBytes))

	err := json.NewDecoder(wechat_res.Body).Decode(&w_session)

	if err != nil {
		return nil, errors.New("invalid code")
	}
	if len(w_session.Openid) == 0 {
		return nil, errors.New("invalid openid")
	}
	if w_session.ErrCode > 0 {
		return nil, errors.New(w_session.ErrMsg)
	}

	req := &aPB.WechatReq{
		Wechat: w_session.Openid,
	}

	res, err := r.accountService.LoginWithWechat(ctx, req)
	if err != nil {
		return nil, err
	}

	acc := aPB.Account{
		Id:      res.Id,
		LoginId: res.LoginId,
		Role:    res.Role,
	}

	token, _ := auth.GenerateToken(&acc)
	doc := bson.D{{Key: "key", Value: token.Key}, {Key: "value", Value: token.Value}, {Key: "expiresIn", Value: token.ExpiresIn}, {Key: "wechetSession", Value: w_session}}
	r.DB.Collection("session").InsertOne(ctx, doc)

	return &model.Login{
		ID:          acc.Id,
		AccessToken: token.Key,
	}, nil
}

// RefreshToken is the resolver for the refreshToken field.
func (r *mutationResolver) RefreshToken(ctx context.Context, input model.NewRefreshToken) (*model.Login, error) {
	acc, err := auth.ParseToken(input.Token)
	if err != nil {
		return nil, fmt.Errorf("access denied")
	}
	token, err := auth.GenerateToken(acc)
	if err != nil {
		return nil, err
	}

	doc := bson.D{{Key: "key", Value: token.Key}, {Key: "Value", Value: token.Value}, {Key: "ExpiresIn", Value: token.ExpiresIn}}
	r.DB.Collection("session").InsertOne(ctx, doc)

	return &model.Login{
		AccessToken: token.Value,
	}, nil
}

// CreateAccount is the resolver for the createAccount field.
func (r *mutationResolver) CreateAccount(ctx context.Context, input model.NewAccount) (*model.ID, error) {
	ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()

	req := &aPB.Account{
		LoginId:  input.LoginID,
		Password: input.Password,
		Role:     input.Role.String(),
		Scopes:   "[]",
	}

	res, err := r.accountService.CreateAccount(ctx, req)

	if err != nil {
		log.Println(err)
		return nil, err
	}

	return &model.ID{ID: res.Value}, nil
}

// UpdateAccount is the resolver for the updateAccount field.
func (r *mutationResolver) UpdateAccount(ctx context.Context, input model.UpdateAccount) (*model.Result, error) {
	in := &aPB.Account{Id: input.ID}
	if input.Password != nil {
		in.Password = *input.Password
	}
	if input.WechatName != nil {
		in.WechatName = *input.WechatName
	}
	if input.WechatAvatar != nil {
		in.WechatAvatar = *input.WechatAvatar
	}
	if input.Role != nil {
		in.Role = input.Role.String()
	}
	if input.Scopes != nil {
		if v, err := json.Marshal(input.Scopes); err == nil {
			in.Scopes = string(v)
		}
	}
	if input.Status != nil {
		in.Status = int32(*input.Status)
	}

	out, err := r.accountService.UpdateAccount(ctx, in)

	if err != nil {
		return nil, err
	}

	return &model.Result{Succed: &out.Value}, nil
}

// UpdateProfile is the resolver for the updateProfile field.
func (r *mutationResolver) UpdateProfile(ctx context.Context, input model.UpdateProfile) (*model.Result, error) {
	ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()

	if err := utils.VerifyPermissions(ctx, input.ID); err != nil {
		return nil, err
	}

	req := &aPB.Profile{
		Id:             input.ID,
		Name:           *input.Name,
		Gender:         *input.Gender,
		Email:          *input.Email,
		Phone:          *input.Phone,
		City:           *input.City,
		Tags:           *input.Tags,
		Nric:           *input.Nric,
		Authentication: *input.Authentication,
		Profession:     *input.Profession,
		GuardianName:   *input.GuardianName,
		GuardianNric:   *input.GuardianNric,
		GuardianPhone:  *input.GuardianPhone,
		Step:           int32(*input.Step),
		StepTime:       int32(*input.StepTime),
	}

	res, err := r.accountService.UpdateProfile(ctx, req)

	if err != nil {
		log.Println(err)
		return nil, err
	}

	return &model.Result{Succed: &res.Value}, nil
}

// UpdatePassword is the resolver for the updatePassword field.
func (r *mutationResolver) UpdatePassword(ctx context.Context, input model.UpdatePassword) (*model.Result, error) {
	ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()

	if err := utils.VerifyPermissions(ctx, input.ID); err != nil {
		return nil, err
	}

	req := &aPB.PasswordReq{
		LoginId:     input.ID,
		OldPassword: input.OldPassword,
		NewPassword: input.NewPassword,
	}

	res, err := r.accountService.UpdatePassword(ctx, req)

	if err != nil {
		detail := merr.Parse(err.Error()).Detail
		if detail == "record not found" {
			return nil, errors.New("密码不正确，请重新输入")
		}
		return nil, errors.New("密码修改失败")
	}

	return &model.Result{Succed: &res.Value}, nil
}

// SetAccountRole is the resolver for the setAccountRole field.
func (r *mutationResolver) SetAccountRole(ctx context.Context, input model.SetAccountRole) (*model.Result, error) {
	ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()

	var scopes string
	if v, err := json.Marshal(input.Scopes); err == nil {
		scopes = string(v)
	}
	req := &aPB.Account{
		Id:     input.ID,
		Role:   input.Role.String(),
		Scopes: scopes,
	}

	res, err := r.accountService.UpdateAccount(ctx, req)

	if err != nil {
		log.Println(err)
		return nil, err
	}

	return &model.Result{Succed: &res.Value}, nil
}

// DeleteAccount is the resolver for the deleteAccount field.
func (r *mutationResolver) DeleteAccount(ctx context.Context, id string) (*model.Account, error) {
	out, err := r.accountService.DeleteAccount(ctx, &aPB.AsKeyword{Value: id})
	if err != nil {
		return nil, err
	}
	if len(out.Data) == 0 {
		return nil, nil
	}
	data := out.Data[0]

	r.auditing(ctx, AuditingCodeAccount, fmt.Sprintf("删除用户(%s)", data.WechatName), data)

	return r.NewAccount(data), nil
}

// CreateClaimCode is the resolver for the createClaimCode field.
func (r *mutationResolver) CreateClaimCode(ctx context.Context, input model.NewClaimCode) (*model.ID, error) {
	ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()

	req := &aPB.ClaimCode{
		UserId: input.UserID,
		Code:   input.Code,
		Status: int32(input.Status),
	}

	res, err := r.accountService.CreateClaimCode(ctx, req)

	if err != nil {
		log.Println(err)
		return nil, err
	}

	return &model.ID{ID: res.Value}, nil
}

// UpdateClaimCode is the resolver for the updateClaimCode field.
func (r *mutationResolver) UpdateClaimCode(ctx context.Context, input model.UpdateClaimCode) (*model.Result, error) {
	ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()

	if err := utils.VerifyPermissions(ctx, input.ID); err != nil {
		return nil, err
	}

	req := &aPB.ClaimCode{
		Id:     input.ID,
		Status: int32(input.Status),
	}

	res, err := r.accountService.UpdateClaimCode(ctx, req)

	if err != nil {
		log.Panicln(err)
		return nil, err
	}

	return &model.Result{Succed: &res.Value}, nil
}

// CreateSceneryspot is the resolver for the createSceneryspot field.
func (r *mutationResolver) CreateSceneryspot(ctx context.Context, input model.NewSceneryspot) (*model.ID, error) {
	ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()

	in := &sPB.Sceneryspot{
		Code:              input.Code,
		Name:              input.Name,
		Address:           *input.Address,
		Points:            int32(*input.Points),
		Images:            *input.Images,
		Coordinate:        *input.Coordinate,
		Introduction:      *input.Introduction,
		CategoryId:        *input.CategoryID,
		PositionTolerance: *input.PositionTolerance,
		PassportLink:      *input.PassportLink,
		HealthCodeLink:    *input.HealthCodeLink,
		Status:            int32(*input.Status),
		EnableAward:       NotNilBool(input.EnableAward, false),
	}
	if input.ElectricFence != nil {
		in.ElectricFence = *input.ElectricFence
	}

	res, err := r.sceneryspotService.CreateSceneryspot(ctx, in)

	if err != nil {
		log.Println(err)
		return nil, err
	}

	return &model.ID{ID: res.Value}, nil
}

// UpdateSceneryspot is the resolver for the updateSceneryspot field.
func (r *mutationResolver) UpdateSceneryspot(ctx context.Context, input model.UpdateSceneryspot) (*model.Result, error) {
	ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()

	req := &sPB.Sceneryspot{
		Id:                input.ID,
		Code:              NotNilString(input.Code, ""),
		Name:              NotNilString(input.Name, ""),
		Address:           NotNilString(input.Address, ""),
		Points:            int32(NotNilInt(input.Points, 0)),
		Images:            NotNilString(input.Images, ""),
		Coordinate:        NotNilString(input.Coordinate, ""),
		ElectricFence:     NotNilString(input.ElectricFence, ""),
		Introduction:      NotNilString(input.Introduction, ""),
		CategoryId:        NotNilString(input.CategoryID, ""),
		PositionTolerance: NotNilString(input.PositionTolerance, ""),
		PassportLink:      NotNilString(input.PassportLink, ""),
		HealthCodeLink:    NotNilString(input.HealthCodeLink, ""),
		Status:            int32(NotNilInt(input.Status, 0)),
		EnableAward:       NotNilBool(input.EnableAward, false),
	}

	res, err := r.sceneryspotService.UpdateSceneryspot(ctx, req)

	if err != nil {
		log.Println(err)
		return nil, err
	}

	return &model.Result{Succed: &res.Value}, nil
}

// CreateServiceItem is the resolver for the createServiceItem field.
func (r *mutationResolver) CreateServiceItem(ctx context.Context, input model.NewServiceItem) (*model.ID, error) {
	ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()

	req := &sPB.ServiceItem{
		SceneryspotId:      input.SceneryspotID,
		Name:               input.Name,
		CategoryId:         *input.CategoryID,
		Address:            *input.Address,
		Images:             *input.Images,
		Coordinate:         *input.Coordinate,
		Wxappid:            *input.Wxappid,
		DisplayOrder:       int32(NotNilInt(input.DisplayOrder, 1)),
		Introduction:       *input.Introduction,
		ExpenseInstruction: *input.ExpenseInstruction,
		Status:             int32(*input.Status),
	}

	res, err := r.sceneryspotService.CreateServiceItem(ctx, req)

	if err != nil {
		log.Println(err)
		return nil, err
	}

	return &model.ID{ID: res.Value}, nil
}

// UpdateServiceItem is the resolver for the updateServiceItem field.
func (r *mutationResolver) UpdateServiceItem(ctx context.Context, input model.UpdateServiceItem) (*model.Result, error) {
	ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()

	req := &sPB.ServiceItem{
		Id:                 input.ID,
		Name:               NotNilString(input.Name, ""),
		CategoryId:         NotNilString(input.CategoryID, ""),
		Address:            NotNilString(input.Address, ""),
		Images:             NotNilString(input.Images, ""),
		Coordinate:         NotNilString(input.Coordinate, ""),
		Wxappid:            NotNilString(input.Wxappid, ""),
		DisplayOrder:       int32(NotNilInt(input.DisplayOrder, 1)),
		Introduction:       NotNilString(input.Introduction, ""),
		ExpenseInstruction: NotNilString(input.ExpenseInstruction, ""),
		Status:             int32(NotNilInt(input.Status, 0)),
	}

	res, err := r.sceneryspotService.UpdateServiceItem(ctx, req)

	if err != nil {
		log.Println(err)
		return nil, err
	}

	return &model.Result{Succed: &res.Value}, nil
}

// CreateStamp is the resolver for the createStamp field.
func (r *mutationResolver) CreateStamp(ctx context.Context, input model.NewStamp) (*model.ID, error) {
	ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()

	req := &sPB.Stamp{
		Name:          input.Name,
		SceneryspotId: input.SceneryspotID,
		Address:       *input.Address,
		Coordinate:    *input.Coordinate,
		Code:          *input.Code,
	}

	res, err := r.sceneryspotService.CreateStamp(ctx, req)

	if err != nil {
		log.Println(err)
		return nil, err
	}

	return &model.ID{ID: res.Value}, nil
}

// UpdateStamp is the resolver for the updateStamp field.
func (r *mutationResolver) UpdateStamp(ctx context.Context, input model.UpdateStamp) (*model.Result, error) {
	ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()

	req := &sPB.Stamp{
		Id:         input.ID,
		Name:       *input.Name,
		Address:    *input.Address,
		Coordinate: *input.Coordinate,
		Code:       *input.Code,
	}

	res, err := r.sceneryspotService.UpdateStamp(ctx, req)

	if err != nil {
		log.Println(err)
		return nil, err
	}

	return &model.Result{Succed: &res.Value}, nil
}

// CreateUserStamp is the resolver for the createUserStamp field.
func (r *mutationResolver) CreateUserStamp(ctx context.Context, input model.NewUserStamp) (*model.UserStamp, error) {
	ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()

	code := input.Code
	if len(code) == 0 {
		var v string
		if out, err := r.accountService.GetAccount(ctx, &aPB.AsKeyword{Value: input.UserID}); err == nil {
			v = out.Wechat
		}
		if out, err := r.eventService.GetEvent(ctx, &ePB.EsKeyword{Value: input.EventID}); err == nil {
			v += fmt.Sprintf("&%s", out.Code)
		}
		if out, err := r.sceneryspotService.GetSceneryspot(ctx, &sPB.SsKeyword{Value: input.SceneryspotID}); err == nil {
			v += fmt.Sprintf("&%s", out.Code)
		}

		encryptedCode, err := utils.AESEncrypt(v)
		if err != nil {
			return nil, err
		}

		code = encryptedCode
	}

	in := &sPB.UserStamp{
		UserId:        input.UserID,
		EventId:       input.EventID,
		SceneryspotId: input.SceneryspotID,
		Code:          code,
		Location:      input.Location,
	}

	out, err := r.sceneryspotService.CreateUserStamp(ctx, in)
	if err != nil {
		return nil, err
	}
	data := out.Data[0]

	return &model.UserStamp{
		UserID:        data.UserId,
		EventID:       data.EventId,
		SceneryspotID: data.SceneryspotId,
		Code:          &data.Code,
		Location:      &data.Location,
		Status:        int(data.Status),
		CreateTime:    int(data.CreateTime),
	}, nil
}

// UpdateUserStamp is the resolver for the updateUserStamp field.
func (r *mutationResolver) UpdateUserStamp(ctx context.Context, input model.UserStampInput) (*model.UserStamp, error) {
	ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()

	in := &sPB.UserStamp{
		UserId:        input.UserID,
		EventId:       input.EventID,
		SceneryspotId: input.SceneryspotID,
		Status:        int32(input.Status),
	}

	out, err := r.sceneryspotService.UpdateUserStamp(ctx, in)
	if err != nil {
		return nil, err
	}
	r.eventService.IncrementUserStampCount(
		ctx,
		&ePB.UserStampCountRequest{UserId: input.UserID, EventId: input.EventID, Value: 1},
	)
	data := out.Data[0]

	// event award
	if event, _ := r.eventService.GetEvent(ctx, &ePB.EsKeyword{Value: input.EventID}); event.EnableAward {
		sceneryspots, _ := r.getSceneryspotIDs(ctx, input.EventID)
		stamps, _ := r.sceneryspotService.GetUserStamp(
			ctx,
			&sPB.UserStampRequest{
				UserId:  input.UserID,
				EventId: input.EventID,
			},
		)
		if len(sceneryspots) == len(stamps.Data) {
			if awards, err := r.eventService.GetUserEventAwards(
				ctx,
				&ePB.UserEventAwardRequest{
					UserId:   input.UserID,
					EventId:  input.EventID,
					Location: data.Location,
				},
			); err == nil && len(awards.Data) > 0 {
				code := awards.Data[0].Code
				r.messageService.CreateConversation(
					ctx,
					&msgPB.Conversation{
						Participant: string(MessageFromReward),
						To:          input.UserID,
						Content:     fmt.Sprintf("活动<%s>奖励领取码：%s", event.Name, code),
						SendTime:    int32(time.Now().Unix()),
						Status:      1,
					},
				)
			}
		}
	}

	// sceneryspot award
	if sceneryspot, _ := r.sceneryspotService.GetSceneryspot(ctx, &sPB.SsKeyword{Value: input.SceneryspotID}); sceneryspot.EnableAward {
		if awards, err := r.eventService.GetUserEventAwards(
			ctx,
			&ePB.UserEventAwardRequest{
				UserId:        input.UserID,
				SceneryspotId: input.SceneryspotID,
				Location:      data.Location,
			},
		); err == nil && len(awards.Data) > 0 {
			code := awards.Data[0].Code
			r.messageService.CreateConversation(
				ctx,
				&msgPB.Conversation{
					Participant: string(MessageFromReward),
					To:          input.UserID,
					Content:     fmt.Sprintf("景区<%s>奖励领取码：%s", sceneryspot.Name, code),
					SendTime:    int32(time.Now().Unix()),
					Status:      1,
				},
			)
		}
	}

	return &model.UserStamp{
		UserID:        data.UserId,
		EventID:       data.EventId,
		SceneryspotID: data.SceneryspotId,
		Code:          &data.Code,
		Location:      &data.Location,
		Status:        int(data.Status),
		CreateTime:    int(data.CreateTime),
	}, nil
}

// UpdateUserStampRecord is the resolver for the updateUserStampRecord field.
func (r *mutationResolver) UpdateUserStampRecord(ctx context.Context, input model.NewUserStampRecord) (*model.Result, error) {
	ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()

	req := &sPB.UserStampRecordReq{
		UserId:        input.UserID,
		EventId:       input.EventID,
		SceneryspotId: input.SceneryspotID,
		ActionUserId:  input.ActionUserID,
		ActionType:    input.ActionType,
	}

	res, err := r.sceneryspotService.UpdateUserStampRecord(ctx, req)

	if err != nil {
		log.Println(err)
		return nil, err
	}

	if input.ActionType == "Like" && res.Value {
		if camp, err := r.getUserCamp(ctx, input.UserID, input.EventID); err == nil && camp != nil {
			curr := auth.ForContext(ctx).User
			points := int32(1)

			if _, err := r.eventService.IncrementEventUserPoints(ctx, &ePB.EventUserPoints{
				UserId:     input.UserID,
				EventId:    input.EventID,
				CampId:     camp.Id,
				Points:     points,
				CampPoints: points,
			}); err != nil {
				logger.Error(err)
			}

			account, _ := r.accountService.GetAccount(ctx, &aPB.AsKeyword{Value: curr.Id})
			up := &aPB.UserPoints{
				UserId:  input.UserID,
				EventId: input.EventID,
				Content: fmt.Sprintf("%s为你的“印迹地图”点赞，阵营和个人榜加%d分。", account.WechatName, points),
				Op:      "+",
				Points:  points,
			}
			if _, err := r.accountService.AddUserPoints(ctx, up); err == nil {
				r.messageService.CreateConversation(
					ctx,
					&msgPB.Conversation{
						Participant: string(MessageFromSystem),
						To:          up.UserId,
						Content:     up.Content,
						SendTime:    int32(time.Now().Unix()),
						Status:      1,
					},
				)
			}
		}
	}

	return &model.Result{Succed: &res.Value}, nil
}

// CreateCategory is the resolver for the createCategory field.
func (r *mutationResolver) CreateCategory(ctx context.Context, input model.NewCategory) (*model.ID, error) {
	ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()

	req := &mPB.Category{
		Name:        input.Name,
		ParentId:    *input.ParentID,
		HasSubclass: *input.HasSubclass,
		Status:      int32(input.Status),
		Sort:        int32(input.Sort),
	}

	res, err := r.managementService.CreateCategory(ctx, req)

	if err != nil {
		log.Println(err)
		return nil, err
	}

	return &model.ID{ID: res.Value}, nil
}

// UpdateCategory is the resolver for the updateCategory field.
func (r *mutationResolver) UpdateCategory(ctx context.Context, input model.UpdateCategory) (*model.Result, error) {
	ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()

	req := &mPB.Category{
		Id:          input.ID,
		Name:        *input.Name,
		ParentId:    *input.ParentID,
		HasSubclass: *input.HasSubclass,
		Status:      int32(*input.Status),
		Sort:        int32(*input.Sort),
	}

	res, err := r.managementService.UpdateCategory(ctx, req)

	if err != nil {
		log.Println(err)
		return nil, err
	}

	return &model.Result{Succed: &res.Value}, nil
}

// CreateTag is the resolver for the createTag field.
func (r *mutationResolver) CreateTag(ctx context.Context, input model.NewTag) (*model.ID, error) {
	ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()

	req := &mPB.Tag{
		Name:       input.Name,
		CategoryId: input.CategoryID,
		Status:     int32(input.Status),
	}

	res, err := r.managementService.CreateTag(ctx, req)

	if err != nil {
		log.Println(err)
		return nil, err
	}

	return &model.ID{ID: res.Value}, nil
}

// UpdateTag is the resolver for the updateTag field.
func (r *mutationResolver) UpdateTag(ctx context.Context, input model.UpdateTag) (*model.Result, error) {
	ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()

	req := &mPB.Tag{
		Id:         input.ID,
		Name:       *input.Name,
		CategoryId: *input.CategoryID,
		Status:     int32(*input.Status),
	}

	res, err := r.managementService.UpdateTag(ctx, req)

	if err != nil {
		log.Println(err)
		return nil, err
	}

	return &model.Result{Succed: &res.Value}, nil
}

// UpdateConfigs is the resolver for the updateConfigs field.
func (r *mutationResolver) UpdateConfigs(ctx context.Context, input map[string]any) (map[string]any, error) {
	data := []*mPB.Config{}
	for k, v := range input {
		data = append(data, &mPB.Config{Key: k, Value: fmt.Sprintf("%v", v)})
	}
	if _, err := r.managementService.UpdateConfigs(ctx, &mPB.ConfigRequest{Data: data}); err != nil {
		return nil, err
	}

	r.auditing(ctx, AuditingCodeConfigs, "更新系统配置", input)

	return input, nil
}

// UpdateTurtleBackConfig is the resolver for the updateTurtleBackConfig field.
func (r *mutationResolver) UpdateTurtleBackConfig(ctx context.Context, input model.UpdateTurtleBackConfig) (*model.Result, error) {
	ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()

	req := &mPB.TurtleBackConfig{
		Id:             input.ID,
		Sort:           int32(NotNilInt(input.Sort, 0)),
		MenuConfigName: NotNilString(input.MenuConfigName, ""),
		MenuName:       NotNilString(input.MenuName, ""),
		Path:           NotNilString(input.Path, ""),
		MenuCode:       NotNilString(input.MenuCode, ""),
		Enable:         NotNilBool(&input.Enable, false),
		IconPath:       NotNilString(input.IconPath, ""),
	}

	res, err := r.managementService.UpdateTurtleBackConfig(ctx, req)

	if err != nil {
		log.Println(err)
		return nil, err
	}

	return &model.Result{Succed: &res.Value}, nil
}

// CreateTideSpot is the resolver for the createTideSpot field.
func (r *mutationResolver) CreateTideSpot(ctx context.Context, input model.NewTideSpot) (*model.ID, error) {
	ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()

	req := &mPB.TideSpot{
		Name:              input.Name,
		PositionTolerance: NotNilString(input.PositionTolerance, ""),
		ElectricFence:     NotNilString(&input.ElectricFence, ""),
	}

	res, err := r.managementService.CreateTideSpot(ctx, req)

	if err != nil {
		log.Println(err)
		return nil, err
	}

	return &model.ID{ID: res.Value}, nil
}

// UpdateTideSpot is the resolver for the updateTideSpot field.
func (r *mutationResolver) UpdateTideSpot(ctx context.Context, input *model.UpdateTideSpot) (*model.Result, error) {
	ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()

	req := &mPB.TideSpot{
		Id:                input.ID,
		Name:              NotNilString(input.Name, ""),
		PositionTolerance: NotNilString(input.PositionTolerance, ""),
		ElectricFence:     NotNilString(input.ElectricFence, ""),
		Status:            int32(NotNilInt(input.Status, 1)),
	}

	res, err := r.managementService.UpdateTideSpot(ctx, req)

	if err != nil {
		log.Println(err)
		return nil, err
	}

	return &model.Result{Succed: &res.Value}, nil
}

// CreateTideSpotConfig is the resolver for the CreateTideSpotConfig field.
func (r *mutationResolver) CreateTideSpotConfig(ctx context.Context, input model.NewTideSpotConfig) (*model.ID, error) {
	ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()
	//logoImg, _ := os.ReadFile(NotNilString(input.CouponImgPath, ""))

	req := &mPB.TideSpotConfig{
		TideSpotId:      NotNilString(&input.TideSpotID, ""),
		TideSpotName:    NotNilString(&input.TideSpotName, ""),
		CouponName:      NotNilString(&input.CouponName, ""),
		CompareWord:     NotNilString(input.CompareWord, ""),
		CouponImgPath:   NotNilString(input.CouponImgPath, ""),
		CompareLogoPath: NotNilString(input.CompareLogoPath, ""),
		Desc:            NotNilString(input.Desc, ""),
		EffectiveTime:   int32(NotNilInt(input.EffectiveTime, 0)),
		CouponContent:   NotNilString(input.CouponContent, ""),
		Type:            NotNilString(&input.Type, ""),
	}
	res, err := r.managementService.CreateTideSpotConfig(ctx, req)

	if err != nil {
		log.Println(err)
		return nil, err
	}
	if input.TideSpotGoodListJSON != nil && len(*input.TideSpotGoodListJSON) > 0 {
		// tideSpotGoodList := make([]*mPB.TideSpotGood, 0)
		tideSpotGoodList := make([]map[string]interface{}, 0)
		json.Unmarshal([]byte(*input.TideSpotGoodListJSON), &tideSpotGoodList)
		for _, good := range tideSpotGoodList {
			goodReq := &mPB.TideSpotGood{
				GoodName:         good["goodName"].(string),
				GoodBarcode:      good["goodBarcode"].(string),
				TideSpotConfigId: res.Value,
			}
			_, goodErr := r.managementService.CreateTideSpotGood(ctx, goodReq)
			if goodErr != nil {
				log.Println(goodErr)
				return nil, goodErr
			}
		}
	}
	if err != nil {
		log.Println(err)
		return nil, err
	}

	// 上传logo
	ocr.UploadLogo(*input.CompareLogoPath, res.Value)
	return &model.ID{ID: res.Value}, nil
}

// UpdateTideSpotConfig is the resolver for the updateTideSpotConfig field.
func (r *mutationResolver) UpdateTideSpotConfig(ctx context.Context, input model.UpdateTideSpotConfig) (*model.Result, error) {
	ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()

	req := &mPB.TideSpotConfig{
		Id:             input.ID,
		GuideDesc:      NotNilString(input.GuideDesc, ""),
		GuideVideoPath: NotNilString(input.GuideVideoPath, ""),
		Enable:         NotNilBool(input.Enable, false),
	}

	res, err := r.managementService.UpdateTideSpotConfig(ctx, req)

	if err != nil {
		log.Println(err)
		return nil, err
	}

	return &model.Result{Succed: &res.Value}, nil
}

// CreateCoupon is the resolver for the createCoupon field.
func (r *mutationResolver) CreateCoupon(ctx context.Context, input model.NewCoupon) (*model.ID, error) {
	ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()
	tideSpotConfigParam := mPB.MsKeyword{
		Value: input.TideSpotConfigID,
	}
	tideSpotConfig, err := r.managementService.GetTideSpotConfigById(ctx, &tideSpotConfigParam)
	if err != nil {
		log.Println(err)
		return nil, err
	}
	cur := auth.ForContext(ctx)
	v := model.Token{}

	if cur != nil {
		r.DB.Collection("session").FindOne(ctx, bson.D{{Key: "key", Value: cur.Token}}).Decode(&v)
	}
	u, err := auth.ParseToken(v.Value)
	account, err := r.accountService.GetAccount(ctx, &aPB.AsKeyword{Value: u.Id})
	if err != nil {
		log.Println(err)
		return nil, err
	}
	profile, err := r.accountService.GetProfileByUserID(ctx, &aPB.AsKeyword{Value: account.Id})
	if err != nil {
		log.Println(err)
		return nil, err
	}
	req := &mPB.Coupon{
		TideSpotConfigId:  input.TideSpotConfigID,
		SubmitWord:        input.SubmitWord,
		SubmitImgPath:     input.SubmitImgPath,
		SubmitLogoImgPath: input.SubmitLogoImgPath,
		Type:              tideSpotConfig.Type,
		TideSpotId:        tideSpotConfig.TideSpotId,
		TideSpotName:      tideSpotConfig.TideSpotName,
		CouponName:        tideSpotConfig.CouponName,
		GenerateWord:      tideSpotConfig.CompareWord,
		GenerateImgPath:   tideSpotConfig.CouponImgPath,
		Desc:              tideSpotConfig.Desc,
		DeductionAmount:   tideSpotConfig.DeductionAmount,
		MinimumAmount:     tideSpotConfig.MinimumAmount,
		EffectiveTime:     int32(tideSpotConfig.EffectiveTime),
		UserWechat:        account.GetWechat(),
		UserWechatName:    account.WechatName,
		UserPhone:         profile.Phone,
	}

	res, err := r.managementService.CreateCoupon(ctx, req)
	if err != nil {
		log.Println(err)
		return nil, err
	}
	req.Id = res.Value

	// 更新配置
	r.UpdateTideSpotConfigFromGenerateCoupon(ctx, tideSpotConfig)
	code := r.UpdateQRCode(req)
	updateReq := &mPB.Coupon{
		Id:         res.Value,
		QrCodePath: code,
	}
	_, err = r.managementService.UpdateCoupon(ctx, updateReq)
	if err != nil {
		log.Println(err)
		return nil, err
	}
	return &model.ID{ID: res.Value}, nil
}

// CreateCouponByOcr is the resolver for the createCouponByOcr field.
func (r *mutationResolver) CreateCouponByOcr(ctx context.Context, input *model.OcrImgPath) (*model.OcrRes, error) {
	logoRes, err := ocr.OcrLogo(input.LogoImgPath)
	if err != nil {
		log.Println("BAIDUOCR:" + merr.Parse(err.Error()).Detail)
	}
	if !logoRes {
		failMsg := "不好意思，您不符合生成优惠券资格"
		couponID := ""
		return &model.OcrRes{
			CouponID: &couponID,
			Msg:      &failMsg,
		}, nil
	}
	text, err := ocr.OcrText(input.TextImgPath)
	if err != nil {
		log.Println("WXOCR:" + merr.Parse(err.Error()).Detail)
	}
	tideSpotConfig, err := r.managementService.GetTideSpotConfigById(ctx, &mPB.MsKeyword{
		Value: input.TideSpotConfigID,
	})
	if err != nil {
		log.Println("WXOCR:" + merr.Parse(err.Error()).Detail)
	}
	word := tideSpotConfig.GetCompareWord()
	replaceWord := strings.Replace(word, "，", ",", -1)
	parts := strings.Split(replaceWord, ",")
	for _, part := range parts {
		if !strings.Contains(text, part) {
			failMsg := "不好意思，您不符合生成优惠券资格"
			couponID := ""
			return &model.OcrRes{
				CouponID: &couponID,
				Msg:      &failMsg,
			}, nil
		}

	}
	req := &model.NewCoupon{
		TideSpotConfigID:  NotNilString(&input.TideSpotConfigID, ""),
		SubmitImgPath:     NotNilString(&input.TextImgPath, ""),
		SubmitLogoImgPath: NotNilString(&input.LogoImgPath, ""),
		SubmitWord:        NotNilString(&input.TextImgPath, ""),
	}
	coupon, err := r.CreateCoupon(ctx, *req)
	if err != nil {
		log.Println(err)
		return nil, err
	}
	typeText := ""
	if tideSpotConfig.Type == "Exchange" {
		typeText = "兑换券"
	} else {
		typeText = "抵扣券"
	}
	successMsg := fmt.Sprintf("恭喜，获取了%s【%s】1张，请到个人中心查看", typeText, tideSpotConfig.CouponName)
	return &model.OcrRes{
		CouponID: &coupon.ID,
		Msg:      &successMsg,
	}, nil
}

// UpdateCoupon is the resolver for the updateCoupon field.
func (r *mutationResolver) UpdateCoupon(ctx context.Context, input model.UpdateCoupon) (*model.Result, error) {
	ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()

	req := &mPB.Coupon{
		Id:  input.ID,
		Use: *input.Use,
	}

	res, err := r.managementService.UpdateCoupon(ctx, req)
	if input.CouponBuyGoodListJSON != nil && len(*input.CouponBuyGoodListJSON) > 0 {
		// tideSpotGoodList := make([]*mPB.TideSpotGood, 0)
		buyGoodList := make([]map[string]interface{}, 0)
		json.Unmarshal([]byte(*input.CouponBuyGoodListJSON), &buyGoodList)
		for _, good := range buyGoodList {
			goodReq := &mPB.CouponBuyGood{
				GoodName:    good["goodName"].(string),
				GoodBarcode: good["goodBarcode"].(string),
				CouponId:    input.ID,
			}
			_, goodErr := r.managementService.CreateCouponBuyGood(ctx, goodReq)
			if goodErr != nil {
				log.Println(goodErr)
				return nil, goodErr
			}
		}
	}
	if err != nil {
		log.Println(err)
		return nil, err
	}
	// todo 更新配置
	coupon, err := r.managementService.GetCoupon(ctx, &mPB.MsKeyword{
		Value: input.ID,
	})
	if err != nil {
		log.Println(err)
		return nil, err
	}
	tideSpotConfig, err := r.managementService.GetTideSpotConfigById(ctx, &mPB.MsKeyword{
		Value: coupon.TideSpotConfigId,
	})
	if err != nil {
		log.Println(err)
		return nil, err
	}
	r.UpdateTideSpotConfigFromUseCoupon(ctx, tideSpotConfig)
	return &model.Result{Succed: &res.Value}, nil
}

// UpdateCouponToRead is the resolver for the updateCouponToRead field.
func (r *mutationResolver) UpdateCouponToRead(ctx context.Context) (*model.Result, error) {
	ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()
	curUser := auth.ForContext(ctx).User
	req := &mPB.Coupon{
		UserWechat: curUser.Wechat,
		Read:       true,
	}

	res, err := r.managementService.UpdateCouponToRead(ctx, req)
	if err != nil {
		log.Println(err)
		return nil, err
	}
	return &model.Result{Succed: &res.Value}, nil
}

// CreateEvent is the resolver for the createEvent field.
func (r *mutationResolver) CreateEvent(ctx context.Context, input model.NewEvent) (*model.ID, error) {
	ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()

	req := &ePB.Event{
		Code:         input.Code,
		Name:         input.Name,
		StartTime:    int32(input.StartTime),
		EndTime:      int32(input.EndTime),
		Introduction: NotNilString(input.Introduction, ""),
		Images:       NotNilString(input.Images, ""),
		Step:         NotNilString(input.Step, ""),
		Status:       int32(input.Status),
		EnableAward:  NotNilBool(input.EnableAward, false),
		CategoryId:   NotNilString(input.CategoryID, ""),
	}

	res, err := r.eventService.CreateEvent(ctx, req)

	if err != nil {
		log.Println(err)
		return nil, err
	}

	return &model.ID{ID: res.Value}, nil
}

// UpdateEvent is the resolver for the updateEvent field.
func (r *mutationResolver) UpdateEvent(ctx context.Context, input model.UpdateEvent) (*model.Result, error) {
	ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()

	req := &ePB.Event{
		Id:           input.ID,
		Code:         NotNilString(input.Code, ""),
		Name:         NotNilString(input.Name, ""),
		StartTime:    int32(NotNilInt(input.StartTime, 0)),
		EndTime:      int32(NotNilInt(input.EndTime, 0)),
		Introduction: NotNilString(input.Introduction, ""),
		Images:       NotNilString(input.Images, ""),
		Step:         NotNilString(input.Step, ""),
		Status:       int32(NotNilInt(input.Status, 0)),
		EnableAward:  NotNilBool(input.EnableAward, false),
		CategoryId:   NotNilString(input.CategoryID, ""),
	}

	res, err := r.eventService.UpdateEvent(ctx, req)

	if err != nil {
		log.Println(err)
		return nil, err
	}

	return &model.Result{Succed: &res.Value}, nil
}

// CreateEventScenerySpots is the resolver for the createEventScenerySpots field.
func (r *mutationResolver) CreateEventScenerySpots(ctx context.Context, input model.InputEventSceneryspot) (*model.EventSceneryspot, error) {
	ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()

	req := &ePB.EventScenerySpots{
		EventId:       input.EventID,
		ScenerySpotId: input.ScenerySpotID,
	}

	res, err := r.eventService.CreateEventScenerySpots(ctx, req)

	if err != nil {
		log.Println(err)
		return nil, err
	}

	return &model.EventSceneryspot{
		EventID:       res.EventId,
		ScenerySpotID: res.ScenerySpotId,
	}, nil
}

// RemoveEventScenerySpots is the resolver for the removeEventScenerySpots field.
func (r *mutationResolver) RemoveEventScenerySpots(ctx context.Context, input model.InputEventSceneryspot) (*model.Result, error) {
	ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()

	req := &ePB.EventScenerySpots{
		EventId:       input.EventID,
		ScenerySpotId: input.ScenerySpotID,
	}

	res, err := r.eventService.RemoveEventScenerySpots(ctx, req)

	if err != nil {
		log.Println(err)
		return nil, err
	}

	return &model.Result{Succed: &res.Value}, nil
}

// CreateBadge is the resolver for the createBadge field.
func (r *mutationResolver) CreateBadge(ctx context.Context, input model.NewBadge) (*model.ID, error) {
	ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()

	req := &ePB.Badge{
		EventId: input.EventID,
		Name:    input.Name,
		Images:  *input.Images,
	}

	res, err := r.eventService.CreateBadge(ctx, req)

	if err != nil {
		log.Println(err)
		return nil, err
	}

	return &model.ID{ID: res.Value}, nil
}

// UpdateBadge is the resolver for the updateBadge field.
func (r *mutationResolver) UpdateBadge(ctx context.Context, input model.UpdateBadge) (*model.Result, error) {
	ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()

	req := &ePB.Badge{
		Id:     input.ID,
		Name:   *input.Name,
		Images: *input.Images,
	}

	res, err := r.eventService.UpdateBadge(ctx, req)

	if err != nil {
		log.Println(err)
		return nil, err
	}

	return &model.Result{Succed: &res.Value}, nil
}

// DeleteBadge is the resolver for the deleteBadge field.
func (r *mutationResolver) DeleteBadge(ctx context.Context, input []string) ([]*model.Badge, error) {
	if len(input) == 0 {
		return []*model.Badge{}, nil
	}
	out, err := r.eventService.DeleteBadge(ctx, &ePB.Badge{Id: input[0]})
	if err != nil {
		return nil, err
	}

	result := make([]*model.Badge, len(out.Data))
	for i, v := range out.Data {
		result[i] = &model.Badge{
			ID:      v.Id,
			Name:    v.Name,
			EventID: v.EventId,
			Images:  &v.Images,
		}
	}
	return result, nil
}

// CreateUserBadge is the resolver for the createUserBadge field.
func (r *mutationResolver) CreateUserBadge(ctx context.Context, input model.InputUserBadge) (*model.UserBadge, error) {
	ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()

	req := &ePB.UserBadge{
		UserId:  input.UserID,
		BadgeId: input.BadgeID,
		Status:  int32(input.Status),
	}

	res, err := r.eventService.CreateUserBadge(ctx, req)

	if err != nil {
		log.Println(err)
		return nil, err
	}

	return &model.UserBadge{
		UserID:  res.UserId,
		BadgeID: res.BadgeId,
		Status:  int(res.Status),
	}, nil
}

// UpdateUserBadge is the resolver for the updateUserBadge field.
func (r *mutationResolver) UpdateUserBadge(ctx context.Context, input model.InputUserBadge) (*model.Result, error) {
	ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()

	req := &ePB.UserBadge{
		UserId:  input.UserID,
		BadgeId: input.BadgeID,
		Status:  int32(input.Status),
	}

	res, err := r.eventService.UpdateUserBadge(ctx, req)

	if err != nil {
		log.Println(err)
		return nil, err
	}

	return &model.Result{Succed: &res.Value}, nil
}

// RemoveUserBadge is the resolver for the removeUserBadge field.
func (r *mutationResolver) RemoveUserBadge(ctx context.Context, input model.InputUserBadge) (*model.Result, error) {
	ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()

	req := &ePB.UserBadge{
		UserId:  input.UserID,
		BadgeId: input.BadgeID,
		Status:  int32(input.Status),
	}

	res, err := r.eventService.RemoveUserBadge(ctx, req)

	if err != nil {
		log.Println(err)
		return nil, err
	}

	return &model.Result{Succed: &res.Value}, nil
}

// CreateUserBadgeSwap is the resolver for the createUserBadgeSwap field.
func (r *mutationResolver) CreateUserBadgeSwap(ctx context.Context, input model.NewUserBadgeSwap) (*model.ID, error) {
	ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()

	req := &ePB.UserBadgeSwap{
		BadgeId:    input.BadgeID,
		From:       input.From,
		To:         *input.To,
		PreviousId: *input.PreviousID,
		City:       *input.City,
		Content:    *input.Content,
		Status:     int32(input.Status),
		CreateTime: int32(input.CreateTime),
	}

	res, err := r.eventService.CreateUserBadgeSwap(ctx, req)

	if err != nil {
		log.Println(err)
		return nil, err
	}

	return &model.ID{ID: res.Value}, nil
}

// UpdateUserBadgeSwap is the resolver for the updateUserBadgeSwap field.
func (r *mutationResolver) UpdateUserBadgeSwap(ctx context.Context, input model.UpdateUserBadgeSwap) (*model.Result, error) {
	ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()

	req := &ePB.UserBadgeSwap{
		Id:      input.ID,
		To:      *input.To,
		City:    *input.City,
		Content: *input.Content,
		Status:  int32(input.Status),
	}

	res, err := r.eventService.UpdateUserBadgeSwap(ctx, req)

	if err != nil {
		log.Println(err)
		return nil, err
	}

	return &model.Result{Succed: &res.Value}, nil
}

// CreatePassportSet is the resolver for the createPassportSet field.
func (r *mutationResolver) CreatePassportSet(ctx context.Context, input model.NewPassportSet) (*model.ID, error) {
	ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()

	req := &ePB.PassportSet{
		EventId:  input.EventID,
		Name:     input.Name,
		Status:   int32(input.Status),
		Quantity: int32(input.Quantity),
		Issued:   int32(input.Issued),
	}

	res, err := r.eventService.CreatePassportSet(ctx, req)

	if err != nil {
		log.Println(err)
		return nil, err
	}

	return &model.ID{ID: res.Value}, nil
}

// UpdatePassportSet is the resolver for the updatePassportSet field.
func (r *mutationResolver) UpdatePassportSet(ctx context.Context, input model.UpdatePassportSet) (*model.Result, error) {
	ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()

	req := &ePB.PassportSet{
		Id:       input.ID,
		Name:     *input.Name,
		Status:   int32(*input.Status),
		Quantity: int32(*input.Quantity),
		Issued:   int32(*input.Issued),
	}

	res, err := r.eventService.UpdatePassportSet(ctx, req)

	if err != nil {
		log.Println(err)
		return nil, err
	}

	return &model.Result{Succed: &res.Value}, nil
}

// CreatePassport is the resolver for the createPassport field.
func (r *mutationResolver) CreatePassport(ctx context.Context, input model.NewPassport) (*model.ID, error) {
	ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()

	req := &ePB.Passport{
		PassportSetId: input.PassportSetID,
		Code:          input.Code,
		Status:        int32(input.Status),
	}

	res, err := r.eventService.CreatePassport(ctx, req)

	if err != nil {
		log.Println(err)
		return nil, err
	}

	return &model.ID{ID: res.Value}, nil
}

// UpdatePassport is the resolver for the updatePassport field.
func (r *mutationResolver) UpdatePassport(ctx context.Context, input model.UpdatePassport) (*model.Result, error) {
	ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()

	req := &ePB.Passport{
		Id:     input.ID,
		Code:   *input.Code,
		Status: int32(*input.Status),
	}

	res, err := r.eventService.UpdatePassport(ctx, req)

	if err != nil {
		log.Println(err)
		return nil, err
	}

	return &model.Result{Succed: &res.Value}, nil
}

// ImportPassports is the resolver for the importPassports field.
func (r *mutationResolver) ImportPassports(ctx context.Context, input model.NewPassports) (*model.Result, error) {
	ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()

	succed := true

	for _, pc := range input.PassportCode {

		passport := &ePB.Passport{
			PassportSetId: input.PassportSetID,
			Code:          *pc,
			Status:        0,
		}

		_, err := r.eventService.CreatePassport(ctx, passport)

		if err != nil {
			return nil, err
		}

	}

	return &model.Result{Succed: &succed}, nil
}

// CreateUserPassport is the resolver for the createUserPassport field.
func (r *mutationResolver) CreateUserPassport(ctx context.Context, input model.NewUserPassport) (*model.ID, error) {
	ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()
	cur := auth.ForContext(ctx).User

	req := &ePB.UserPassport{
		Id:             NewID(),
		UserId:         input.UserID,
		EventId:        input.EventID,
		PassportCode:   NotNilString(input.PassportCode, ""),
		RealName:       NotNilString(input.RealName, ""),
		Nric:           NotNilString(input.Nric, ""),
		Phone:          NotNilString(input.Phone, ""),
		Gender:         NotNilString(input.Gender, ""),
		Profession:     NotNilString(input.Profession, ""),
		Authentication: NotNilBool(input.Authentication, false),
		GuardianName:   NotNilString(input.GuardianName, ""),
		GuardianNric:   NotNilString(input.GuardianNric, ""),
		GuardianPhone:  NotNilString(input.GuardianPhone, ""),
		ClaimCode:      NotNilString(input.PassportCode, ""),
		ClaimBy:        cur.Id,
		ClaimTime:      int32(time.Now().Unix()),
		Status:         1,
		CreateTime:     int32(time.Now().Unix()),
	}

	res, err := r.eventService.CreateUserPassport(ctx, req)
	if err != nil {
		detail := merr.Parse(err.Error()).Detail
		if detail == "invalid passport" {
			return nil, errors.New("无效护照，如有疑问请联系微信客服")
		}
		if detail == "passport already activated" {
			return nil, errors.New("护照已被激活，如有疑问请联系微信客服")
		}
		if detail == "invalid activate" {
			return nil, errors.New("请勿重复激活，如有疑问请联系微信客服")
		}
		return nil, err
	}

	var age, birthday int32
	if input.Nric != nil && len(*input.Nric) > 0 {
		nric := *input.Nric
		if v, err := time.Parse("20060102", nric[6:14]); err == nil {
			birthday = int32(v.Unix())
			age = int32(time.Now().Sub(v).Hours() / 24 / 365)
		}
	}
	if _, err := r.accountService.UpdateProfile(ctx, &aPB.Profile{
		Id:             input.UserID,
		Name:           NotNilString(input.RealName, ""),
		Authentication: NotNilBool(input.Authentication, false),
		Nric:           NotNilString(input.Nric, ""),
		Phone:          NotNilString(input.Phone, ""),
		Gender:         NotNilString(input.Gender, ""),
		Profession:     NotNilString(input.Profession, ""),
		Age:            age,
		Birthday:       birthday,
		GuardianName:   NotNilString(input.GuardianName, ""),
		GuardianNric:   NotNilString(input.GuardianNric, ""),
		GuardianPhone:  NotNilString(input.GuardianPhone, ""),
	}); err != nil {
		logger.Error(err)
	}

	return &model.ID{ID: res.Value}, nil
}

// UpdateUserPassport is the resolver for the updateUserPassport field.
func (r *mutationResolver) UpdateUserPassport(ctx context.Context, input model.UpdateUserPassport) (*model.Result, error) {
	ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()

	srv := r.eventService
	succed := true

	if input.Status != nil && *input.Status == 4 {
		out, err := srv.DeleteUserPassport(ctx, &ePB.EsKeyword{Value: input.ID})
		if err != nil {
			return nil, err
		}
		r.auditing(ctx, AuditingCodeEvent, "还原护照", map[string]interface{}{"data": out.Data})
		return &model.Result{Succed: &succed}, nil
	}

	if input.PassportCode != nil && len(*input.PassportCode) == 0 {
		out, err := srv.UnbindUserPassport(ctx, &ePB.EsKeyword{Value: input.ID})
		if err != nil {
			return nil, err
		}
		fmt.Println(out.Data)
		r.auditing(ctx, AuditingCodeEvent, "解除护照", map[string]interface{}{"data": out.Data})
		return &model.Result{Succed: &succed}, nil
	}

	cur := auth.ForContext(ctx).User
	in := &ePB.UserPassport{Id: input.ID}
	if input.UserID != nil && len(*input.UserID) > 0 {
		in.UserId = *input.UserID
	}
	if input.PassportCode != nil && len(*input.PassportCode) > 0 {
		in.PassportCode = *input.PassportCode
		in.ClaimCode = *input.PassportCode
		in.ClaimBy = cur.Id
		in.ClaimTime = int32(time.Now().Unix())
		in.Status = 3
	}
	if input.EventID != nil && len(*input.EventID) > 0 {
		in.EventId = *input.EventID
	}
	if input.CampID != nil && len(*input.CampID) > 0 {
		in.UserCampId = *input.CampID
	}

	out, err := r.eventService.UpdateUserPassport(ctx, in)
	if err != nil {
		detail := merr.Parse(err.Error()).Detail
		if detail == "invalid passport" {
			return nil, errors.New("无效的护照号码，请重新输入")
		}
		if detail == "passport already activated" {
			return nil, errors.New("护照号码已被激活，请勿重复激活")
		}
		return nil, err
	}
	r.auditing(ctx, AuditingCodeEvent, "绑定护照", input)

	return &model.Result{Succed: &out.Value}, nil
}

// RemoveUserPassport is the resolver for the removeUserPassport field.
func (r *mutationResolver) RemoveUserPassport(ctx context.Context, id string) (*model.Result, error) {
	ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()

	req := &ePB.EsKeyword{
		Value: id,
	}

	res, err := r.eventService.RemoveUserPassport(ctx, req)

	if err != nil {
		return nil, err
	}

	return &model.Result{Succed: &res.Value}, nil
}

// PickupUserPassport is the resolver for the pickupUserPassport field.
func (r *mutationResolver) PickupUserPassport(ctx context.Context, input model.PickupUserPassport) (*model.ID, error) {
	ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()

	req := &ePB.PickupPassportReq{
		UserId:     input.UserID,
		EventId:    input.EventID,
		RealName:   *input.RealName,
		Nric:       input.Nric,
		Phone:      input.Phone,
		Gender:     input.Gender,
		Profession: input.Profession,
		Age:        int32(input.Age),
	}

	res, err := r.eventService.PickupUserPassport(ctx, req)

	if err != nil {
		return nil, err
	}

	return &model.ID{ID: res.Value}, nil
}

// UpdateGuardianInfo is the resolver for the updateGuardianInfo field.
func (r *mutationResolver) UpdateGuardianInfo(ctx context.Context, input model.UpdateGuardianInfo) (*model.Result, error) {
	ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()

	req := &ePB.GuardianInfoReq{
		Id:            input.ID,
		GuardianName:  input.GuardianName,
		GuardianNric:  input.GuardianNric,
		GuardianPhone: input.GuardianPhone,
	}

	res, err := r.eventService.UpdateGuardianInfo(ctx, req)

	if err != nil {
		return nil, err
	}

	return &model.Result{Succed: &res.Value}, nil
}

// VerifyUserPassport is the resolver for the verifyUserPassport field.
func (r *mutationResolver) VerifyUserPassport(ctx context.Context, input model.VerifyUserPassport) (*model.Result, error) {
	ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()

	req := &ePB.VerifyPassportReq{
		Id:     input.ID,
		Verify: input.Verify,
	}

	res, err := r.eventService.VerifyUserPassport(ctx, req)

	if err != nil {
		return nil, err
	}

	return &model.Result{Succed: &res.Value}, nil
}

// ActivateUserPassport is the resolver for the activateUserPassport field.
func (r *mutationResolver) ActivateUserPassport(ctx context.Context, input model.ActivateUserPassport) (*model.Result, error) {
	ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()

	req := &ePB.ActivatePassportReq{
		UserId:       input.UserID,
		EventId:      input.EventID,
		PassportCode: input.PassportCode,
	}

	res, err := r.eventService.ActivateUserPassport(ctx, req)

	if err != nil {
		return nil, err
	}

	return &model.Result{Succed: &res.Value}, nil
}

// CreateCamp is the resolver for the createCamp field.
func (r *mutationResolver) CreateCamp(ctx context.Context, input model.NewCamp) (*model.ID, error) {
	ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()

	categoryID := ""
	if input.CategoryID != nil {
		categoryID = *input.CategoryID
	}

	req := &ePB.Camp{
		EventId:      input.EventID,
		Name:         input.Name,
		Images:       *input.Images,
		Introduction: *input.Introduction,
		Points:       int32(input.Points),
		CategoryId:   categoryID,
	}

	res, err := r.eventService.CreateCamp(ctx, req)

	if err != nil {
		log.Println(err)
		return nil, err
	}

	return &model.ID{ID: res.Value}, nil
}

// UpdateCamp is the resolver for the updateCamp field.
func (r *mutationResolver) UpdateCamp(ctx context.Context, input model.UpdateCamp) (*model.Result, error) {
	ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()

	req := &ePB.Camp{
		Id:           input.ID,
		Name:         NotNilString(input.Name, ""),
		Images:       NotNilString(input.Images, ""),
		Introduction: NotNilString(input.Introduction, ""),
		Points:       int32(NotNilInt(input.Points, 0)),
		Status:       int32(NotNilInt(input.Status, 0)),
		CategoryId:   NotNilString(input.CategoryID, ""),
	}

	res, err := r.eventService.UpdateCamp(ctx, req)
	if err != nil {
		return nil, err
	}

	return &model.Result{Succed: &res.Value}, nil
}

// CreateHonour is the resolver for the createHonour field.
func (r *mutationResolver) CreateHonour(ctx context.Context, input model.NewHonour) (*model.ID, error) {
	ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()

	req := &ePB.Honour{
		CampId:    input.CampID,
		Name:      input.Name,
		Images:    *input.Images,
		MinPoints: int32(input.MinPoints),
		MaxPoints: int32(input.MaxPoints),
		Status:    int32(input.Status),
	}

	res, err := r.eventService.CreateHonour(ctx, req)

	if err != nil {
		log.Println(err)
		return nil, err
	}

	return &model.ID{ID: res.Value}, nil
}

// UpdateHonour is the resolver for the updateHonour field.
func (r *mutationResolver) UpdateHonour(ctx context.Context, input model.UpdateHonour) (*model.Result, error) {
	ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()

	req := &ePB.Honour{
		Id:        input.ID,
		Name:      NotNilString(input.Name, ""),
		Images:    NotNilString(input.Images, ""),
		MinPoints: int32(NotNilInt(input.MinPoints, 0)),
		MaxPoints: int32(NotNilInt(input.MaxPoints, 0)),
		Status:    int32(NotNilInt(input.Status, 0)),
	}

	res, err := r.eventService.UpdateHonour(ctx, req)

	if err != nil {
		log.Println(err)
		return nil, err
	}

	return &model.Result{Succed: &res.Value}, nil
}

// CreateUserCamp is the resolver for the createUserCamp field.
func (r *mutationResolver) CreateUserCamp(ctx context.Context, input model.NewUserCamp) (*model.ID, error) {
	ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()

	honours, err := r.eventService.GetHonourByCampID(ctx, &ePB.EsKeyword{Value: input.CampID})
	if err != nil {
		return nil, err
	}

	honourID := ""
	for _, v := range honours.Data {
		if input.Points >= int(v.MinPoints) && input.Points <= int(v.MaxPoints) {
			honourID = v.Id
		}
	}

	req := &ePB.UserCamp{
		UserId:     input.UserID,
		CampId:     input.CampID,
		Honour:     honourID,
		Points:     int32(input.Points),
		Status:     int32(input.Status),
		EventId:    input.EventID,
		PassportId: input.PassportID,
	}

	res, err := r.eventService.CreateUserCamp(ctx, req)

	if err != nil {
		log.Println(err)
		return nil, err
	}

	return &model.ID{ID: res.Value}, nil
}

// UpdateUserCamp is the resolver for the updateUserCamp field.
func (r *mutationResolver) UpdateUserCamp(ctx context.Context, input model.UpdateUserCamp) (*model.Result, error) {
	ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()

	in := ePB.UserCamp{
		UserId: input.UserID,
		CampId: input.CampID,
	}
	if input.Points != nil {
		in.Points = int32(*input.Points)
	}
	if input.StampCount != nil {
		in.StampCount = int32(*input.StampCount)
	}
	if input.Status != nil {
		in.Status = int32(*input.Status)
	}

	out, err := r.eventService.UpdateUserCamp(ctx, &in)
	if err != nil {
		return nil, err
	}

	return &model.Result{Succed: &out.Value}, nil
}

// CreateNotification is the resolver for the createNotification field.
func (r *mutationResolver) CreateNotification(ctx context.Context, input model.NewNotification) (*model.ID, error) {
	ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()

	req := &msgPB.Notification{
		Name:         input.Name,
		CategoryId:   input.CategoryID,
		Content:      input.Content,
		Sender:       input.Sender,
		ReleaseTime:  int32(input.ReleaseTime),
		BlockingTime: int32(input.BlockingTime),
	}

	res, err := r.messageService.CreateNotification(ctx, req)

	if err != nil {
		log.Println(err)
		return nil, err
	}

	return &model.ID{ID: res.Value}, nil
}

// UpdateNotification is the resolver for the updateNotification field.
func (r *mutationResolver) UpdateNotification(ctx context.Context, input model.NotificationInput) (*model.Notification, error) {
	out, err := r.messageService.UpdateNotification(ctx, &msgPB.Notification{
		Id:          input.ID,
		Name:        input.Name,
		Content:     input.Content,
		ReleaseTime: int32(time.Now().Unix()),
	})
	if err != nil {
		return nil, err
	}
	if len(out.Data) == 0 {
		return nil, errors.New("修改公告失败")
	}
	r.auditing(ctx, AuditingCodeNotification, "修改公告", out.Data)

	data := out.Data[0]
	result := model.Notification{
		ID:           data.Id,
		Name:         data.Name,
		CategoryID:   data.CategoryId,
		Content:      data.Content,
		Sender:       data.Sender,
		ReleaseTime:  int(data.ReleaseTime),
		BlockingTime: int(data.BlockingTime),
		CreateTime:   int(data.CreateTime),
	}
	return &result, nil
}

// DeleteNotification is the resolver for the deleteNotification field.
func (r *mutationResolver) DeleteNotification(ctx context.Context, input []string) ([]string, error) {
	if len(input) == 0 {
		return []string{}, nil
	}
	out, err := r.messageService.DeleteNotification(ctx, &msgPB.DeleteNotificationRequest{Values: input})
	if err != nil {
		return nil, err
	}
	r.auditing(ctx, AuditingCodeNotification, "删除公告", out.Data)
	return input, nil
}

// UpdateUserNotification is the resolver for the updateUserNotification field.
func (r *mutationResolver) UpdateUserNotification(ctx context.Context, input model.UpdateUserNotification) (*model.Result, error) {
	ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()

	req := &msgPB.UserNotification{
		UserId:         input.UserID,
		NotificationId: input.NotificationID,
		Status:         int32(input.Status),
	}

	res, err := r.messageService.UpdateUserNotification(ctx, req)

	if err != nil {
		log.Println(err)
		return nil, err
	}

	return &model.Result{Succed: &res.Value}, nil
}

// CreateConversation is the resolver for the createConversation field.
func (r *mutationResolver) CreateConversation(ctx context.Context, input model.NewConversation) (*model.Conversation, error) {
	ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()

	curr := auth.ForContext(ctx).User

	in := &msgPB.Conversation{
		Participant: input.Participant,
		From:        curr.Id,
		To:          input.To,
		Content:     input.Content,
		SendTime:    int32(time.Now().Unix()),
		Status:      1,
	}
	if len(in.Participant) == 0 {
		in.Participant = uuid.Must(uuid.NewV4()).String()
	}

	out, err := r.messageService.CreateConversation(ctx, in)
	if err != nil {
		return nil, err
	}

	return r.Query().Conversation(ctx, out.Value)
}

// UpdateConversation is the resolver for the updateConversation field.
func (r *mutationResolver) UpdateConversation(ctx context.Context, input model.UpdateConversation) (*model.Result, error) {
	ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()

	req := &msgPB.Conversation{
		Id:       input.ID,
		ReadTime: int32(time.Now().Unix()),
		Status:   int32(input.Status),
	}

	res, err := r.messageService.UpdateConversation(ctx, req)

	if err != nil {
		log.Println(err)
		return nil, err
	}

	return &model.Result{Succed: &res.Value}, nil
}

// CreateTweet is the resolver for the createTweet field.
func (r *mutationResolver) CreateTweet(ctx context.Context, input model.NewTweet) (*model.ID, error) {
	ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()

	var location, region string
	if input.Location != nil {
		location = *input.Location
	}
	if input.Region != nil {
		region = *input.Region
	}
	req := &msgPB.Tweet{
		UserId:        input.UserID,
		Content:       input.Content,
		EventId:       input.EventID,
		SceneryspotId: input.SceneryspotID,
		Location:      location,
		Region:        region,
	}

	res, err := r.messageService.CreateTweet(ctx, req)

	if err != nil {
		log.Println(err)
		return nil, err
	}

	return &model.ID{ID: res.Value}, nil
}

// UpdateTweet is the resolver for the updateTweet field.
func (r *mutationResolver) UpdateTweet(ctx context.Context, input model.UpdateTweet) (*model.Result, error) {
	ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()

	req := &msgPB.Tweet{
		Id:     input.ID,
		Status: int32(*input.Status),
	}

	res, err := r.messageService.UpdateTweet(ctx, req)

	if err != nil {
		log.Println(err)
		return nil, err
	}

	return &model.Result{Succed: &res.Value}, nil
}

// LikeTweet is the resolver for the likeTweet field.
func (r *mutationResolver) LikeTweet(ctx context.Context, tweetID string, userID string) (*model.Result, error) {
	ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()

	req := &msgPB.TweetReq{
		TweetId: tweetID,
		UserId:  userID,
	}

	res, err := r.messageService.LikeTweet(ctx, req)

	if err != nil {
		log.Println(err)
		return nil, err
	}

	if res.Value {
		if tweet, err := r.messageService.GetTweet(ctx, &msgPB.MsgsKeyword{Value: tweetID}); err == nil {
			if camp, err := r.getUserCamp(ctx, tweet.UserId, tweet.EventId); err == nil && camp != nil {
				curr := auth.ForContext(ctx).User
				points := int32(1)

				if _, err := r.eventService.IncrementEventUserPoints(ctx, &ePB.EventUserPoints{
					UserId:     tweet.UserId,
					EventId:    tweet.EventId,
					CampId:     camp.Id,
					Points:     points,
					CampPoints: points,
				}); err != nil {
					logger.Error(err)
				}
				account, _ := r.accountService.GetAccount(ctx, &aPB.AsKeyword{Value: curr.Id})
				sceneryspot, _ := r.sceneryspotService.GetSceneryspot(ctx, &sPB.SsKeyword{Value: tweet.SceneryspotId})
				up := &aPB.UserPoints{
					UserId:  tweet.UserId,
					EventId: tweet.EventId,
					Content: fmt.Sprintf("%s为%s景区的“印迹分享”点赞，阵营和个人榜加%d分", account.WechatName, sceneryspot.Name, points),
					Op:      "+",
					Points:  points,
				}
				if _, err := r.accountService.AddUserPoints(ctx, up); err == nil {
					r.messageService.CreateConversation(
						ctx,
						&msgPB.Conversation{
							Participant: string(MessageFromSystem),
							To:          up.UserId,
							Content:     up.Content,
							SendTime:    int32(time.Now().Unix()),
							Status:      1,
						},
					)
				}
			}
		}
	}

	return &model.Result{Succed: &res.Value}, nil
}

// UnlikeTweet is the resolver for the unlikeTweet field.
func (r *mutationResolver) UnlikeTweet(ctx context.Context, tweetID string, userID string) (*model.Result, error) {
	ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()

	req := &msgPB.TweetReq{
		TweetId: tweetID,
		UserId:  userID,
	}

	res, err := r.messageService.UnlikeTweet(ctx, req)

	if err != nil {
		log.Println(err)
		return nil, err
	}

	return &model.Result{Succed: &res.Value}, nil
}

// ViewTweet is the resolver for the viewTweet field.
func (r *mutationResolver) ViewTweet(ctx context.Context, tweetID string, userID string) (*model.Result, error) {
	ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()

	req := &msgPB.TweetReq{
		TweetId: tweetID,
		UserId:  userID,
	}

	res, err := r.messageService.ViewTweet(ctx, req)

	if err != nil {
		log.Println(err)
		return nil, err
	}

	return &model.Result{Succed: &res.Value}, nil
}

// ShareTweet is the resolver for the shareTweet field.
func (r *mutationResolver) ShareTweet(ctx context.Context, tweetID string, userID string) (*model.Result, error) {
	ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()

	req := &msgPB.TweetReq{
		TweetId: tweetID,
		UserId:  userID,
	}

	res, err := r.messageService.ShareTweet(ctx, req)

	if err != nil {
		log.Println(err)
		return nil, err
	}

	return &model.Result{Succed: &res.Value}, nil
}

// CreateFollowers is the resolver for the createFollowers field.
func (r *mutationResolver) CreateFollowers(ctx context.Context, input model.InputFollowers) (*model.Result, error) {
	ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()

	req := &msgPB.Followers{
		UserId:   input.UserID,
		Follower: input.Follower,
	}

	res, err := r.messageService.CreateFollowers(ctx, req)

	if err != nil {
		log.Println(err)
		return nil, err
	}

	return &model.Result{Succed: &res.Value}, nil
}

// RemoveFollowers is the resolver for the removeFollowers field.
func (r *mutationResolver) RemoveFollowers(ctx context.Context, input model.InputFollowers) (*model.Result, error) {
	ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()

	req := &msgPB.Followers{
		UserId:   input.UserID,
		Follower: input.Follower,
	}

	res, err := r.messageService.RemoveFollowers(ctx, req)

	if err != nil {
		log.Println(err)
		return nil, err
	}

	return &model.Result{Succed: &res.Value}, nil
}

// CreateFollowing is the resolver for the createFollowing field.
func (r *mutationResolver) CreateFollowing(ctx context.Context, input model.InputFollowing) (*model.Result, error) {
	ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()

	req := &msgPB.Following{
		UserId:    input.UserID,
		Following: input.Following,
	}

	res, err := r.messageService.CreateFollowing(ctx, req)

	if err != nil {
		log.Println(err)
		return nil, err
	}

	return &model.Result{Succed: &res.Value}, nil
}

// RemoveFollowing is the resolver for the removeFollowing field.
func (r *mutationResolver) RemoveFollowing(ctx context.Context, input model.InputFollowing) (*model.Result, error) {
	ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()

	req := &msgPB.Following{
		UserId:    input.UserID,
		Following: input.Following,
	}

	res, err := r.messageService.RemoveFollowing(ctx, req)

	if err != nil {
		log.Println(err)
		return nil, err
	}

	return &model.Result{Succed: &res.Value}, nil
}

// ClearUserUnreadMessage is the resolver for the clearUserUnreadMessage field.
func (r *mutationResolver) ClearUserUnreadMessage(ctx context.Context, userID string, typeArg string) (*model.Result, error) {
	ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()

	req := &msgPB.ClearUserUnreadMessageReq{
		UserId: userID,
		Type:   typeArg,
	}

	res, err := r.messageService.ClearUserUnreadMessage(ctx, req)

	if err != nil {
		log.Println(err)
		return nil, err
	}

	return &model.Result{Succed: &res.Value}, nil
}

// CreateTrek is the resolver for the createTrek field.
func (r *mutationResolver) CreateTrek(ctx context.Context, input model.NewTrek) (*model.ID, error) {
	ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()

	in := &tPB.Trek{
		SceneryspotId: input.SceneryspotID,
		Name:          input.Name,
		Step:          int32(input.Step),
		Points:        int32(input.Points),
		Images:        input.Images,
		Introduction:  *input.Introduction,
		StartTime:     int32(input.StartTime),
		EndTime:       int32(input.EndTime),
		Necessary:     input.Necessary,
		Status:        int32(input.Status),
		CreateTime:    int32(input.CreateTime),
	}
	if input.EventID != nil {
		in.EventId = *input.EventID
	}
	if input.ElectricFence != nil {
		in.ElectricFence = *input.ElectricFence
	}

	res, err := r.taskService.CreateTrek(ctx, in)

	if err != nil {
		log.Println(err)
		return nil, err
	}

	return &model.ID{ID: res.Value}, nil
}

// UpdateTrek is the resolver for the updateTrek field.
func (r *mutationResolver) UpdateTrek(ctx context.Context, input model.UpdateTrek) (*model.Result, error) {
	ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()

	req := &tPB.Trek{
		Id:            input.ID,
		Name:          NotNilString(input.Name, ""),
		Step:          int32(NotNilInt(input.Step, 0)),
		Points:        int32(NotNilInt(input.Points, 0)),
		Images:        NotNilString(input.Images, ""),
		Introduction:  NotNilString(input.Introduction, ""),
		StartTime:     int32(NotNilInt(input.StartTime, 0)),
		EndTime:       int32(NotNilInt(input.EndTime, 0)),
		Necessary:     NotNilBool(input.Necessary, false),
		Status:        int32(NotNilInt(input.Status, 0)),
		ElectricFence: NotNilString(input.ElectricFence, ""),
	}

	res, err := r.taskService.UpdateTrek(ctx, req)

	if err != nil {
		log.Println(err)
		return nil, err
	}

	return &model.Result{Succed: &res.Value}, nil
}

// CreateGeocaching is the resolver for the createGeocaching field.
func (r *mutationResolver) CreateGeocaching(ctx context.Context, input model.NewGeocaching) (*model.ID, error) {
	ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()

	in := &tPB.Geocaching{
		SceneryspotId: input.SceneryspotID,
		Name:          input.Name,
		Points:        int32(input.Points),
		Images:        input.Images,
		Introduction:  *input.Introduction,
		StartTime:     int32(input.StartTime),
		EndTime:       int32(input.EndTime),
		Necessary:     input.Necessary,
		Status:        int32(input.Status),
		CreateTime:    int32(input.CreateTime),
	}
	if input.EventID != nil {
		in.EventId = *input.EventID
	}
	if input.ElectricFence != nil {
		in.ElectricFence = *input.ElectricFence
	}

	res, err := r.taskService.CreateGeocaching(ctx, in)

	if err != nil {
		log.Println(err)
		return nil, err
	}

	return &model.ID{ID: res.Value}, nil
}

// UpdateGeocaching is the resolver for the updateGeocaching field.
func (r *mutationResolver) UpdateGeocaching(ctx context.Context, input model.UpdateGeocaching) (*model.Result, error) {
	ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()

	req := &tPB.Geocaching{
		Id:            input.ID,
		Name:          NotNilString(input.Name, ""),
		Points:        int32(NotNilInt(input.Points, 0)),
		Images:        NotNilString(input.Images, ""),
		Introduction:  NotNilString(input.Introduction, ""),
		StartTime:     int32(NotNilInt(input.StartTime, 0)),
		EndTime:       int32(NotNilInt(input.EndTime, 0)),
		Necessary:     NotNilBool(input.Necessary, false),
		Status:        int32(NotNilInt(input.Status, 0)),
		ElectricFence: NotNilString(input.ElectricFence, ""),
	}

	res, err := r.taskService.UpdateGeocaching(ctx, req)

	if err != nil {
		log.Println(err)
		return nil, err
	}

	return &model.Result{Succed: &res.Value}, nil
}

// CreateScreenshot is the resolver for the createScreenshot field.
func (r *mutationResolver) CreateScreenshot(ctx context.Context, input model.NewScreenshot) (*model.ID, error) {
	ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()

	in := &tPB.Screenshot{
		SceneryspotId: input.SceneryspotID,
		Name:          input.Name,
		Points:        int32(input.Points),
		Images:        input.Images,
		Introduction:  *input.Introduction,
		StartTime:     int32(input.StartTime),
		EndTime:       int32(input.EndTime),
		Necessary:     input.Necessary,
		Status:        int32(input.Status),
		CreateTime:    int32(input.CreateTime),
	}
	if input.EventID != nil {
		in.EventId = *input.EventID
	}
	if input.ElectricFence != nil {
		in.ElectricFence = *input.ElectricFence
	}

	res, err := r.taskService.CreateScreenshot(ctx, in)

	if err != nil {
		log.Println(err)
		return nil, err
	}

	return &model.ID{ID: res.Value}, nil
}

// UpdateScreenshot is the resolver for the updateScreenshot field.
func (r *mutationResolver) UpdateScreenshot(ctx context.Context, input model.UpdateScreenshot) (*model.Result, error) {
	ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()

	req := &tPB.Screenshot{
		Id:            input.ID,
		Name:          NotNilString(input.Name, ""),
		Points:        int32(NotNilInt(input.Points, 0)),
		Images:        NotNilString(input.Images, ""),
		Introduction:  NotNilString(input.Introduction, ""),
		StartTime:     int32(NotNilInt(input.StartTime, 0)),
		EndTime:       int32(NotNilInt(input.EndTime, 0)),
		Necessary:     NotNilBool(input.Necessary, false),
		Status:        int32(NotNilInt(input.Status, 0)),
		ElectricFence: NotNilString(input.ElectricFence, ""),
	}

	res, err := r.taskService.UpdateScreenshot(ctx, req)

	if err != nil {
		log.Println(err)
		return nil, err
	}

	return &model.Result{Succed: &res.Value}, nil
}

// CreatePuzzle is the resolver for the createPuzzle field.
func (r *mutationResolver) CreatePuzzle(ctx context.Context, input model.NewPuzzle) (*model.ID, error) {
	ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()

	in := &tPB.Puzzle{
		SceneryspotId: input.SceneryspotID,
		Name:          input.Name,
		Points:        int32(input.Points),
		Images:        input.Images,
		Introduction:  *input.Introduction,
		StartTime:     int32(input.StartTime),
		EndTime:       int32(input.EndTime),
		Necessary:     input.Necessary,
		Status:        int32(input.Status),
		Countdown:     int32(input.Countdown),
		CreateTime:    int32(input.CreateTime),
	}
	if input.EventID != nil {
		in.EventId = *input.EventID
	}
	if input.ElectricFence != nil {
		in.ElectricFence = *input.ElectricFence
	}

	res, err := r.taskService.CreatePuzzle(ctx, in)

	if err != nil {
		log.Println(err)
		return nil, err
	}

	return &model.ID{ID: res.Value}, nil
}

// UpdatePuzzle is the resolver for the updatePuzzle field.
func (r *mutationResolver) UpdatePuzzle(ctx context.Context, input model.UpdatePuzzle) (*model.Result, error) {
	ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()

	req := &tPB.Puzzle{
		Id:            input.ID,
		Name:          NotNilString(input.Name, ""),
		Points:        int32(NotNilInt(input.Points, 0)),
		Images:        NotNilString(input.Images, ""),
		Introduction:  NotNilString(input.Introduction, ""),
		StartTime:     int32(NotNilInt(input.StartTime, 0)),
		EndTime:       int32(NotNilInt(input.EndTime, 0)),
		Necessary:     NotNilBool(input.Necessary, false),
		Status:        int32(NotNilInt(input.Status, 0)),
		Countdown:     int32(NotNilInt(input.Countdown, 0)),
		ElectricFence: NotNilString(input.ElectricFence, ""),
	}

	res, err := r.taskService.UpdatePuzzle(ctx, req)

	if err != nil {
		log.Println(err)
		return nil, err
	}

	return &model.Result{Succed: &res.Value}, nil
}

// CreateQuestionBank is the resolver for the createQuestionBank field.
func (r *mutationResolver) CreateQuestionBank(ctx context.Context, input model.NewQuestionBank) (*model.ID, error) {
	ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()

	in := &tPB.QuestionBank{
		SceneryspotId: input.SceneryspotID,
		Question:      input.Question,
		Options:       input.Options,
		Answer:        input.Answer,
		StartTime:     int32(input.StartTime),
		EndTime:       int32(input.EndTime),
		Necessary:     input.Necessary,
		Points:        int32(input.Points),
		Status:        int32(input.Status),
	}
	if input.EventID != nil {
		in.EventId = *input.EventID
	}
	if input.ElectricFence != nil {
		in.ElectricFence = *input.ElectricFence
	}

	res, err := r.taskService.CreateQuestionBank(ctx, in)

	if err != nil {
		log.Println(err)
		return nil, err
	}

	return &model.ID{ID: res.Value}, nil
}

// UpdateQuestionBank is the resolver for the updateQuestionBank field.
func (r *mutationResolver) UpdateQuestionBank(ctx context.Context, input model.UpdateQuestionBank) (*model.Result, error) {
	ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()

	req := &tPB.QuestionBank{
		Id:            input.ID,
		Question:      NotNilString(input.Question, ""),
		Options:       NotNilString(input.Options, ""),
		Answer:        NotNilString(input.Answer, ""),
		StartTime:     int32(NotNilInt(input.StartTime, 0)),
		EndTime:       int32(NotNilInt(input.EndTime, 0)),
		Necessary:     NotNilBool(input.Necessary, false),
		Points:        int32(NotNilInt(input.Points, 0)),
		Status:        int32(NotNilInt(input.Status, 0)),
		ElectricFence: NotNilString(input.ElectricFence, ""),
	}

	res, err := r.taskService.UpdateQuestionBank(ctx, req)

	if err != nil {
		log.Println(err)
		return nil, err
	}

	return &model.Result{Succed: &res.Value}, nil
}

// CreateQuestion is the resolver for the createQuestion field.
func (r *mutationResolver) CreateQuestion(ctx context.Context, input model.NewQuestion) (*model.ID, error) {
	ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()

	in := &tPB.Question{
		SceneryspotId: input.SceneryspotID,
		Questions:     input.Questions,
		StartTime:     int32(input.StartTime),
		EndTime:       int32(input.EndTime),
		Points:        int32(input.Points),
		Status:        int32(input.Status),
	}
	if input.EventID != nil {
		in.EventId = *input.EventID
	}
	if input.ElectricFence != nil {
		in.ElectricFence = *input.ElectricFence
	}

	res, err := r.taskService.CreateQuestion(ctx, in)

	if err != nil {
		log.Println(err)
		return nil, err
	}

	return &model.ID{ID: res.Value}, nil
}

// UpdateQuestion is the resolver for the updateQuestion field.
func (r *mutationResolver) UpdateQuestion(ctx context.Context, input model.UpdateQuestion) (*model.Result, error) {
	ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()

	req := &tPB.Question{
		Id:            input.ID,
		Questions:     *input.Questions,
		StartTime:     int32(*input.StartTime),
		EndTime:       int32(*input.EndTime),
		Points:        int32(*input.Points),
		Status:        int32(*input.Status),
		ElectricFence: NotNilString(input.ElectricFence, ""),
	}

	res, err := r.taskService.UpdateQuestion(ctx, req)

	if err != nil {
		log.Println(err)
		return nil, err
	}

	return &model.Result{Succed: &res.Value}, nil
}

// CreateUserTask is the resolver for the createUserTask field.
func (r *mutationResolver) CreateUserTask(ctx context.Context, input model.NewUserTask) (*model.UserTask, error) {
	ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()

	var completedTasks []*tPB.UserTask
	if out, err := r.taskService.GetUserTasks(
		ctx,
		&tPB.UserTaskRequest{
			UserId:       input.UserID,
			EventId:      input.EventID,
			Sceneryspots: []string{input.SceneryspotID},
			CategoryId:   input.TaskCategory,
		},
	); err == nil {
		completedTasks = out.Data
	}
	for _, task := range completedTasks {
		if task.TaskId == input.TaskID {
			return nil, errors.New("任务已完成，请务重复实执行")
		}
	}

	var points int32
	var status TaskStatus
	var up *aPB.UserPoints

	campId := ""
	optional := false
	necessary := true
	if camp, err := r.getUserCamp(ctx, input.UserID, input.EventID); err == nil && camp != nil {
		campId = camp.Id
		optional = input.TaskCategory != camp.CategoryId
	}

	getPoints := func(v int32, necessary bool) int32 {
		if v > 0 && optional && necessary {
			return v / 2
		}
		return v
	}

	if input.TaskCategory == string(TaskCategoryTrek) {
		v, err := r.taskService.GetTrek(ctx, &tPB.TsKeyword{Value: input.TaskID})
		if err != nil {
			return nil, err
		}
		if v == nil {
			return nil, errors.New("无效任务")
		}
		points = 0
		status = TaskStatusPendding
		necessary = v.Necessary
	}

	if input.TaskCategory == string(TaskCategoryQuestion) {
		v, err := r.taskService.GetQuestionBank(ctx, &tPB.TsKeyword{Value: input.TaskID})
		if err != nil {
			return nil, err
		}
		if input.Result != v.Answer {
			return nil, errors.New("结果不正确，请重新答题")
		}

		if input.Result == v.Answer {
			points = getPoints(v.Points, v.Necessary)
			status = TaskStatusCompleted

			up = &aPB.UserPoints{
				UserId:  input.UserID,
				EventId: input.EventID,
				Content: v.Question,
				Op:      "+",
				Points:  points,
			}
		}

		necessary = v.Necessary
	}

	if input.TaskCategory == string(TaskCategoryGeocaching) {
		v, err := r.taskService.GetGeocaching(ctx, &tPB.TsKeyword{Value: input.TaskID})
		if err != nil {
			return nil, err
		}
		if input.Result == v.Id {
			points = getPoints(v.Points, v.Necessary)

			up = &aPB.UserPoints{
				UserId:  input.UserID,
				EventId: input.EventID,
				Content: v.Name,
				Op:      "+",
				Points:  points,
			}
		}
		status = TaskStatusCompleted
		necessary = v.Necessary
	}

	if input.TaskCategory == string(TaskCategoryScreenshot) {
		v, err := r.taskService.GetScreenshot(ctx, &tPB.TsKeyword{Value: input.TaskID})
		if err != nil {
			return nil, err
		}
		if v == nil {
			return nil, errors.New("无效任务")
		}

		points = 0
		status = TaskStatusPendding
		necessary = v.Necessary
	}

	if input.TaskCategory == string(TaskCategoryPuzzle) {
		v, err := r.taskService.GetPuzzle(ctx, &tPB.TsKeyword{Value: input.TaskID})
		if err != nil {
			return nil, err
		}
		if input.Result == v.Images {
			points = getPoints(v.Points, v.Necessary)

			up = &aPB.UserPoints{
				UserId:  input.UserID,
				EventId: input.EventID,
				Content: v.Name,
				Op:      "+",
				Points:  points,
			}
		}
		status = TaskStatusCompleted
		necessary = v.Necessary
	}

	audit := ""
	if points > 0 {
		audit = fmt.Sprint(points)
	}

	in := &tPB.UserTask{
		UserId:        input.UserID,
		EventId:       input.EventID,
		CampId:        input.CampID,
		SceneryspotId: input.SceneryspotID,
		TaskId:        input.TaskID,
		TaskCategory:  input.TaskCategory,
		Result:        input.Result,
		Points:        points,
		Status:        int32(status),
		Audit:         audit,
	}

	out, err := r.taskService.CreateUserTask(ctx, in)
	if err != nil {
		return nil, err
	}
	if len(out.Data) == 0 {
		return nil, nil
	}

	if points > 0 {
		campPoints := points
		if necessary && optional {
			campPoints = 0
		}
		if _, err := r.eventService.IncrementEventUserPoints(ctx, &ePB.EventUserPoints{
			UserId:     input.UserID,
			EventId:    input.EventID,
			CampId:     campId,
			Points:     points,
			CampPoints: campPoints,
		}); err != nil {
			logger.Error(err)
		}
	}

	if up != nil {
		if _, err := r.accountService.AddUserPoints(ctx, up); err == nil {
			r.messageService.CreateConversation(
				ctx,
				&msgPB.Conversation{
					Participant: string(MessageFromSystem),
					To:          up.UserId,
					Content:     fmt.Sprintf("[积分]%s: 个人积分%s%d", up.Content, up.Op, up.Points),
					SendTime:    int32(time.Now().Unix()),
					Status:      1,
				},
			)
		}
	}

	return r.NewUserTask(out.Data[0]), nil
}

// CompleteUserTask is the resolver for the completeUserTask field.
func (r *mutationResolver) CompleteUserTask(ctx context.Context, input *model.NewUserTask) (*model.UserTask, error) {
	ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()

	var task *tPB.UserTask
	if out, err := r.taskService.GetUserTaskByUserID(
		ctx,
		&tPB.TsKeyword{Value: input.UserID},
	); err == nil {
		for _, v := range out.Data {
			if v.TaskId == input.TaskID {
				task = v
				break
			}
		}
	}
	if task == nil {
		return nil, errors.New("无效任务")
	}
	if task.Status == int32(TaskStatusCompleted) {
		return nil, errors.New("任务已完成，请务重复实执行")
	}
	task.Result = input.Result

	var up *aPB.UserPoints
	campId := ""
	optional := false
	necessary := true
	if camp, err := r.getUserCamp(ctx, input.UserID, input.EventID); err == nil && camp != nil {
		campId = camp.Id
		optional = input.TaskCategory != camp.CategoryId
	}

	getPoints := func(v int32, necessary bool) int32 {
		if v > 0 && optional && necessary {
			return v / 2
		}
		return v
	}

	if input.TaskCategory == string(TaskCategoryTrek) {
		v, err := r.taskService.GetTrek(ctx, &tPB.TsKeyword{Value: input.TaskID})
		if err != nil {
			return nil, err
		}
		if v == nil {
			return nil, errors.New("无效任务")
		}

		var points int32
		step, _ := strconv.Atoi(task.Result)
		if step >= int(v.Step) {
			points = getPoints(v.Points, v.Necessary)

			up = &aPB.UserPoints{
				UserId:  input.UserID,
				EventId: input.EventID,
				Content: v.Name,
				Op:      "+",
				Points:  points,
			}
		}

		task.Status = int32(TaskStatusCompleted)
		task.Points = points
		task.Audit = fmt.Sprint(points)
		necessary = v.Necessary
	}

	out, err := r.taskService.UpdateUserTask(
		ctx,
		&tPB.UserTask{
			Id:     task.Id,
			Result: task.Result,
			Points: task.Points,
			Status: task.Status,
			Audit:  task.Audit,
		},
	)
	if err != nil {
		return nil, err
	}
	if !out.Value {
		return nil, nil
	}

	if task.Points > 0 {
		campPoints := task.Points
		if necessary && optional {
			campPoints = 0
		}
		if _, err := r.eventService.IncrementEventUserPoints(ctx, &ePB.EventUserPoints{
			UserId:     input.UserID,
			EventId:    input.EventID,
			Points:     task.Points,
			CampId:     campId,
			CampPoints: campPoints,
		}); err != nil {
			logger.Error(err)
		}
	}

	if up != nil {
		if _, err := r.accountService.AddUserPoints(ctx, up); err == nil {
			r.messageService.CreateConversation(
				ctx,
				&msgPB.Conversation{
					Participant: string(MessageFromSystem),
					To:          up.UserId,
					Content:     fmt.Sprintf("[积分]%s: 个人积分%s%d", up.Content, up.Op, up.Points),
					SendTime:    int32(time.Now().Unix()),
					Status:      1,
				},
			)
		}
	}

	return r.NewUserTask(task), nil
}

// UpdateUserTask is the resolver for the updateUserTask field.
func (r *mutationResolver) UpdateUserTask(ctx context.Context, input model.UpdateUserTask) (*model.Result, error) {
	ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()

	ut, err := r.taskService.GetUserTask(ctx, &tPB.TsKeyword{Value: input.ID})
	if err != nil {
		return nil, err
	}
	if ut == nil {
		return nil, nil
	}

	var audit string
	if input.Audit != nil {
		audit = *input.Audit
	}
	req := &tPB.UserTask{
		Id:     input.ID,
		Result: *input.Result,
		Points: int32(*input.Points),
		Status: int32(*input.Status),
		Audit:  audit,
	}
	res, err := r.taskService.UpdateUserTask(ctx, req)
	if err != nil {
		return nil, err
	}

	p0, _ := strconv.Atoi(ut.Audit)
	p1, _ := strconv.Atoi(audit)
	points := int32(p1 - p0)
	if points != 0 {
		campId := ""
		campPoints := points
		optional := false
		necessary := true
		if camp, err := r.getUserCamp(ctx, ut.UserId, ut.EventId); err == nil && camp != nil {
			campId = camp.Id
			optional = ut.TaskCategory != camp.CategoryId
		}
		if ut.TaskCategory == string(TaskCategoryTrek) {
			if v, err := r.taskService.GetTrek(ctx, &tPB.TsKeyword{Value: ut.TaskId}); err == nil {
				necessary = v.Necessary
			}
		}
		if ut.TaskCategory == string(TaskCategoryQuestion) {
			if v, err := r.taskService.GetQuestionBank(ctx, &tPB.TsKeyword{Value: ut.TaskId}); err == nil {
				necessary = v.Necessary
			}
		}
		if ut.TaskCategory == string(TaskCategoryGeocaching) {
			if v, err := r.taskService.GetGeocaching(ctx, &tPB.TsKeyword{Value: ut.TaskId}); err == nil {
				necessary = v.Necessary
			}
		}
		if ut.TaskCategory == string(TaskCategoryScreenshot) {
			if v, err := r.taskService.GetScreenshot(ctx, &tPB.TsKeyword{Value: ut.TaskId}); err == nil {
				necessary = v.Necessary
			}
		}
		if ut.TaskCategory == string(TaskCategoryPuzzle) {
			if v, err := r.taskService.GetPuzzle(ctx, &tPB.TsKeyword{Value: ut.TaskId}); err == nil {
				necessary = v.Necessary
			}
		}

		if necessary && optional {
			points /= 2
			campPoints = 0
		}

		r.eventService.IncrementEventUserPoints(
			ctx,
			&ePB.EventUserPoints{
				UserId:     ut.UserId,
				EventId:    ut.EventId,
				Points:     points,
				CampId:     campId,
				CampPoints: campPoints,
			},
		)
		op := "+"
		if points < 0 {
			op = "-"
		}
		up := &aPB.UserPoints{
			UserId:  ut.UserId,
			EventId: ut.EventId,
			Content: "您的任务已通过审核",
			Op:      op,
			Points:  int32(math.Abs(float64(points))),
		}

		if _, err := r.accountService.AddUserPoints(ctx, up); err == nil {
			r.messageService.CreateConversation(
				ctx,
				&msgPB.Conversation{
					Participant: string(MessageFromSystem),
					To:          up.UserId,
					Content:     fmt.Sprintf("[积分]%s: 个人积分%s%d", up.Content, up.Op, up.Points),
					SendTime:    int32(time.Now().Unix()),
					Status:      1,
				},
			)
		}
	}

	return &model.Result{Succed: &res.Value}, nil
}

// UploadFiles is the resolver for the uploadFiles field.
func (r *mutationResolver) UploadFiles(ctx context.Context, files []*graphql.Upload) ([]*model.File, error) {
	if len(files) == 0 {
		return nil, errors.New("empty files")
	}
	var resp []*model.File
	for i, upload := range files {
		name := upload.Filename
		if i := strings.LastIndex(name, "."); i > -1 {
			name = name[:i]
		}

		filename := uuid.Must(uuid.NewV4()).String()
		switch upload.ContentType {
		case "image/jpeg":
			{
				filename += ".jpeg"
			}
		case "image/png":
			{
				filename += ".png"
			}
		}

		content, err := io.ReadAll(upload.File)
		if err != nil {
			return []*model.File{}, err
		}
		if err := ioutil.WriteFile("resources/"+filename, content, 0644); err != nil {
			fmt.Println("Error creating", "resources/"+filename)
			fmt.Println(err)
			return nil, err
		}

		resp = append(resp, &model.File{
			ID:          i + 1,
			Name:        name,
			Content:     string(content),
			ContentType: upload.ContentType,
		})
	}
	return resp, nil
}

// UploadWithPayload is the resolver for the UploadWithPayload field.
func (r *mutationResolver) UploadWithPayload(ctx context.Context, payload []*model.UploadFile) ([]*model.File, error) {
	if len(payload) == 0 {
		return nil, errors.New("empty payload")
	}
	var resp []*model.File
	for i, v := range payload {
		upload := v.File
		fmt.Printf("Filename=%v, Size=%v, ContentType=%v\n", upload.Filename, upload.Size, upload.ContentType)
		name := upload.Filename
		if i := strings.LastIndex(name, "."); i > -1 {
			name = name[:i]
		}

		filename := uuid.Must(uuid.NewV4()).String()
		switch upload.ContentType {
		case "image/jpeg":
			{
				filename += ".jpeg"
			}
		case "image/png":
			{
				filename += ".png"
			}
		}

		content, err := io.ReadAll(upload.File)
		if err != nil {
			return []*model.File{}, err
		}

		var rawURI, previewURI string
		path := "resources"
		if v.Tag != nil {
			rawURI = "/" + *v.Tag
			path += "/" + *v.Tag
			if _, err := os.Stat(path); errors.Is(err, os.ErrNotExist) {
				if err := os.MkdirAll(path, os.ModePerm); err != nil {
					fmt.Println(err)
				}
			}
		}
		rawURI += "/" + filename
		if err := ioutil.WriteFile(path+"/"+filename, content, 0644); err != nil {
			fmt.Println("Error creating", path+"/"+filename)
			fmt.Println(err)
			return nil, err
		}

		if v.Preview {
			// generate thumbnail
			previewURI = "/thumbnail" + rawURI
			name := "resources/thumbnail"
			if v.Tag != nil {
				name += "/" + *v.Tag
				if _, err := os.Stat(name); errors.Is(err, os.ErrNotExist) {
					if err := os.MkdirAll(name, os.ModePerm); err != nil {
						fmt.Println(err)
					}
				}
			}
			thumbnailFilename := name + "/" + filename
			img, _ := imaging.Decode(bytes.NewBuffer(content))
			thumbnail := imaging.Resize(img, 512, 0, imaging.Lanczos)
			if err := imaging.Save(thumbnail, thumbnailFilename); err != nil {
				fmt.Println("Error thumbnail creating", thumbnailFilename, err)
				fmt.Println(err)
			}
		}

		resp = append(resp, &model.File{
			ID:          i + 1,
			Name:        name,
			Content:     string(content),
			ContentType: upload.ContentType,
			RawURI:      "resources/" + filename,
			PreviewURI:  &previewURI,
		})
	}
	return resp, nil
}

// AddPassportStock is the resolver for the addPassportStock field.
func (r *mutationResolver) AddPassportStock(ctx context.Context, input model.NewPassportStock) (*model.Result, error) {
	succed := true
	if len(input.File) == 0 {
		return &model.Result{Succed: &succed}, nil
	}
	bytes, err := ioutil.ReadFile("resources/" + input.File)
	if err != nil {
		fmt.Println("Error read", "resources/"+input.File)
		fmt.Println(err)
		return nil, err
	}
	passportCodes := strings.Split(string(bytes), "\n")
	in := &ePB.PassportSet{
		EventId:  input.EventID,
		Name:     *input.Description,
		Status:   1,
		Quantity: int32(len(passportCodes)),
		Issued:   0,
	}
	key, err := r.eventService.CreatePassportSet(ctx, in)
	if err != nil {
		return nil, err
	}
	for _, code := range passportCodes {
		in := &ePB.Passport{
			PassportSetId: key.Value,
			Code:          fmt.Sprintf("%s", strings.TrimSpace(strings.Trim(code, "\r"))),
			Status:        0,
		}
		if _, err := r.eventService.CreatePassport(ctx, in); err != nil {
			return nil, err
		}
	}
	logger.Infof("%d passport imported for %s\n", len(passportCodes), input.EventID)

	return &model.Result{Succed: &succed}, nil
}

// DeletePassport is the resolver for the deletePassport field.
func (r *mutationResolver) DeletePassport(ctx context.Context, input []string) ([]*model.Passport, error) {
	if len(input) == 0 {
		return []*model.Passport{}, nil
	}

	out, err := r.eventService.DeletePassport(ctx, &ePB.DeletePassportRequest{Values: input})
	if err != nil {
		return nil, err
	}

	data := make([]*model.Passport, len(out.Data))
	for i, v := range out.Data {
		data[i] = r.NewPassport(v)
	}
	return data, nil
}

// CheckUserEventPassport is the resolver for the checkUserEventPassport field.
func (r *mutationResolver) CheckUserEventPassport(ctx context.Context, input *model.NewUserEventPassport) (*model.Result, error) {
	if input == nil {
		return r.newResult(false, "输入数据不能为空")
	}
	if len(input.EventID) == 0 {
		return r.newResult(false, "活动ID不能为空")
	}
	if len(input.RealName) == 0 {
		return r.newResult(false, "姓名不能为空")
	}
	if len(input.Nric) == 0 {
		return r.newResult(false, "身份证号不能为空")
	}
	if len(input.Phone) == 0 {
		return r.newResult(false, "手机号码不能为空")
	}
	in := &ePB.UserPassport{
		Id:         NewID(),
		EventId:    input.EventID,
		RealName:   input.RealName,
		Nric:       input.Nric,
		Phone:      input.Phone,
		Status:     0,
		CreateTime: int32(time.Now().Unix()),
	}
	if _, err := r.eventService.CheckUserEventPassport(ctx, in); err != nil {
		detail := merr.Parse(err.Error()).Detail
		if detail == ErrExistsNricAndPhone.Error() {
			return r.newResult(false, "您已成功提交，请勿重复，如有疑问请联系微信客服")
		}
		if detail == ErrExistsPhone.Error() {
			return r.newResult(false, "手机号重复，请更换有效手机号，如有疑问请联系微信客服")
		}
		if detail == ErrExistsNric.Error() {
			return r.newResult(false, "身份证号重复，请勿使用他人信息，如有疑问请联系微信客服")
		}

		return r.newResult(false, "无效用户")
	}

	return r.newResult(true, "")
}

// CreateUserEventPassport is the resolver for the createUserEventPassport field.
func (r *mutationResolver) CreateUserEventPassport(ctx context.Context, input *model.NewUserEventPassport) (*string, error) {
	cur := auth.ForContext(ctx).User
	if input == nil {
		return nil, errors.New("输入数据不能为空")
	}
	if len(input.EventID) == 0 {
		return nil, errors.New("活动ID不能为空")
	}
	if len(input.RealName) == 0 {
		return nil, errors.New("姓名不能为空")
	}
	if len(input.Nric) == 0 {
		return nil, errors.New("身份证号不能为空")
	}
	if len(input.Phone) == 0 {
		return nil, errors.New("手机号码不能为空")
	}
	in := &ePB.UserPassport{
		Id:         NewID(),
		EventId:    input.EventID,
		RealName:   input.RealName,
		Nric:       input.Nric,
		Phone:      input.Phone,
		Status:     0,
		CreateTime: int32(time.Now().Unix()),
	}
	if input.UserID != nil {
		in.UserId = *input.UserID
	}
	if input.PassportCode != nil && len(*input.PassportCode) > 0 {
		in.PassportCode = *input.PassportCode
		in.Status = 1
		in.ClaimBy = cur.Id
		in.ClaimTime = int32(time.Now().Unix())
	}
	if input.Gender != nil {
		in.Gender = *input.Gender
	}
	if input.Profession != nil {
		in.Profession = *input.Profession
	}
	if input.Guardian != nil {
		in.GuardianName = input.Guardian.Name
		in.GuardianNric = input.Guardian.Nric
		in.GuardianPhone = input.Guardian.Phone
	}
	out, err := r.eventService.CreateUserEventPassport(ctx, in)
	if err != nil {
		detail := merr.Parse(err.Error()).Detail
		if detail == ErrExistsNricAndPhone.Error() {
			return nil, errors.New("您已成功提交，请勿重复，如有疑问请联系微信客服")
		}
		if detail == ErrExistsPhone.Error() {
			return nil, errors.New("手机号重复，请更换有效手机号，如有疑问请联系微信客服")
		}
		if detail == ErrExistsNric.Error() {
			return nil, errors.New("身份证号重复，请勿使用他人信息，如有疑问请联系微信客服")
		}
		logger.Error(err)
		return nil, errors.New("无效用户")
	}

	return &out.Id, nil
}

// ActivateUserEventPassport is the resolver for the activateUserEventPassport field.
func (r *mutationResolver) ActivateUserEventPassport(ctx context.Context, input *model.NewActivateUserEventPassport) (*string, error) {
	cur := auth.ForContext(ctx).User
	in := &ePB.ActivateUserEventPassportRequest{
		Id:           input.ID,
		UserId:       input.UserID,
		EvnetId:      input.EventID,
		PassportCode: input.PassportCode,
		ClaimBy:      cur.Id,
		ClaimTime:    int32(time.Now().Unix()),
	}
	out, err := r.eventService.ActivateUserEventPassport(ctx, in)
	if err != nil {
		detail := merr.Parse(err.Error()).Detail
		if detail == "invalid passport" {
			return nil, errors.New("无效护照，如有疑问请联系微信客服")
		}
		if detail == "passport already activated" {
			return nil, errors.New("护照已被激活，如有疑问请联系微信客服")
		}
		if detail == "invalid activate" {
			return nil, errors.New("请勿重复激活，如有疑问请联系微信客服")
		}
		return nil, err
	}
	data := out.Data
	if len(data) == 0 {
		return nil, errors.New("护照无法激活，如有疑问请联系微信客服")
	}

	return &data[0].Id, nil
}

// UpdatePhotoStatus is the resolver for the updatePhotoStatus field.
func (r *mutationResolver) UpdatePhotoStatus(ctx context.Context, input model.NewPhotoStatus) (*string, error) {
	if _, err := r.messageService.UpdateTweet(ctx, &msgPB.Tweet{Id: input.ID, Status: int32(input.Status)}); err != nil {
		return nil, err
	}

	if tweet, err := r.messageService.GetTweet(ctx, &msgPB.MsgsKeyword{Value: input.ID}); err == nil {
		content := "您发布的印迹分享已通过审核"
		if tweet.Status != 2 {
			content = "您发布的印迹分享未通过审核"
		}
		r.messageService.CreateConversation(
			ctx,
			&msgPB.Conversation{
				Participant: string(MessageFromSystem),
				To:          tweet.UserId,
				Content:     content,
				SendTime:    int32(time.Now().Unix()),
				Status:      1,
			},
		)
	}

	return &input.ID, nil
}

// RemovePhotos is the resolver for the removePhotos field.
func (r *mutationResolver) RemovePhotos(ctx context.Context) (*model.Result, error) {
	if _, err := r.messageService.RemoveTweet(ctx, &msgPB.Tweet{Status: 3}); err != nil {
		return nil, err
	}

	r.auditing(ctx, AuditingCodeConfigs, "清空相册回收站")

	succed := true
	message := ""

	return &model.Result{Succed: &succed, Message: &message}, nil
}

// Export is the resolver for the export field.
func (r *mutationResolver) Export(ctx context.Context, export model.Export) (*model.Result, error) {
	succed := true
	cst := time.FixedZone("CST", 8*3600)
	var records [][]string

	if export == model.ExportUser {
		out, err := r.accountService.GetExportUsers(
			ctx,
			&aPB.ExportUserRequest{Roles: []string{string(model.RoleOperator), string(model.RoleUser)}},
		)
		if err != nil {
			return nil, err
		}
		if len(out.Data) == 0 {
			return &model.Result{Succed: &succed}, nil
		}
		records = append(records, []string{"用户名称", "微信 ID", "注册时间", "所在城市", "性别", "手机", "邮件"})
		for _, v := range out.Data {
			records = append(records, []string{
				v.WechatName,
				v.Wechat,
				time.Unix(int64(v.CreateTime), 0).In(cst).Format("2006-01-02 15:04:05"),
				v.City,
				v.Gender,
				v.Phone,
				v.Email,
			})
		}
	}

	if export == model.ExportPassport {
		out, err := r.eventService.GetExportPassports(ctx, &ePB.ExportPassportRequest{})
		if err != nil {
			return nil, err
		}
		if len(out.Data) == 0 {
			return &model.Result{Succed: &succed}, nil
		}
		records = append(records, []string{
			"护照号码",
			"状态",
			"姓名",
			"身份证号",
			"手机号码",
			"性别",
			"职业",
			"监护人姓名",
			"监护人身份证号",
			"监护人手机号码",
			"发放人员",
			"发放时间",
		})

		for _, v := range out.Data {
			status := "已绑定"
			if v.Status == 0 {
				status = "未领取"
			}
			if v.Status == 1 {
				status = "已领取"
			}
			records = append(records, []string{
				v.Code,
				status,
				v.RealName,
				v.Nric,
				v.Phone,
				v.Gender,
				v.Profession,
				v.GuardianName,
				v.GuardianNric,
				v.GuardianPhone,
				v.ClaimBy,
				time.Unix(int64(v.ClaimTime), 0).In(cst).Format("2006-01-02 15:04:05"),
			})
		}
	}

	filename := fmt.Sprintf("/downloads/%s", time.Now().UTC().Format("20060102"))
	if err := os.MkdirAll(ResourceDir+filename, os.ModePerm); err != nil {
		return nil, err
	}
	filename += fmt.Sprintf("/%s.csv", strings.ReplaceAll(uuid.Must(uuid.NewV4()).String(), "-", ""))

	if err := WriteCSV(ResourceDir+filename, records); err != nil {
		return nil, err
	}

	return &model.Result{Succed: &succed, Message: &filename}, nil
}

// ExportEventUsers is the resolver for the exportEventUsers field.
func (r *mutationResolver) ExportEventUsers(ctx context.Context, eventID string, camps []string) (*model.Result, error) {
	succed := true
	var records [][]string
	out, err := r.eventService.GetEventUsers(ctx, &ePB.EventUserRequest{EventId: eventID, Camps: camps})
	if err != nil {
		return nil, err
	}
	if len(out.Data) == 0 {
		return &model.Result{Succed: &succed}, nil
	}
	records = append(records, []string{"用户名称", "所在城市", "邮箱", "所在阵营", "积分", "打卡数量"})
	for _, v := range out.Data {
		records = append(records, []string{
			v.UserName,
			v.City,
			v.Email,
			v.CampName,
			fmt.Sprintf("%d", v.Points),
			fmt.Sprintf("%d", v.StampCount),
		})
	}

	filename := fmt.Sprintf("/downloads/%s", time.Now().UTC().Format("20060102"))
	if err := os.MkdirAll(ResourceDir+filename, os.ModePerm); err != nil {
		return nil, err
	}
	filename += fmt.Sprintf("/%s.csv", strings.ReplaceAll(uuid.Must(uuid.NewV4()).String(), "-", ""))

	if err := WriteCSV(ResourceDir+filename, records); err != nil {
		fmt.Println(err)
		return nil, err
	}

	return &model.Result{Succed: &succed, Message: &filename}, nil
}

// Restore is the resolver for the restore field.
func (r *mutationResolver) Restore(ctx context.Context, restore model.Restore, input []string) (*model.Result, error) {
	succed := true
	message := ""

	if len(input) == 0 {
		return &model.Result{Succed: &succed, Message: &message}, nil
	}

	srv := r.managementService
	switch restore {
	case model.RestoreSceneryspot:
		if _, err := srv.RestoreSceneryspot(ctx, &mPB.RestoreRequest{Values: input}); err != nil {
			return nil, err
		}
		r.auditing(ctx, AuditingCodeConfigs, "还原景区数据", input)
	case model.RestoreEvent:
		if _, err := srv.RestoreEvent(ctx, &mPB.RestoreRequest{Values: input}); err != nil {
			return nil, err
		}
		r.auditing(ctx, AuditingCodeConfigs, "还原活动数据", input)
	case model.RestoreUser:
		if _, err := srv.RestoreUser(ctx, &mPB.RestoreRequest{Values: input}); err != nil {
			return nil, err
		}
		r.auditing(ctx, AuditingCodeConfigs, "还原用户数据", input)
	case model.RestoreTask:
		if _, err := srv.RestoreTask(ctx, &mPB.RestoreRequest{Values: input}); err != nil {
			return nil, err
		}
		r.auditing(ctx, AuditingCodeConfigs, "还原任务数据", input)
	case model.RestoreBadge:
		if _, err := srv.RestoreBadge(ctx, &mPB.RestoreRequest{Values: input}); err != nil {
			return nil, err
		}
		r.auditing(ctx, AuditingCodeConfigs, "还原徽章数据", input)
	case model.RestoreLike:
		if _, err := srv.RestoreLike(ctx, &mPB.RestoreRequest{Values: input}); err != nil {
			return nil, err
		}
		r.auditing(ctx, AuditingCodeConfigs, "还原互动数据", input)
	case model.RestorePoints:
		if _, err := srv.RestorePoints(ctx, &mPB.RestoreRequest{Values: input}); err != nil {
			return nil, err
		}
		r.auditing(ctx, AuditingCodeConfigs, "积分清零", input)
	case model.RestoreConversation:
		if _, err := srv.RestoreConversation(ctx, &mPB.RestoreRequest{Values: input}); err != nil {
			return nil, err
		}
		r.auditing(ctx, AuditingCodeConfigs, "还原消息", input)
	}

	return &model.Result{Succed: &succed, Message: &message}, nil
}

// RestoreUser is the resolver for the restoreUser field.
func (r *mutationResolver) RestoreUser(ctx context.Context, userID string, input []string) (*model.Result, error) {
	succed := true
	message := ""
	srv := r.managementService
	if _, err := srv.RestoreUserEvent(ctx, &mPB.RestoreRequest{UserId: userID, Values: input}); err != nil {
		return nil, err
	}
	r.auditing(ctx, AuditingCodeAccount, "清除用户数据", map[string]interface{}{"userID": userID, "input": input})

	return &model.Result{Succed: &succed, Message: &message}, nil
}

// CreateUserSceneryspot is the resolver for the createUserSceneryspot field.
func (r *mutationResolver) CreateUserSceneryspot(ctx context.Context, input *model.NewUserSceneryspot) (*model.Sceneryspot, error) {
	srv := r.sceneryspotService
	in := sPB.UserSceneryspot{
		UserId:        input.UserID,
		EventId:       input.EventID,
		ScenerySpotId: input.SceneryspotID,
	}
	out, err := srv.CreateUserSceneryspot(ctx, &in)
	if err != nil {
		return nil, err
	}

	results := make([]*model.Sceneryspot, len(out.Data))
	for i, v := range out.Data {
		points := int(v.Points)
		status := int(v.Status)
		createtime := int(v.CreateTime)
		results[i] = &model.Sceneryspot{
			ID:                v.Id,
			Name:              v.Name,
			Address:           &v.Address,
			Points:            &points,
			Images:            &v.Images,
			Coordinate:        &v.Coordinate,
			ElectricFence:     &v.ElectricFence,
			Introduction:      &v.Introduction,
			CategoryID:        &v.CategoryId,
			PositionTolerance: &v.PositionTolerance,
			PassportLink:      &v.PassportLink,
			HealthCodeLink:    &v.HealthCodeLink,
			Status:            &status,
			CreateTime:        &createtime,
		}
	}
	if len(results) > 0 {
		return results[0], nil
	}

	return nil, nil
}

// CreateUserSwap is the resolver for the createUserSwap field.
func (r *mutationResolver) CreateUserSwap(ctx context.Context, input model.NewUserSwap) (*model.UserSwap, error) {
	srv := r.eventService

	if out, _ := srv.GetClaimEventPassports(ctx, &ePB.ActivateUserEventPassportRequest{UserId: input.UserID}); NoAnyPassportActivated(out.Data) {
		return nil, errors.New("您没有在任一个活动中成功领取或激活过护照")
	}

	id, _ := uuid.NewV4()
	in := ePB.CreateUserSwapRequest{
		Id:          id.String(),
		InBadge:     input.Badges[1],
		OutBadge:    input.Badges[0],
		From:        input.UserID,
		To:          "",
		EventId:     input.EventID,
		PreviousId:  "",
		City:        input.City,
		Content:     "[]",
		Status:      1,
		CreateTime:  int32(time.Now().Unix()),
		ExpiredTime: int32(time.Now().Add(time.Hour * 24 * 7).Unix()), // Expired at 7 date after
	}
	out, err := srv.CreateUserSwap(ctx, &in)
	if err != nil {
		return nil, err
	}
	if len(out.Data) > 0 {
		return r.NewUserSwap(out.Data[0]), nil
	}

	return nil, nil
}

// UpdateUserSwap is the resolver for the updateUserSwap field.
func (r *mutationResolver) UpdateUserSwap(ctx context.Context, input model.UserSwapInput) (*model.UserSwap, error) {
	if len(input.ID) == 0 || input.Status == 0 {
		return nil, errors.New("invalid request data")
	}

	srv := r.eventService
	in := ePB.UpdateUserSwapRequest{
		Id:          input.ID,
		Status:      int32(input.Status),
		ExpiredTime: int32(time.Now().Add(time.Hour * 24 * 7).Unix()), // Expired at 7 date after
	}
	out, err := srv.UpdateUserSwap(ctx, &in)
	if err != nil {
		return nil, err
	}
	if len(out.Data) > 0 {
		return r.NewUserSwap(out.Data[0]), nil
	}

	return nil, nil
}

// SendUserSwap is the resolver for the sendUserSwap field.
func (r *mutationResolver) SendUserSwap(ctx context.Context, id string, userID string, content string) (*model.UserSwap, error) {
	srv := r.eventService
	out, err := srv.GetUserBadgeSwap(ctx, &ePB.EsKeyword{Value: id})
	if err != nil {
		return nil, err
	}
	v := []map[string]interface{}{}
	now := time.Now().Unix()
	if len(out.Content) > 0 {
		if err := json.Unmarshal([]byte(out.Content), &v); err != nil {
			logger.Error(err)
			return nil, err
		}
	}
	v = append(v, map[string]interface{}{
		userID: []interface{}{content, now},
	})
	data, err := json.Marshal(&v)
	if err != nil {
		logger.Error(err)
		return nil, err
	}
	if _, err := srv.UpdateUserBadgeSwap(ctx, &ePB.UserBadgeSwap{Id: id, Content: string(data)}); err != nil {
		return nil, err
	}

	r.messageService.CreateConversation(
		ctx,
		&msgPB.Conversation{
			Participant: out.Id,
			From:        userID,
			To:          out.From,
			Content:     content,
			SendTime:    int32(now),
			Status:      1,
		},
	)

	out2, err := srv.GetUserSwaps(ctx, &ePB.UserSwapRequest{Id: id})
	if err != nil {
		return nil, err
	}
	if len(out2.Data) > 0 {
		return r.NewUserSwap(out2.Data[0]), nil
	}

	return nil, nil
}

// UpdateEventSettings is the resolver for the updateEventSettings field.
func (r *mutationResolver) UpdateEventSettings(ctx context.Context, id string, settings map[string]any) (map[string]any, error) {
	out, err := r.eventService.GetEventSettings(ctx, &ePB.EventSettingsRequest{Id: id})
	if err != nil {
		return nil, err
	}
	data := out.Data
	if data == nil {
		data = &ePB.EventSettings{}
	}
	if v, ok := settings["menus"]; ok {
		menus := []string{}
		for _, e := range v.([]interface{}) {
			menus = append(menus, fmt.Sprint(e))
		}
		data.Menus = menus
	}
	if v, ok := settings["markBackgrouds"]; ok {
		markBackgrouds := []string{}
		for _, e := range v.([]interface{}) {
			markBackgrouds = append(markBackgrouds, fmt.Sprint(e))
		}
		data.MarkBackgrouds = markBackgrouds
	}
	if _, err := r.eventService.UpdateEventSettings(ctx, &ePB.UpdateEventSettingsRequest{Id: id, Data: data}); err != nil {
		return nil, err
	}
	return settings, err
}

// UpdateEventUserPoints is the resolver for the updateEventUserPoints field.
func (r *mutationResolver) UpdateEventUserPoints(ctx context.Context, input model.NewUserPoints) (*model.EventUser, error) {
	in := &ePB.EventUserPoints{
		UserId:  input.UserID,
		EventId: input.EventID,
		CampId:  input.CampID,
		Points:  int32(input.Points),
	}
	out, err := r.eventService.UpdateEventUserPoints(ctx, in)
	if err != nil {
		return nil, err
	}
	data := out.Data
	if data != nil {
		r.auditing(ctx, AuditingCodeUserPoints, fmt.Sprintf("更改%s的积分为%d", data.UserName, data.Points), input)

		up := &aPB.UserPoints{
			UserId:  data.UserId,
			EventId: data.EventId,
			Content: "客服变更",
			Op:      "",
			Points:  data.Points,
		}
		if _, err := r.accountService.AddUserPoints(ctx, up); err == nil {
			r.messageService.CreateConversation(
				ctx,
				&msgPB.Conversation{
					Participant: string(MessageFromSystem),
					To:          up.UserId,
					Content:     fmt.Sprintf("[积分]%s: 个人积分%s%d", up.Content, up.Op, up.Points),
					SendTime:    int32(time.Now().Unix()),
					Status:      1,
				},
			)
		}
	}
	return r.NewEventUser(out.Data), nil
}

// CreateEventAwards is the resolver for the createEventAwards field.
func (r *mutationResolver) CreateEventAwards(ctx context.Context, input model.NewEventAwardUploadFile) ([]*model.EventAward, error) {
	if len(input.File) == 0 {
		return []*model.EventAward{}, nil
	}
	bytes, err := ioutil.ReadFile("resources/" + input.File)
	if err != nil {
		logger.Error(err)
		return nil, fmt.Errorf("File error: %s", err.Error())
	}

	codes := strings.Split(string(bytes), "\n")
	for i, v := range codes {
		codes[i] = strings.TrimSpace(strings.Trim(v, "\r"))
	}

	in := &ePB.CreateEventAwardRequest{
		Codes: codes,
	}
	if input.EventID != nil {
		in.EventId = *input.EventID
	}
	if input.SceneryspotID != nil {
		in.SceneryspotId = *input.SceneryspotID
	}
	out, err := r.eventService.CreateEventAward(ctx, in)
	if err != nil {
		return nil, err
	}

	result := make([]*model.EventAward, len(out.Data))
	for i, v := range out.Data {
		result[i] = r.NewEventAward(v)
	}
	return result, nil
}

// DeleteEventAward is the resolver for the deleteEventAward field.
func (r *mutationResolver) DeleteEventAward(ctx context.Context, input []string) ([]*model.EventAward, error) {
	if len(input) == 0 {
		return []*model.EventAward{}, nil
	}

	out, err := r.eventService.DeleteEventAward(ctx, &ePB.DeleteEventAwardRequest{Values: input})
	if err != nil {
		return nil, err
	}

	result := make([]*model.EventAward, len(out.Data))
	for i, v := range out.Data {
		result[i] = r.NewEventAward(v)
	}
	return result, nil
}

// Mutation returns generated.MutationResolver implementation.
func (r *Resolver) Mutation() generated.MutationResolver { return &mutationResolver{r} }

type mutationResolver struct{ *Resolver }
