package resolver

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.70

import (
	"context"
	"errors"
	"fmt"
	"gateway/esign"
	"gateway/graph/auth"
	"gateway/graph/generated"
	"gateway/graph/model"
	"gateway/graph/utils"
	"log"
	"os"
	"strings"
	"time"

	"github.com/gofrs/uuid"
	aPB "gitlab.com/annoying-orange/shenzhouyinji/service/account/proto"
	ePB "gitlab.com/annoying-orange/shenzhouyinji/service/event/proto"
	mPB "gitlab.com/annoying-orange/shenzhouyinji/service/management/proto"
	msgPB "gitlab.com/annoying-orange/shenzhouyinji/service/message/proto"
	sPB "gitlab.com/annoying-orange/shenzhouyinji/service/sceneryspot/proto"
	tPB "gitlab.com/annoying-orange/shenzhouyinji/service/task/proto"
	"go-micro.dev/v4/logger"
)

// ServerTime is the resolver for the serverTime field.
func (r *queryResolver) ServerTime(ctx context.Context) (int, error) {
	return int(time.Now().Unix()), nil
}

// Admins is the resolver for the Admins field.
func (r *queryResolver) Admins(ctx context.Context) ([]*model.User, error) {
	out, err := r.accountService.GetAccounts(ctx, &aPB.AccountRequest{Roles: []string{string(model.RoleAdmin)}})
	if err != nil {
		return nil, err
	}

	users := make([]*model.User, len(out.Data))
	for i, u := range out.Data {
		users[i] = &model.User{
			ID:         u.Id,
			LoginID:    u.LoginId,
			Status:     int(u.Status),
			CreateTime: int(u.CreateTime),
		}
	}

	return users, nil
}

// Account is the resolver for the account field.
func (r *queryResolver) Account(ctx context.Context, id string) (*model.Account, error) {
	ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()

	out, err := r.accountService.GetAccount(ctx, &aPB.AsKeyword{Value: id})
	if err != nil {
		return nil, err
	}

	return r.NewAccount(out), nil
}

// Accounts is the resolver for the accounts field.
func (r *queryResolver) Accounts(ctx context.Context, first *int, after *string, last *int, before *string, search *string, phone *string, province *string, city *string, district *string) (*model.AccountConnection, error) {
	ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()

	afterCursor, err := DecodedCursor(after)
	if err != nil {
		return nil, err
	}

	beforeCursor, err := DecodedCursor(before)
	if err != nil {
		return nil, err
	}

	edges := make([]*model.AccountEdge, *first)
	count := 0
	currentPage := false

	if afterCursor == "" && beforeCursor == "" {
		currentPage = true
	}

	startCursor := ""
	endCursor := ""
	hasPreviousPage := false
	hasNextPage := false

	in := &aPB.AccountRequest{Roles: []string{string(model.RoleOperator), string(model.RoleUser)}}
	if search != nil {
		in.Search = *search
	}
	if phone != nil {
		in.Phone = *phone
	}
	if province != nil {
		in.Province = *province
	}
	if city != nil {
		in.City = *city
	}
	if district != nil {
		in.District = *district
	}
	out, err := r.accountService.GetAccounts(ctx, in)
	if err != nil {
		return nil, err
	}
	results := out.Data

	if afterCursor == "" && len(beforeCursor) > 0 {
		for i, v := range results {
			if v.Id == beforeCursor {
				currentPage = true
			}
			if currentPage && *last > 0 {
				m, n := i-*last, i
				if m < 0 {
					m = 0
				}
				for _, v := range results[m:n] {
					edges[count] = &model.AccountEdge{
						Cursor: EncodeToCursor(v.Id),
						Node:   r.NewAccount(v),
					}
					count++
				}

				hasPreviousPage = i-count > 0
				hasNextPage = i < len(results)-1
				break
			}
		}
	} else {
		for i, v := range results {
			if currentPage && count < *first {
				edges[count] = &model.AccountEdge{
					Cursor: EncodeToCursor(v.Id),
					Node:   r.NewAccount(v),
				}
				count++
			}

			if v.Id == afterCursor {
				currentPage = true
			}

			if !hasPreviousPage {
				hasPreviousPage = i-count >= 0
			}

			if count == *first {
				hasNextPage = i < len(results)-1
				break
			}
		}
	}

	if count > 0 {
		startCursor = EncodeToCursor(edges[0].Node.ID)
		endCursor = EncodeToCursor(edges[count-1].Node.ID)
	}

	conn := model.AccountConnection{
		TotalCount: len(results),
		Edges:      edges[:count],
		PageInfo: &model.PageInfo{
			StartCursor:     startCursor,
			EndCursor:       endCursor,
			HasPreviousPage: &hasPreviousPage,
			HasNextPage:     &hasNextPage,
		},
	}

	return &conn, nil
}

// Profile is the resolver for the profile field.
func (r *queryResolver) Profile(ctx context.Context, userID string) (*model.Profile, error) {
	ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()

	req := aPB.AsKeyword{
		Value: userID,
	}

	res, err := r.accountService.GetProfileByUserID(ctx, &req)

	if err != nil {
		return nil, err
	}

	age := int(res.Age)
	birthday := int(res.Birthday)

	return &model.Profile{
		ID:             res.Id,
		Name:           &res.Name,
		Gender:         &res.Gender,
		Age:            &age,
		Birthday:       &birthday,
		Email:          &res.Email,
		Phone:          &res.Phone,
		City:           &res.City,
		Tags:           &res.Tags,
		Nric:           &res.Nric,
		Authentication: &res.Authentication,
		Profession:     &res.Profession,
		GuardianName:   &res.GuardianName,
		GuardianNric:   &res.GuardianNric,
		GuardianPhone:  &res.GuardianPhone,
		CreateTime:     int(res.CreateTime),
	}, nil
}

// ClaimCode is the resolver for the claimCode field.
func (r *queryResolver) ClaimCode(ctx context.Context, userID string) (*model.ClaimCode, error) {
	ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()

	req := aPB.AsKeyword{
		Value: userID,
	}

	res, err := r.accountService.GetClaimCodeByUserID(ctx, &req)
	fmt.Print(res)
	if err != nil {
		return nil, err
	}

	return &model.ClaimCode{
		ID:         res.Id,
		UserID:     res.UserId,
		Code:       res.Code,
		Status:     int(res.Status),
		CreateTime: int(res.CreateTime),
	}, nil
}

// Sceneryspot is the resolver for the sceneryspots field.
func (r *queryResolver) Sceneryspot(ctx context.Context, id string) (*model.Sceneryspot, error) {
	ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()

	req := sPB.SsKeyword{
		Value: id,
	}

	res, err := r.sceneryspotService.GetSceneryspot(ctx, &req)

	if err != nil {
		return nil, err
	}

	points := int(res.Points)
	status := int(res.Status)
	createtime := int(res.CreateTime)

	return &model.Sceneryspot{
		ID:                res.Id,
		Code:              res.Code,
		Name:              res.Name,
		Address:           &res.Address,
		Points:            &points,
		Images:            &res.Images,
		Coordinate:        &res.Coordinate,
		ElectricFence:     &res.ElectricFence,
		Introduction:      &res.Introduction,
		CategoryID:        &res.CategoryId,
		PositionTolerance: &res.PositionTolerance,
		PassportLink:      &res.PassportLink,
		HealthCodeLink:    &res.HealthCodeLink,
		Status:            &status,
		CreateTime:        &createtime,
		EnableAward:       res.EnableAward,
	}, nil
}

// Sceneryspots is the resolver for the sceneryspots field.
func (r *queryResolver) Sceneryspots(ctx context.Context) ([]*model.Sceneryspot, error) {
	ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()

	req := sPB.SsEmptyReq{}

	res, err := r.sceneryspotService.GetSceneryspots(ctx, &req)

	if err != nil {
		return nil, err
	}

	results := make([]*model.Sceneryspot, 0)
	for _, s := range res.Data {
		points := int(s.Points)
		status := int(s.Status)
		createtime := int(s.CreateTime)
		results = append(results, &model.Sceneryspot{
			ID:                s.Id,
			Code:              s.Code,
			Name:              s.Name,
			Address:           &s.Address,
			Points:            &points,
			Images:            &s.Images,
			Coordinate:        &s.Coordinate,
			ElectricFence:     &s.ElectricFence,
			Introduction:      &s.Introduction,
			CategoryID:        &s.CategoryId,
			PositionTolerance: &s.PositionTolerance,
			PassportLink:      &s.PassportLink,
			HealthCodeLink:    &s.HealthCodeLink,
			Status:            &status,
			CreateTime:        &createtime,
			EnableAward:       s.EnableAward,
		})
	}

	return results, err
}

// SceneryspotsByIDs is the resolver for the sceneryspotsByIDs field.
func (r *queryResolver) SceneryspotsByIDs(ctx context.Context, ids []string) ([]*model.Sceneryspot, error) {
	ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()

	req := sPB.SsKeywords{
		Value: ids,
	}

	res, err := r.sceneryspotService.GetSceneryspotsByIDs(ctx, &req)

	if err != nil {
		return nil, err
	}

	results := make([]*model.Sceneryspot, 0)
	for _, s := range res.Data {
		points := int(s.Points)
		status := int(s.Status)
		createtime := int(s.CreateTime)
		results = append(results, &model.Sceneryspot{
			ID:                s.Id,
			Code:              s.Code,
			Name:              s.Name,
			Address:           &s.Address,
			Points:            &points,
			Images:            &s.Images,
			Coordinate:        &s.Coordinate,
			ElectricFence:     &s.ElectricFence,
			Introduction:      &s.Introduction,
			CategoryID:        &s.CategoryId,
			PositionTolerance: &s.PositionTolerance,
			PassportLink:      &s.PassportLink,
			HealthCodeLink:    &s.HealthCodeLink,
			Status:            &status,
			CreateTime:        &createtime,
		})
	}

	return results, err
}

// ServiceItem is the resolver for the serviceItem field.
func (r *queryResolver) ServiceItem(ctx context.Context, id string) (*model.ServiceItem, error) {
	ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()

	req := sPB.SsKeyword{
		Value: id,
	}

	res, err := r.sceneryspotService.GetServiceItem(ctx, &req)

	if err != nil {
		return nil, err
	}

	return &model.ServiceItem{
		ID:                 res.Id,
		SceneryspotID:      res.SceneryspotId,
		Name:               res.Name,
		CategoryID:         &res.CategoryId,
		Images:             &res.Images,
		Address:            &res.Address,
		Coordinate:         &res.Coordinate,
		Wxappid:            &res.Wxappid,
		DisplayOrder:       int(res.DisplayOrder),
		Introduction:       &res.Introduction,
		ExpenseInstruction: &res.ExpenseInstruction,
	}, nil
}

// ServiceItems is the resolver for the serviceItems field.
func (r *queryResolver) ServiceItems(ctx context.Context, sceneryspotID string) ([]*model.ServiceItem, error) {
	ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()

	req := sPB.SsKeyword{
		Value: sceneryspotID,
	}

	res, err := r.sceneryspotService.GetServiceItemsBySceneryspotID(ctx, &req)

	if err != nil {
		return nil, err
	}

	results := make([]*model.ServiceItem, 0)
	for _, s := range res.Data {
		results = append(results, &model.ServiceItem{
			ID:                 s.Id,
			SceneryspotID:      s.SceneryspotId,
			Name:               s.Name,
			CategoryID:         &s.CategoryId,
			Images:             &s.Images,
			Address:            &s.Address,
			Coordinate:         &s.Coordinate,
			Wxappid:            &s.Wxappid,
			DisplayOrder:       int(s.DisplayOrder),
			Introduction:       &s.Introduction,
			ExpenseInstruction: &s.ExpenseInstruction,
		})
	}

	return results, err
}

// ServiceItemsWithCategory is the resolver for the serviceItemsWithCategory field.
func (r *queryResolver) ServiceItemsWithCategory(ctx context.Context, sceneryspotID string, categoryID string) ([]*model.ServiceItem, error) {
	ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()

	req := sPB.SsKeywordByCategory{
		SceneryspotID: sceneryspotID,
		CategoryID:    categoryID,
	}

	res, err := r.sceneryspotService.GetServiceItemsByCategory(ctx, &req)

	if err != nil {
		return nil, err
	}

	results := make([]*model.ServiceItem, 0)
	for _, s := range res.Data {
		results = append(results, &model.ServiceItem{
			ID:                 s.Id,
			SceneryspotID:      s.SceneryspotId,
			Name:               s.Name,
			CategoryID:         &s.CategoryId,
			Images:             &s.Images,
			Address:            &s.Address,
			Coordinate:         &s.Coordinate,
			Wxappid:            &s.Wxappid,
			DisplayOrder:       int(s.DisplayOrder),
			Introduction:       &s.Introduction,
			ExpenseInstruction: &s.ExpenseInstruction,
		})
	}

	return results, err
}

// Stamp is the resolver for the stamp field.
func (r *queryResolver) Stamp(ctx context.Context, id string) (*model.Stamp, error) {
	ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()

	req := sPB.SsKeyword{
		Value: id,
	}

	res, err := r.sceneryspotService.GetStamp(ctx, &req)

	if err != nil {
		return nil, err
	}

	status := int(res.Status)
	createtime := int(res.CreateTime)

	return &model.Stamp{
		ID:            res.Id,
		SceneryspotID: res.SceneryspotId,
		Name:          res.Name,
		Address:       &res.Address,
		Coordinate:    &res.Coordinate,
		Code:          &res.Code,
		Images:        &res.Images,
		Status:        &status,
		CreateTime:    &createtime,
	}, nil
}

// Stamps is the resolver for the stamps field.
func (r *queryResolver) Stamps(ctx context.Context, sceneryspotID string) ([]*model.Stamp, error) {
	ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()

	req := sPB.SsKeyword{
		Value: sceneryspotID,
	}

	res, err := r.sceneryspotService.GetStampsBySceneryspotID(ctx, &req)

	if err != nil {
		return nil, err
	}

	results := make([]*model.Stamp, 0)
	for _, s := range res.Data {

		status := int(s.Status)
		createtime := int(s.CreateTime)

		results = append(results, &model.Stamp{
			ID:            s.Id,
			SceneryspotID: s.SceneryspotId,
			Name:          s.Name,
			Address:       &s.Address,
			Coordinate:    &s.Coordinate,
			Code:          &s.Code,
			Images:        &s.Images,
			Status:        &status,
			CreateTime:    &createtime,
		})
	}

	return results, err
}

// UserStamp is the resolver for the userStamp field.
func (r *queryResolver) UserStamp(ctx context.Context, userID string, eventID string, sceneryspotID string) (*model.UserStamp, error) {
	out, err := r.sceneryspotService.GetUserStamp(
		ctx,
		&sPB.UserStampRequest{
			UserId:        userID,
			EventId:       eventID,
			SceneryspotId: sceneryspotID,
		},
	)
	if err != nil {
		return nil, err
	}
	if len(out.Data) > 0 {
		data := out.Data[0]
		return &model.UserStamp{
			UserID:        data.UserId,
			EventID:       data.EventId,
			SceneryspotID: data.SceneryspotId,
			Code:          &data.Code,
			Location:      &data.Location,
			Status:        int(data.Status),
			CreateTime:    int(data.CreateTime),
		}, nil
	}

	settings, err := r.eventService.GetEventSettings(ctx, &ePB.EventSettingsRequest{Id: eventID})
	if err != nil {
		return nil, err
	}
	menus := make(map[string]bool)
	if settings.Data != nil {
		for _, v := range settings.Data.Menus {
			menus[v] = true
		}
	}

	if ok := menus[string(MenuTask)]; ok {
		camp, err := r.getUserCamp(ctx, userID, eventID)
		if err != nil {
			return nil, err
		}
		if camp == nil {
			return nil, nil
		}

		var userTasks []*tPB.UserTask
		if out, err := r.taskService.GetUserTasks(
			ctx,
			&tPB.UserTaskRequest{
				UserId:       userID,
				EventId:      eventID,
				Sceneryspots: []string{sceneryspotID},
			},
		); err == nil {
			userTasks = out.Data
		}

		completedTask := func(v string) *tPB.UserTask {
			for _, task := range userTasks {
				if v == task.TaskId {
					return task
				}
			}
			return nil
		}

		tasks := []model.Task{}
		if camp.CategoryId == string(TaskCategoryTrek) {
			treks, err := r.getTreks(ctx, camp.CategoryId, sceneryspotID, completedTask)
			if err != nil {
				return nil, err
			}
			tasks = append(tasks, treks...)
		}
		if camp.CategoryId == string(TaskCategoryQuestion) {
			questions, err := r.getQuestions(ctx, camp.CategoryId, sceneryspotID, userTasks)
			if err != nil {
				return nil, err
			}
			tasks = append(tasks, questions...)
		}
		if camp.CategoryId == string(TaskCategoryGeocaching) {
			geocachings, err := r.getGeocachings(ctx, camp.CategoryId, sceneryspotID, completedTask)
			if err != nil {
				return nil, err
			}
			tasks = append(tasks, geocachings...)
		}
		if camp.CategoryId == string(TaskCategoryScreenshot) {
			screenshots, err := r.getScreenshots(ctx, camp.CategoryId, sceneryspotID, completedTask)
			if err != nil {
				return nil, err
			}
			tasks = append(tasks, screenshots...)
		}
		if camp.CategoryId == string(TaskCategoryPuzzle) {
			puzzles, err := r.getPuzzles(ctx, camp.CategoryId, sceneryspotID, completedTask)
			if err != nil {
				return nil, err
			}
			tasks = append(tasks, puzzles...)
		}
		for _, v := range tasks {
			if v.GetCompleted() == nil || *v.GetCompleted() == false {
				return nil, nil
			}
		}
	}

	if ok := menus[string(MenuShare)]; ok {
		out, err := r.messageService.GetTweets(
			ctx,
			&msgPB.TweetRequest{UserId: userID, EventId: eventID, Sceneryspots: []string{sceneryspotID}, Limit: 1},
		)
		if err != nil {
			return nil, err
		}
		if len(out.Data) == 0 {
			return nil, nil
		}
	}

	var code string
	if out, err := r.accountService.GetAccount(ctx, &aPB.AsKeyword{Value: userID}); err == nil {
		code = out.Wechat
	}
	if out, err := r.eventService.GetEvent(ctx, &ePB.EsKeyword{Value: eventID}); err == nil {
		code += fmt.Sprintf("&%s", out.Code)
	}
	if out, err := r.sceneryspotService.GetSceneryspot(ctx, &sPB.SsKeyword{Value: sceneryspotID}); err == nil {
		code += fmt.Sprintf("&%s", out.Code)
	}
	code, _ = utils.AESEncrypt(code)

	return &model.UserStamp{UserID: userID, EventID: eventID, SceneryspotID: sceneryspotID, Code: &code}, nil
}

// UserStampByUserID is the resolver for the userStampByUserID field.
func (r *queryResolver) UserStampByUserID(ctx context.Context, id string) ([]*model.UserStamp, error) {
	ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()

	req := sPB.SsKeyword{
		Value: id,
	}

	res, err := r.sceneryspotService.GetUserStampByUserID(ctx, &req)

	if err != nil {
		return nil, err
	}

	results := make([]*model.UserStamp, 0)
	for _, s := range res.Data {
		sceneryspotInfo, _ := r.sceneryspotService.GetSceneryspot(ctx, &sPB.SsKeyword{Value: s.SceneryspotId})
		results = append(results, &model.UserStamp{
			UserID:                s.UserId,
			EventID:               s.EventId,
			SceneryspotID:         s.SceneryspotId,
			SceneryspotName:       &sceneryspotInfo.Name,
			SceneryspotAddress:    &sceneryspotInfo.Address,
			SceneryspotImages:     &sceneryspotInfo.Images,
			SceneryspotCoordinate: &sceneryspotInfo.Coordinate,
			Code:                  &s.Code,
			Location:              &s.Location,
			LikeCount:             int(s.LikeCount),
			ShareCount:            int(s.ShareCount),
			ViewCount:             int(s.ViewCount),
			Status:                int(s.Status),
		})
	}

	return results, err
}

// UserStampByStampID is the resolver for the userStampByStampID field.
func (r *queryResolver) UserStampByStampID(ctx context.Context, id string) ([]*model.UserStamp, error) {
	ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()

	req := sPB.SsKeyword{
		Value: id,
	}

	res, err := r.sceneryspotService.GetUserStampByStampID(ctx, &req)

	if err != nil {
		return nil, err
	}

	results := make([]*model.UserStamp, 0)
	for _, s := range res.Data {
		results = append(results, &model.UserStamp{
			UserID: s.UserId,
		})
	}

	return results, err
}

// UserShare is the resolver for the userShare field.
func (r *queryResolver) UserShare(ctx context.Context, userID string, eventID string, sceneryspotID string) (*model.Tweet, error) {
	ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()

	out, err := r.messageService.GetUserTweet(
		ctx,
		&msgPB.UserTweetRequest{UserId: userID, EventId: eventID, SceneryspotId: sceneryspotID},
	)
	if err != nil {
		return nil, err
	}
	if len(out.Data) == 0 {
		return nil, nil
	}
	v := out.Data[0]

	lc := int(v.LikeCount)
	sc := int(v.ShareCount)
	vc := int(v.ViewCount)

	return &model.Tweet{
		ID:            v.Id,
		UserID:        v.UserId,
		Content:       v.Content,
		LikeCount:     &lc,
		ShareCount:    &sc,
		ViewCount:     &vc,
		Status:        int(v.Status),
		CreateTime:    int(v.CreateTime),
		EventID:       v.EventId,
		SceneryspotID: v.SceneryspotId,
		Location:      &v.Location,
		Region:        &v.Region,
	}, err
}

// UserStampPointsRecord is the resolver for the userStampPointsRecord field.
func (r *queryResolver) UserStampPointsRecord(ctx context.Context, input model.NewUserStampPointsRecord) ([]*model.UserStampPointsRecord, error) {
	ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()

	req := sPB.UserStampPointsRecordReq{
		UserId:        input.UserID,
		EventId:       input.EventID,
		SceneryspotId: input.SceneryspotID,
		ActionUserId:  input.ActionUserID,
	}

	res, err := r.sceneryspotService.GetUserStampPointsRecord(ctx, &req)

	if err != nil {
		return nil, err
	}

	userInfo, _ := r.accountService.GetAccount(ctx, &aPB.AsKeyword{Value: input.UserID})

	results := make([]*model.UserStampPointsRecord, 0)
	for _, s := range res.Data {
		actionUserInfo, _ := r.accountService.GetAccount(ctx, &aPB.AsKeyword{Value: s.ActionUserId})
		results = append(results, &model.UserStampPointsRecord{
			ID:               s.Id,
			UserID:           s.UserId,
			UserName:         userInfo.WechatName,
			UserAvatar:       userInfo.WechatAvatar,
			EventID:          s.EventId,
			SceneryspotID:    s.SceneryspotId,
			ActionUserID:     s.ActionUserId,
			ActionUserName:   actionUserInfo.WechatName,
			ActionUserAvatar: actionUserInfo.WechatAvatar,
			Like:             int(s.Like),
			Share:            int(s.Share),
			View:             int(s.View),
		})
	}

	return results, err
}

// CouponList is the resolver for the couponList field.
func (r *queryResolver) CouponList(ctx context.Context, first *int, after *string, last *int, before *string, typeArg *string, stateCode *string, tideSpotName *string, tideSpotID *string, generateRule *string, buyGoodName *string, verificationWechatName *string, userWechatName *string, userPhone *string, useTimeStart *int, useTimeEnd *int, userWechat *string, backSearch *bool, tideSpotConfigID *string, buyGoodBarCode *string) (*model.CouponConnection, error) {
	afterCursor, err := DecodedCursor(after)
	if err != nil {
		return nil, err
	}

	beforeCursor, err := DecodedCursor(before)
	if err != nil {
		return nil, err
	}

	edges := make([]*model.CouponEdge, *first)
	count := 0
	currentPage := false

	if afterCursor == "" && beforeCursor == "" {
		currentPage = true
	}

	startCursor := ""
	endCursor := ""
	hasPreviousPage := false
	hasNextPage := false

	if NotNilBool(backSearch, false) {
		user := auth.ForContext(ctx).User
		userWechat = &user.Wechat
	}
	in := mPB.CouponRequest{
		Type:                   NotNilString(typeArg, ""),
		TideSpotName:           NotNilString(tideSpotName, ""),
		TideSpotId:             NotNilString(tideSpotName, ""),
		GenerateRule:           NotNilString(generateRule, ""),
		BuyGoodName:            NotNilString(buyGoodName, ""),
		VerificationWechatName: NotNilString(verificationWechatName, ""),
		UserWechatName:         NotNilString(userWechatName, ""),
		UserPhone:              NotNilString(userPhone, ""),
		UseTimeStart:           int32(NotNilInt(useTimeStart, 0)),
		UseTimeEnd:             int32(NotNilInt(useTimeEnd, 0)),
		UserWechat:             NotNilString(userWechat, ""),
		StateCode:              NotNilString(stateCode, ""),
	}

	out, err := r.managementService.GetCouponList(ctx, &in)
	if err != nil {
		return nil, err
	}
	results := out.Data

	if afterCursor == "" && len(beforeCursor) > 0 {
		for i, v := range results {
			if v.Id == beforeCursor {
				currentPage = true
			}
			if currentPage && *last > 0 {
				m, n := i-*last, i
				if m < 0 {
					m = 0
				}
				for _, v := range results[m:n] {
					edges[count] = &model.CouponEdge{
						Cursor: EncodeToCursor(v.Id),
						Node:   r.NewCoupon(v),
					}
					count++
				}

				hasPreviousPage = i-count > 0
				hasNextPage = i < len(results)-1
				break
			}
		}
	} else {
		for i, v := range results {
			if currentPage && count < *first {
				edges[count] = &model.CouponEdge{
					Cursor: EncodeToCursor(v.Id),
					Node:   r.NewCoupon(v),
				}
				count++
			}

			if v.Id == afterCursor {
				currentPage = true
			}

			if hasPreviousPage == false {
				hasPreviousPage = i-count >= 0
			}

			if count == *first {
				hasNextPage = i < len(results)-1
				break
			}
		}
	}

	if count > 0 {
		startCursor = EncodeToCursor(edges[0].Node.ID)
		endCursor = EncodeToCursor(edges[count-1].Node.ID)
	}
	exchangeIn := mPB.CouponRequest{
		Type:                   "Exchange",
		TideSpotName:           NotNilString(tideSpotName, ""),
		TideSpotId:             NotNilString(tideSpotName, ""),
		GenerateRule:           NotNilString(generateRule, ""),
		BuyGoodName:            NotNilString(buyGoodName, ""),
		VerificationWechatName: NotNilString(verificationWechatName, ""),
		UserWechatName:         NotNilString(userWechatName, ""),
		UserPhone:              NotNilString(userPhone, ""),
		UseTimeStart:           int32(NotNilInt(useTimeStart, 0)),
		UseTimeEnd:             int32(NotNilInt(useTimeEnd, 0)),
		UserWechat:             NotNilString(userWechat, ""),
		StateCode:              NotNilString(stateCode, ""),
	}
	exchangeOut, err := r.managementService.GetCouponList(ctx, &exchangeIn)
	exchangeRes := exchangeOut.Data

	deductionIn := mPB.CouponRequest{
		Type:                   "Deduction",
		TideSpotName:           NotNilString(tideSpotName, ""),
		TideSpotId:             NotNilString(tideSpotName, ""),
		GenerateRule:           NotNilString(generateRule, ""),
		BuyGoodName:            NotNilString(buyGoodName, ""),
		VerificationWechatName: NotNilString(verificationWechatName, ""),
		UserWechatName:         NotNilString(userWechatName, ""),
		UserPhone:              NotNilString(userPhone, ""),
		UseTimeStart:           int32(NotNilInt(useTimeStart, 0)),
		UseTimeEnd:             int32(NotNilInt(useTimeEnd, 0)),
		UserWechat:             NotNilString(userWechat, ""),
		StateCode:              NotNilString(stateCode, ""),
	}
	deductionOut, err := r.managementService.GetCouponList(ctx, &deductionIn)
	deductionRes := deductionOut.Data

	conn := model.CouponConnection{
		TotalCount:          len(results),
		TotalExchangeCount:  len(exchangeRes),
		TotalDeductionCount: len(deductionRes),
		Edges:               edges[:count],
		PageInfo: &model.PageInfo{
			StartCursor:     startCursor,
			EndCursor:       endCursor,
			HasPreviousPage: &hasPreviousPage,
			HasNextPage:     &hasNextPage,
		},
	}

	return &conn, nil
}

// CouponListGroupByType is the resolver for the couponListGroupByType field.
func (r *queryResolver) CouponListGroupByType(ctx context.Context, tideSpotID *string) (*model.CouponListGroupByTypeRes, error) {
	ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()
	user := auth.ForContext(ctx).User
	userWechat := &user.Wechat
	exchangeIn := mPB.CouponRequest{
		Type:       "Exchange",
		TideSpotId: NotNilString(tideSpotID, ""),
		UserWechat: NotNilString(userWechat, ""),
	}
	exchangeRes, err := r.managementService.GetCouponList(ctx, &exchangeIn)
	if err != nil {
		return nil, err
	}
	exchangeResults := make([]*model.Coupon, 0)
	for _, s := range exchangeRes.Data {
		exchangeResults = append(exchangeResults, r.NewCoupon(s))
	}

	deductionIn := mPB.CouponRequest{
		Type:       "Deduction",
		TideSpotId: NotNilString(tideSpotID, ""),
		UserWechat: NotNilString(userWechat, ""),
	}
	deductionRes, err := r.managementService.GetCouponList(ctx, &deductionIn)
	if err != nil {
		return nil, err
	}
	deductionResults := make([]*model.Coupon, 0)
	for _, s := range deductionRes.Data {
		deductionResults = append(deductionResults, r.NewCoupon(s))
	}

	return &model.CouponListGroupByTypeRes{
		ExchangeList:  exchangeResults,
		DeductionList: deductionResults,
	}, err
}

// CouponListByPagination is the resolver for the couponListByPagination field.
func (r *queryResolver) CouponListByPagination(ctx context.Context, pageIndex int, pageSize int, typeArg *string, stateCode *string, tideSpotName *string, tideSpotID *string, generateRule *string, buyGoodName *string, verificationWechatName *string, userWechatName *string, userPhone *string, useTimeStart *int, useTimeEnd *int, userWechat *string, backSearch *bool, tideSpotConfigID *string, buyGoodBarCode *string) (*model.CouponPagination, error) {
	ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()
	if NotNilBool(backSearch, false) {
		user := auth.ForContext(ctx).User
		userWechat = &user.Wechat
	}
	in := mPB.CouponRequest{
		Type:                   NotNilString(typeArg, ""),
		TideSpotName:           NotNilString(tideSpotName, ""),
		TideSpotId:             NotNilString(tideSpotName, ""),
		GenerateRule:           NotNilString(generateRule, ""),
		BuyGoodName:            NotNilString(buyGoodName, ""),
		VerificationWechatName: NotNilString(verificationWechatName, ""),
		UserWechatName:         NotNilString(userWechatName, ""),
		UserPhone:              NotNilString(userPhone, ""),
		UseTimeStart:           int32(NotNilInt(useTimeStart, 0)),
		UseTimeEnd:             int32(NotNilInt(useTimeEnd, 0)),
		UserWechat:             NotNilString(userWechat, ""),
		StateCode:              NotNilString(stateCode, ""),
		PageIndex:              int32(pageIndex),
		PageSize:               int32(pageSize),
	}

	res, err := r.managementService.GetCouponListByPage(ctx, &in)
	if err != nil {
		return nil, err
	}
	total := int(res.Total)
	results := make([]*model.Coupon, 0)
	for _, s := range res.Data {
		results = append(results, r.NewCoupon(s))
	}
	exchangeIn := mPB.CouponRequest{
		Type:                   "Exchange",
		TideSpotName:           NotNilString(tideSpotName, ""),
		TideSpotId:             NotNilString(tideSpotName, ""),
		GenerateRule:           NotNilString(generateRule, ""),
		BuyGoodName:            NotNilString(buyGoodName, ""),
		VerificationWechatName: NotNilString(verificationWechatName, ""),
		UserWechatName:         NotNilString(userWechatName, ""),
		UserPhone:              NotNilString(userPhone, ""),
		UseTimeStart:           int32(NotNilInt(useTimeStart, 0)),
		UseTimeEnd:             int32(NotNilInt(useTimeEnd, 0)),
		UserWechat:             NotNilString(userWechat, ""),
		StateCode:              NotNilString(stateCode, ""),
	}
	exchangeOut, err := r.managementService.GetCouponList(ctx, &exchangeIn)
	exchangeRes := exchangeOut.Data

	deductionIn := mPB.CouponRequest{
		Type:                   "Deduction",
		TideSpotName:           NotNilString(tideSpotName, ""),
		TideSpotId:             NotNilString(tideSpotName, ""),
		GenerateRule:           NotNilString(generateRule, ""),
		BuyGoodName:            NotNilString(buyGoodName, ""),
		VerificationWechatName: NotNilString(verificationWechatName, ""),
		UserWechatName:         NotNilString(userWechatName, ""),
		UserPhone:              NotNilString(userPhone, ""),
		UseTimeStart:           int32(NotNilInt(useTimeStart, 0)),
		UseTimeEnd:             int32(NotNilInt(useTimeEnd, 0)),
		UserWechat:             NotNilString(userWechat, ""),
		StateCode:              NotNilString(stateCode, ""),
	}
	deductionOut, err := r.managementService.GetCouponList(ctx, &deductionIn)
	deductionRes := deductionOut.Data

	useIn := mPB.CouponRequest{
		TideSpotName:           NotNilString(tideSpotName, ""),
		TideSpotId:             NotNilString(tideSpotName, ""),
		GenerateRule:           NotNilString(generateRule, ""),
		BuyGoodName:            NotNilString(buyGoodName, ""),
		VerificationWechatName: NotNilString(verificationWechatName, ""),
		UserWechatName:         NotNilString(userWechatName, ""),
		UserPhone:              NotNilString(userPhone, ""),
		UseTimeStart:           int32(NotNilInt(useTimeStart, 0)),
		UseTimeEnd:             int32(NotNilInt(useTimeEnd, 0)),
		UserWechat:             NotNilString(userWechat, ""),
		StateCode:              "Used",
	}
	useOut, err := r.managementService.GetCouponList(ctx, &useIn)
	useRes := useOut.Data

	expiredIn := mPB.CouponRequest{
		TideSpotName:           NotNilString(tideSpotName, ""),
		TideSpotId:             NotNilString(tideSpotName, ""),
		GenerateRule:           NotNilString(generateRule, ""),
		BuyGoodName:            NotNilString(buyGoodName, ""),
		VerificationWechatName: NotNilString(verificationWechatName, ""),
		UserWechatName:         NotNilString(userWechatName, ""),
		UserPhone:              NotNilString(userPhone, ""),
		UseTimeStart:           int32(NotNilInt(useTimeStart, 0)),
		UseTimeEnd:             int32(NotNilInt(useTimeEnd, 0)),
		UserWechat:             NotNilString(userWechat, ""),
		StateCode:              "Expired",
	}
	expiredOut, err := r.managementService.GetCouponList(ctx, &expiredIn)
	expiredRes := expiredOut.Data
	return &model.CouponPagination{
		Data:                results,
		TotalCount:          total,
		TotalExchangeCount:  len(exchangeRes),
		TotalDeductionCount: len(deductionRes),
		UseCount:            len(useRes),
		ExpireCount:         len(expiredRes),
	}, err
}

// Coupon is the resolver for the coupon field.
func (r *queryResolver) Coupon(ctx context.Context, id string) (*model.Coupon, error) {
	ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()

	req := mPB.MsKeyword{
		Value: id,
	}

	res, err := r.managementService.GetCoupon(ctx, &req)

	if err != nil {
		return nil, err
	}

	return r.NewCoupon(res), nil
}

// TideSpotConfig is the resolver for the tideSpotConfig field.
func (r *queryResolver) TideSpotConfig(ctx context.Context, id string) (*model.TideSpotConfig, error) {
	ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()

	req := mPB.MsKeyword{
		Value: id,
	}

	res, err := r.managementService.GetTideSpotConfigById(ctx, &req)

	if err != nil {
		return nil, err
	}

	return r.NewTideSpotConfig(res), nil
}

// TideSpotConfigList is the resolver for the tideSpotConfigList field.
func (r *queryResolver) TideSpotConfigList(ctx context.Context, first *int, after *string, last *int, before *string, typeArg *string, tideSpotID *string, enable *bool) (*model.TideSpotConfigConnection, error) {
	afterCursor, err := DecodedCursor(after)
	if err != nil {
		return nil, err
	}

	beforeCursor, err := DecodedCursor(before)
	if err != nil {
		return nil, err
	}

	edges := make([]*model.TideSpotConfigEdge, *first)
	count := 0
	currentPage := false

	if afterCursor == "" && beforeCursor == "" {
		currentPage = true
	}

	startCursor := ""
	endCursor := ""
	hasPreviousPage := false
	hasNextPage := false

	in := mPB.TideSpotConfigRequest{
		Type:       NotNilString(typeArg, ""),
		TideSpotId: NotNilString(tideSpotID, ""),
		Enable:     NotNilBool(enable, false),
	}

	out, err := r.managementService.GetTideSpotConfigList(ctx, &in)
	if err != nil {
		return nil, err
	}
	results := out.Data

	if afterCursor == "" && len(beforeCursor) > 0 {
		for i, v := range results {
			if v.Id == beforeCursor {
				currentPage = true
			}
			if currentPage && *last > 0 {
				m, n := i-*last, i
				if m < 0 {
					m = 0
				}
				for _, v := range results[m:n] {
					edges[count] = &model.TideSpotConfigEdge{
						Cursor: EncodeToCursor(v.Id),
						Node:   r.NewTideSpotConfig(v),
					}
					count++
				}

				hasPreviousPage = i-count > 0
				hasNextPage = i < len(results)-1
				break
			}
		}
	} else {
		for i, v := range results {
			if currentPage && count < *first {
				edges[count] = &model.TideSpotConfigEdge{
					Cursor: EncodeToCursor(v.Id),
					Node:   r.NewTideSpotConfig(v),
				}
				count++
			}

			if v.Id == afterCursor {
				currentPage = true
			}

			if hasPreviousPage == false {
				hasPreviousPage = i-count >= 0
			}

			if count == *first {
				hasNextPage = i < len(results)-1
				break
			}
		}
	}

	if count > 0 {
		startCursor = EncodeToCursor(edges[0].Node.ID)
		endCursor = EncodeToCursor(edges[count-1].Node.ID)
	}
	configCount, err := r.managementService.GetTideSpotConfigCount(ctx, &in)
	if err != nil {
		return nil, err
	}
	conn := model.TideSpotConfigConnection{
		TotalCount: len(results),
		Edges:      edges[:count],
		PageInfo: &model.PageInfo{
			StartCursor:     startCursor,
			EndCursor:       endCursor,
			HasPreviousPage: &hasPreviousPage,
			HasNextPage:     &hasNextPage,
		},
		TotalGenerateNum: int(configCount.TotalGenerateNum),
		TotalUseNum:      int(configCount.TotalUseNum),
		TotalNotUseNum:   int(configCount.TotalNotUseNum),
		TotalUseAmount:   int(configCount.TotalUseAmount),
	}

	return &conn, nil
}

// TideSpotList is the resolver for the tideSpotList field.
func (r *queryResolver) TideSpotList(ctx context.Context, first *int, after *string, last *int, before *string, name *string) (*model.TideSpotConnection, error) {
	afterCursor, err := DecodedCursor(after)
	if err != nil {
		return nil, err
	}

	beforeCursor, err := DecodedCursor(before)
	if err != nil {
		return nil, err
	}

	edges := make([]*model.TideSpotEdge, *first)
	count := 0
	currentPage := false

	if afterCursor == "" && beforeCursor == "" {
		currentPage = true
	}

	startCursor := ""
	endCursor := ""
	hasPreviousPage := false
	hasNextPage := false

	in := mPB.MsKeyword{Value: *name}

	out, err := r.managementService.GetTideSpotList(ctx, &in)
	if err != nil {
		return nil, err
	}
	results := out.Data

	if afterCursor == "" && len(beforeCursor) > 0 {
		for i, v := range results {
			if v.Id == beforeCursor {
				currentPage = true
			}
			if currentPage && *last > 0 {
				m, n := i-*last, i
				if m < 0 {
					m = 0
				}
				for _, v := range results[m:n] {
					edges[count] = &model.TideSpotEdge{
						Cursor: EncodeToCursor(v.Id),
						Node:   r.NewTideSpot(v),
					}
					count++
				}

				hasPreviousPage = i-count > 0
				hasNextPage = i < len(results)-1
				break
			}
		}
	} else {
		for i, v := range results {
			if currentPage && count < *first {
				edges[count] = &model.TideSpotEdge{
					Cursor: EncodeToCursor(v.Id),
					Node:   r.NewTideSpot(v),
				}
				count++
			}

			if v.Id == afterCursor {
				currentPage = true
			}

			if hasPreviousPage == false {
				hasPreviousPage = i-count >= 0
			}

			if count == *first {
				hasNextPage = i < len(results)-1
				break
			}
		}
	}

	if count > 0 {
		startCursor = EncodeToCursor(edges[0].Node.ID)
		endCursor = EncodeToCursor(edges[count-1].Node.ID)
	}

	conn := model.TideSpotConnection{
		TotalCount: len(results),
		Edges:      edges[:count],
		PageInfo: &model.PageInfo{
			StartCursor:     startCursor,
			EndCursor:       endCursor,
			HasPreviousPage: &hasPreviousPage,
			HasNextPage:     &hasNextPage,
		},
	}

	return &conn, nil
}

// AreaInfoByParentID is the resolver for the areaInfoByParentID field.
func (r *queryResolver) AreaInfoByParentID(ctx context.Context, typeArg string, parentID *string) ([]*model.AreaInfo, error) {
	ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()

	req := mPB.AreaInfoRequest{
		Type:     typeArg,
		ParentId: *parentID,
	}

	res, err := r.managementService.GetAreaInfoByParentID(ctx, &req)

	if err != nil {
		return nil, err
	}

	results := make([]*model.AreaInfo, 0)
	for _, s := range res.Data {
		results = append(results, &model.AreaInfo{
			ID:       s.Id,
			Name:     s.Name,
			ParentID: &s.ParentId,
		})
	}

	return results, err
}

// TurtleBackMenuList is the resolver for the turtleBackMenuList field.
func (r *queryResolver) TurtleBackMenuList(ctx context.Context) ([]*model.TurtleBackMenu, error) {
	req := mPB.MsKeyword{}

	res, err := r.managementService.GetTurtleBackMenuList(ctx, &req)
	if err != nil {
		return nil, err
	}

	results := make([]*model.TurtleBackMenu, 0)
	for _, s := range res.Data {
		results = append(results, &model.TurtleBackMenu{
			ID:       s.Id,
			MenuName: &s.MenuName,
			MenuCode: &s.MenuCode,
			Path:     &s.Path,
		})
	}

	return results, err
}

// TurtleBackConfigList is the resolver for the turtleBackConfigList field.
func (r *queryResolver) TurtleBackConfigList(ctx context.Context) ([]*model.TurtleBackConfig, error) {
	req := mPB.MsKeyword{}

	res, err := r.managementService.GetTurtleBackConfigList(ctx, &req)
	if err != nil {
		return nil, err
	}

	results := make([]*model.TurtleBackConfig, 0)
	for _, s := range res.Data {
		results = append(results, &model.TurtleBackConfig{
			ID:             s.Id,
			Sort:           int(s.Sort),
			MenuName:       s.MenuName,
			MenuConfigName: s.MenuConfigName,
			Path:           s.Path,
			Enable:         s.Enable,
			IconPath:       &s.IconPath,
			MenuCode:       &s.MenuCode,
		})
	}

	return results, err
}

// TurtleBackConfig is the resolver for the turtleBackConfig field.
func (r *queryResolver) TurtleBackConfig(ctx context.Context, id string) (*model.TurtleBackConfig, error) {
	ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()

	req := mPB.MsKeyword{
		Value: id,
	}

	res, err := r.managementService.GetTurtleBackConfig(ctx, &req)

	if err != nil {
		return nil, err
	}

	return &model.TurtleBackConfig{
		ID:             res.Id,
		Sort:           int(res.Sort),
		MenuName:       res.MenuName,
		MenuConfigName: res.MenuConfigName,
		Path:           res.Path,
		Enable:         res.Enable,
		IconPath:       &res.IconPath,
		MenuCode:       &res.MenuCode,
	}, nil
}

// Configs is the resolver for the configs field.
func (r *queryResolver) Configs(ctx context.Context) (map[string]any, error) {
	out, err := r.managementService.GetConfigs(ctx, &mPB.ConfigRequest{})
	if err != nil {
		return nil, err
	}

	result := make(map[string]interface{})
	for _, config := range out.Data {
		result[config.Key] = config.Value
	}

	return result, nil
}

// Category is the resolver for the category field.
func (r *queryResolver) Category(ctx context.Context, id string) (*model.Category, error) {
	ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()

	req := mPB.MsKeyword{
		Value: id,
	}

	res, err := r.managementService.GetCategoryByID(ctx, &req)

	if err != nil {
		return nil, err
	}

	return &model.Category{
		ID:          res.Id,
		Name:        res.Name,
		ParentID:    &res.ParentId,
		HasSubclass: &res.HasSubclass,
		Status:      int(res.Status),
		Sort:        int(res.Sort),
	}, nil
}

// CategoryByName is the resolver for the categoryByName field.
func (r *queryResolver) CategoryByName(ctx context.Context, name string) (*model.Category, error) {
	ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()

	req := mPB.MsKeyword{
		Value: name,
	}

	res, err := r.managementService.GetCategoryByName(ctx, &req)

	if err != nil {
		return nil, err
	}

	return &model.Category{
		ID:          res.Id,
		Name:        res.Name,
		ParentID:    &res.ParentId,
		HasSubclass: &res.HasSubclass,
		Status:      int(res.Status),
		Sort:        int(res.Sort),
	}, nil
}

// CategoriesByParentID is the resolver for the categoriesByParentID field.
func (r *queryResolver) CategoriesByParentID(ctx context.Context, id string) ([]*model.Category, error) {
	ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()

	req := mPB.MsKeyword{
		Value: id,
	}

	res, err := r.managementService.GetCategoryByParentID(ctx, &req)

	if err != nil {
		return nil, err
	}

	results := make([]*model.Category, 0)
	for _, s := range res.Data {
		results = append(results, &model.Category{
			ID:          s.Id,
			Name:        s.Name,
			ParentID:    &s.ParentId,
			HasSubclass: &s.HasSubclass,
			Status:      int(s.Status),
			Sort:        int(s.Sort),
		})
	}

	return results, err
}

// TopCategories is the resolver for the topCategories field.
func (r *queryResolver) TopCategories(ctx context.Context) ([]*model.Category, error) {
	ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()

	req := mPB.MsEmptyReq{}

	res, err := r.managementService.GetTopCategory(ctx, &req)

	if err != nil {
		return nil, err
	}

	results := make([]*model.Category, 0)
	for _, s := range res.Data {
		results = append(results, &model.Category{
			ID:          s.Id,
			Name:        s.Name,
			ParentID:    &s.ParentId,
			HasSubclass: &s.HasSubclass,
			Status:      int(s.Status),
			Sort:        int(s.Sort),
		})
	}

	return results, err
}

// Tag is the resolver for the tag field.
func (r *queryResolver) Tag(ctx context.Context, id string) (*model.Tag, error) {
	ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()

	req := mPB.MsKeyword{
		Value: id,
	}

	res, err := r.managementService.GetTagByID(ctx, &req)

	if err != nil {
		return nil, err
	}

	return &model.Tag{
		ID:         res.Id,
		Name:       res.Name,
		CategoryID: res.CategoryId,
		Status:     int(res.Status),
	}, nil
}

// TagByCategory is the resolver for the tagByCategory field.
func (r *queryResolver) TagByCategory(ctx context.Context, category string) ([]*model.Tag, error) {
	ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()

	req := mPB.MsKeyword{
		Value: category,
	}

	res, err := r.managementService.GetTagByCategoryID(ctx, &req)

	if err != nil {
		return nil, err
	}

	results := make([]*model.Tag, 0)
	for _, s := range res.Data {
		results = append(results, &model.Tag{
			ID:         s.Id,
			Name:       s.Name,
			CategoryID: s.CategoryId,
			Status:     int(s.Status),
		})
	}

	return results, err
}

// Tweet is the resolver for the tweet field.
func (r *queryResolver) Tweet(ctx context.Context, id string) (*model.Tweet, error) {
	ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()

	req := msgPB.MsgsKeyword{
		Value: id,
	}

	res, err := r.messageService.GetTweet(ctx, &req)

	if err != nil {
		return nil, err
	}

	lc := int(res.LikeCount)
	sc := int(res.ShareCount)
	vc := int(res.ViewCount)

	return &model.Tweet{
		ID:            res.Id,
		UserID:        res.UserId,
		Content:       res.Content,
		LikeCount:     &lc,
		ShareCount:    &sc,
		ViewCount:     &vc,
		Status:        int(res.Status),
		CreateTime:    int(res.CreateTime),
		EventID:       res.EventId,
		SceneryspotID: res.SceneryspotId,
		Location:      &res.Location,
		Region:        &res.Region,
	}, err
}

// Tweets is the resolver for the tweets field.
func (r *queryResolver) Tweets(ctx context.Context, userID string) ([]*model.Tweet, error) {
	ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()

	req := msgPB.MsgsKeyword{
		Value: userID,
	}

	res, err := r.messageService.GetTweetByUserID(ctx, &req)

	if err != nil {
		return nil, err
	}

	results := make([]*model.Tweet, 0)
	for _, s := range res.Data {
		lc := int(s.LikeCount)
		sc := int(s.ShareCount)
		vc := int(s.ViewCount)
		results = append(results, &model.Tweet{
			ID:            s.Id,
			UserID:        s.UserId,
			Content:       s.Content,
			LikeCount:     &lc,
			ShareCount:    &sc,
			ViewCount:     &vc,
			Status:        int(s.Status),
			CreateTime:    int(s.CreateTime),
			EventID:       s.EventId,
			SceneryspotID: s.SceneryspotId,
			Location:      &s.Location,
			Region:        &s.Region,
		})
	}

	return results, err
}

// NewestTweet is the resolver for the newestTweet field.
func (r *queryResolver) NewestTweet(ctx context.Context, eventID string, sceneryspotID string, count int) ([]*model.TweetWithAccount, error) {
	ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()

	req := msgPB.NewestTweetReq{
		EventId:       eventID,
		SceneryspotId: sceneryspotID,
		PageIndex:     1,
		PageSize:      int32(count),
	}

	res, err := r.messageService.GetNewestTweet(ctx, &req)
	if err != nil {
		return nil, err
	}

	results := make([]*model.TweetWithAccount, 0)
	for _, s := range res.Data {

		aReq := aPB.AsKeyword{
			Value: s.UserId,
		}

		if account, err := r.accountService.GetAccount(ctx, &aReq); err == nil {
			ct := int(s.CreateTime)
			lc := int(s.LikeCount)
			sc := int(s.ShareCount)
			vc := int(s.ViewCount)

			results = append(results, &model.TweetWithAccount{
				ID:            s.Id,
				UserID:        s.UserId,
				WechatName:    account.WechatName,
				WechatAvatar:  account.WechatAvatar,
				Content:       s.Content,
				LikeCount:     &lc,
				ShareCount:    &sc,
				ViewCount:     &vc,
				Status:        int(s.Status),
				CreateTime:    &ct,
				EventID:       s.EventId,
				SceneryspotID: sceneryspotID,
				Location:      &s.Location,
				Region:        &s.Region,
			})
		}
	}

	return results, err
}

// NewestTweetByPagination is the resolver for the newestTweetByPagination field.
func (r *queryResolver) NewestTweetByPagination(ctx context.Context, eventID string, sceneryspotID string, pageIndex int, pageSize int) (*model.TweetConnection, error) {
	ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()

	req := msgPB.NewestTweetReq{
		EventId:       eventID,
		SceneryspotId: sceneryspotID,
		PageIndex:     int32(pageIndex),
		PageSize:      int32(pageSize),
	}

	res, err := r.messageService.GetNewestTweet(ctx, &req)
	if err != nil {
		return nil, err
	}
	total := int(res.Total)

	results := make([]*model.TweetWithAccount, 0)
	for _, s := range res.Data {

		aReq := aPB.AsKeyword{
			Value: s.UserId,
		}

		if account, err := r.accountService.GetAccount(ctx, &aReq); err == nil {
			ct := int(s.CreateTime)
			lc := int(s.LikeCount)
			sc := int(s.ShareCount)
			vc := int(s.ViewCount)

			results = append(results, &model.TweetWithAccount{
				ID:            s.Id,
				UserID:        s.UserId,
				WechatName:    account.WechatName,
				WechatAvatar:  account.WechatAvatar,
				Content:       s.Content,
				LikeCount:     &lc,
				ShareCount:    &sc,
				ViewCount:     &vc,
				Status:        int(s.Status),
				CreateTime:    &ct,
				EventID:       s.EventId,
				SceneryspotID: sceneryspotID,
				Location:      &s.Location,
				Region:        &s.Region,
			})
		}
	}

	return &model.TweetConnection{
		Tweets: results,
		Total:  &total,
	}, err
}

// Followers is the resolver for the followers field.
func (r *queryResolver) Followers(ctx context.Context, userID string) ([]*model.Followers, error) {
	ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()

	req := msgPB.MsgsKeyword{
		Value: userID,
	}

	res, err := r.messageService.GetFollowersByUserID(ctx, &req)

	if err != nil {
		return nil, err
	}

	results := make([]*model.Followers, 0)
	for _, s := range res.Data {
		ft := int(s.FollowerTime)
		results = append(results, &model.Followers{
			UserID:       s.UserId,
			Follower:     s.Follower,
			FollowerTime: &ft,
		})
	}

	return results, err
}

// Following is the resolver for the following field.
func (r *queryResolver) Following(ctx context.Context, userID string) ([]*model.Following, error) {
	ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()

	req := msgPB.MsgsKeyword{
		Value: userID,
	}

	res, err := r.messageService.GetFollowingByUserID(ctx, &req)

	if err != nil {
		return nil, err
	}

	results := make([]*model.Following, 0)
	for _, s := range res.Data {
		ft := int(s.FollowingTime)
		results = append(results, &model.Following{
			UserID:        s.UserId,
			Following:     s.Following,
			FollowingTime: &ft,
		})
	}

	return results, err
}

// TweetLikeRecords is the resolver for the tweetLikeRecords field.
func (r *queryResolver) TweetLikeRecords(ctx context.Context, tweetID string) ([]*model.TweetLikeRecord, error) {
	ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()

	req := msgPB.MsgsKeyword{
		Value: tweetID,
	}

	res, err := r.messageService.GetTweetLikeRecord(ctx, &req)

	if err != nil {
		return nil, err
	}

	results := make([]*model.TweetLikeRecord, 0)
	for _, s := range res.Data {
		lt := int(s.LikeTime)
		results = append(results, &model.TweetLikeRecord{
			ID:             s.Id,
			TweetID:        s.TweetId,
			LikeUserID:     &s.LikeUserId,
			LikeUserName:   &s.LikeUserName,
			LikeUserAvatar: &s.LikeUserAvatar,
			LikeTime:       &lt,
		})
	}

	return results, err
}

// TweetViewRecords is the resolver for the tweetViewRecords field.
func (r *queryResolver) TweetViewRecords(ctx context.Context, tweetID string) ([]*model.TweetViewRecord, error) {
	ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()

	req := msgPB.MsgsKeyword{
		Value: tweetID,
	}

	res, err := r.messageService.GetTweetViewRecord(ctx, &req)

	if err != nil {
		return nil, err
	}

	results := make([]*model.TweetViewRecord, 0)
	for _, s := range res.Data {
		vt := int(s.ViewTime)
		results = append(results, &model.TweetViewRecord{
			ID:             s.Id,
			TweetID:        s.TweetId,
			ViewUserID:     &s.ViewUserId,
			ViewUserName:   &s.ViewUserName,
			ViewUserAvatar: &s.ViewUserAvatar,
			ViewTime:       &vt,
		})
	}

	return results, err
}

// TweetShareRecords is the resolver for the tweetShareRecords field.
func (r *queryResolver) TweetShareRecords(ctx context.Context, tweetID string) ([]*model.TweetShareRecord, error) {
	ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()

	req := msgPB.MsgsKeyword{
		Value: tweetID,
	}

	res, err := r.messageService.GetTweetShareRecord(ctx, &req)

	if err != nil {
		return nil, err
	}

	results := make([]*model.TweetShareRecord, 0)
	for _, s := range res.Data {
		st := int(s.ShareTime)
		results = append(results, &model.TweetShareRecord{
			ID:              s.Id,
			TweetID:         s.TweetId,
			ShareUserID:     &s.ShareUserId,
			ShareUserName:   &s.ShareUserName,
			ShareUserAvatar: &s.ShareUserAvatar,
			ShareTime:       &st,
		})
	}

	return results, err
}

// TweetLikers is the resolver for the tweetLikers field.
func (r *queryResolver) TweetLikers(ctx context.Context, tweetID string) ([]*model.TweetUserRef, error) {
	ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()

	req := msgPB.MsgsKeyword{
		Value: tweetID,
	}

	res, err := r.messageService.GetTweetLikers(ctx, &req)
	if err != nil {
		return nil, err
	}

	results := make([]*model.TweetUserRef, 0)
	for _, s := range res.Data {
		if userInfo, err := r.accountService.GetAccount(ctx, &aPB.AsKeyword{Value: s.UserId}); err == nil {
			results = append(results, &model.TweetUserRef{
				TweetID:      s.TweetId,
				UserID:       s.UserId,
				WechatName:   userInfo.WechatName,
				WechatAvatar: userInfo.WechatAvatar,
			})
		}
	}

	return results, err
}

// TweetSharers is the resolver for the tweetSharers field.
func (r *queryResolver) TweetSharers(ctx context.Context, tweetID string) ([]*model.TweetUserRef, error) {
	ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()

	req := msgPB.MsgsKeyword{
		Value: tweetID,
	}

	res, err := r.messageService.GetTweetSharers(ctx, &req)

	if err != nil {
		return nil, err
	}

	results := make([]*model.TweetUserRef, 0)
	for _, s := range res.Data {

		userInfo, err := r.accountService.GetAccount(ctx, &aPB.AsKeyword{Value: s.UserId})
		if err != nil {
			return nil, err
		}

		results = append(results, &model.TweetUserRef{
			TweetID:      s.TweetId,
			UserID:       s.UserId,
			WechatName:   userInfo.WechatName,
			WechatAvatar: userInfo.WechatAvatar,
		})
	}

	return results, err
}

// TweetViewers is the resolver for the tweetViewers field.
func (r *queryResolver) TweetViewers(ctx context.Context, tweetID string) ([]*model.TweetUserRef, error) {
	ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()

	req := msgPB.MsgsKeyword{
		Value: tweetID,
	}

	res, err := r.messageService.GetTweetViewers(ctx, &req)

	if err != nil {
		return nil, err
	}

	results := make([]*model.TweetUserRef, 0)
	for _, s := range res.Data {

		userInfo, err := r.accountService.GetAccount(ctx, &aPB.AsKeyword{Value: s.UserId})
		if err != nil {
			return nil, err
		}

		results = append(results, &model.TweetUserRef{
			TweetID:      s.TweetId,
			UserID:       s.UserId,
			WechatName:   userInfo.WechatName,
			WechatAvatar: userInfo.WechatAvatar,
		})
	}

	return results, err
}

// TweetUserActionState is the resolver for the tweetUserActionState field.
func (r *queryResolver) TweetUserActionState(ctx context.Context, tweetID string) ([]*model.TweetUserActionState, error) {
	ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()

	req := msgPB.MsgsKeyword{
		Value: tweetID,
	}

	res, err := r.messageService.GetTweetUserActionState(ctx, &req)

	if err != nil {
		return nil, err
	}

	results := make([]*model.TweetUserActionState, 0)
	for _, s := range res.Data {

		userInfo, err := r.accountService.GetAccount(ctx, &aPB.AsKeyword{Value: s.UserId})
		if err != nil {
			return nil, err
		}

		results = append(results, &model.TweetUserActionState{
			TweetID:      s.TweetId,
			UserID:       s.UserId,
			WechatName:   userInfo.WechatName,
			WechatAvatar: userInfo.WechatAvatar,
			Like:         int(s.Like),
			Share:        int(s.Share),
			View:         int(s.View),
		})
	}

	return results, err
}

// UserRecordByUserID is the resolver for the userRecordByUserId field.
func (r *queryResolver) UserRecordByUserID(ctx context.Context, id string, action string) ([]*model.UserRrcord, error) {
	ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()

	req := msgPB.UserRecordReq{
		UserId:     id,
		ActionType: action,
	}

	res, err := r.messageService.GetUserRecordByUserId(ctx, &req)

	if err != nil {
		return nil, err
	}

	userInfo, err := r.accountService.GetAccount(ctx, &aPB.AsKeyword{Value: id})
	if err != nil {
		return nil, err
	}

	results := make([]*model.UserRrcord, 0)
	for _, s := range res.Data {
		tweetOwner, err := r.accountService.GetAccount(ctx, &aPB.AsKeyword{Value: s.TweetUserId})
		if err != nil {
			return nil, err
		}

		results = append(results, &model.UserRrcord{
			ID:              s.Id,
			UserID:          s.UserId,
			UserName:        userInfo.WechatName,
			UserAvatar:      userInfo.WechatAvatar,
			TweetID:         s.TweetId,
			TweetUserID:     s.TweetUserId,
			TweetUserName:   tweetOwner.WechatName,
			TweetUserAvatar: tweetOwner.WechatAvatar,
			ActionType:      s.ActionType,
			Time:            int(s.Time),
		})
	}

	return results, err
}

// UserRecordByTweetUserID is the resolver for the userRecordByTweetUserId field.
func (r *queryResolver) UserRecordByTweetUserID(ctx context.Context, id string, action string) ([]*model.UserRrcord, error) {
	ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()

	req := msgPB.UserRecordReq{
		UserId:     id,
		ActionType: action,
	}

	res, err := r.messageService.GetUserRecordByTweetUserId(ctx, &req)

	if err != nil {
		return nil, err
	}

	tweetOwner, err := r.accountService.GetAccount(ctx, &aPB.AsKeyword{Value: id})
	if err != nil {
		return nil, err
	}

	results := make([]*model.UserRrcord, 0)
	for _, s := range res.Data {
		userInfo, err := r.accountService.GetAccount(ctx, &aPB.AsKeyword{Value: s.UserId})
		if err != nil {
			return nil, err
		}

		results = append(results, &model.UserRrcord{
			ID:              s.Id,
			UserID:          s.UserId,
			UserName:        userInfo.WechatName,
			UserAvatar:      userInfo.WechatAvatar,
			TweetID:         s.TweetId,
			TweetUserID:     s.TweetUserId,
			TweetUserName:   tweetOwner.WechatName,
			TweetUserAvatar: tweetOwner.WechatAvatar,
			ActionType:      s.ActionType,
			Time:            int(s.Time),
		})
	}

	return results, err
}

// Event is the resolver for the event field.
func (r *queryResolver) Event(ctx context.Context, id string) (*model.Event, error) {
	ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()

	req := ePB.EsKeyword{
		Value: id,
	}

	res, err := r.eventService.GetEvent(ctx, &req)

	if err != nil {
		return nil, err
	}

	es, err := r.eventService.GetEventScenerySpots(ctx, &ePB.EsKeyword{Value: res.Id})

	if err != nil {
		return nil, err
	}

	ss := make([]*model.EventSceneryspot, 0)
	if es.Data != nil {
		for _, ess := range es.Data {
			ss = append(ss, &model.EventSceneryspot{
				EventID:       ess.EventId,
				ScenerySpotID: ess.ScenerySpotId,
			})
		}
	}

	ct := int(res.CreateTime)

	return &model.Event{
		ID:           res.Id,
		Code:         res.Code,
		Name:         res.Name,
		StartTime:    int(res.StartTime),
		EndTime:      int(res.EndTime),
		Introduction: &res.Introduction,
		Images:       &res.Images,
		Step:         &res.Step,
		Status:       int(res.Status),
		CreateTime:   &ct,
		EnableAward:  res.EnableAward,
		CategoryID:   &res.CategoryId,
		ScenerySpots: ss,
	}, nil
}

// Events is the resolver for the events field.
func (r *queryResolver) Events(ctx context.Context) ([]*model.Event, error) {
	ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()

	req := ePB.EsEmptyReq{}

	res, err := r.eventService.GetEvents(ctx, &req)

	if err != nil {
		return nil, err
	}

	results := make([]*model.Event, 0)
	for _, s := range res.Data {

		es, err := r.eventService.GetEventScenerySpots(ctx, &ePB.EsKeyword{Value: s.Id})

		if err != nil {
			return nil, err
		}

		ss := make([]*model.EventSceneryspot, 0)
		if es.Data != nil {
			for _, ess := range es.Data {
				ss = append(ss, &model.EventSceneryspot{
					EventID:       ess.EventId,
					ScenerySpotID: ess.ScenerySpotId,
				})
			}
		}

		ct := int(s.CreateTime)
		results = append(results, &model.Event{
			ID:           s.Id,
			Code:         s.Code,
			Name:         s.Name,
			StartTime:    int(s.StartTime),
			EndTime:      int(s.EndTime),
			Introduction: &s.Introduction,
			Images:       &s.Images,
			Step:         &s.Step,
			Status:       int(s.Status),
			CreateTime:   &ct,
			EnableAward:  s.EnableAward,
			CategoryID:   &s.CategoryId,
			ScenerySpots: ss,
		})
	}

	return results, err
}

// EventSceneryspots is the resolver for the eventSceneryspots field.
func (r *queryResolver) EventSceneryspots(ctx context.Context, eventID string) ([]*model.EventSceneryspot, error) {
	ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()

	req := ePB.EsKeyword{
		Value: eventID,
	}

	res, err := r.eventService.GetEventScenerySpots(ctx, &req)

	if err != nil {
		return nil, err
	}

	results := make([]*model.EventSceneryspot, 0)
	for _, s := range res.Data {
		results = append(results, &model.EventSceneryspot{
			EventID:       s.EventId,
			ScenerySpotID: s.ScenerySpotId,
		})
	}

	return results, err
}

// Badge is the resolver for the badge field.
func (r *queryResolver) Badge(ctx context.Context, id string) (*model.Badge, error) {
	ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()

	req := ePB.EsKeyword{
		Value: id,
	}

	res, err := r.eventService.GetBadge(ctx, &req)

	if err != nil {
		return nil, err
	}

	return &model.Badge{
		ID:      res.Id,
		Name:    res.Name,
		EventID: res.EventId,
		Images:  &res.Images,
	}, nil
}

// Badges is the resolver for the badges field.
func (r *queryResolver) Badges(ctx context.Context, eventID string) ([]*model.Badge, error) {
	ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()

	req := ePB.EsKeyword{
		Value: eventID,
	}

	res, err := r.eventService.GetBadgesByEventID(ctx, &req)

	if err != nil {
		return nil, err
	}

	results := make([]*model.Badge, 0)
	for _, s := range res.Data {
		results = append(results, &model.Badge{
			ID:      s.Id,
			Name:    s.Name,
			EventID: s.EventId,
			Images:  &s.Images,
		})
	}

	return results, err
}

// UserBadges is the resolver for the userBadges field.
func (r *queryResolver) UserBadges(ctx context.Context, userID string) ([]*model.UserBadge, error) {
	ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()

	req := ePB.EsKeyword{
		Value: userID,
	}

	res, err := r.eventService.GetUserBadgeByUserID(ctx, &req)

	if err != nil {
		return nil, err
	}

	results := make([]*model.UserBadge, 0)
	for _, s := range res.Data {
		results = append(results, &model.UserBadge{
			UserID:  s.UserId,
			BadgeID: s.BadgeId,
			Status:  int(s.Status),
		})
	}

	return results, err
}

// UserBadgeSwap is the resolver for the userBadgeSwap field.
func (r *queryResolver) UserBadgeSwap(ctx context.Context, id string) (*model.UserBadgeSwap, error) {
	ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()

	req := ePB.EsKeyword{
		Value: id,
	}

	res, err := r.eventService.GetUserBadgeSwap(ctx, &req)

	if err != nil {
		return nil, err
	}

	return &model.UserBadgeSwap{
		ID:         res.Id,
		BadgeID:    res.BadgeId,
		From:       res.From,
		To:         &res.To,
		PreviousID: &res.PreviousId,
		City:       &res.City,
		Content:    &res.Content,
		Status:     int(res.Status),
		CreateTime: int(res.CreateTime),
	}, nil
}

// UserBadgeSwapByPreviousID is the resolver for the userBadgeSwapByPreviousID field.
func (r *queryResolver) UserBadgeSwapByPreviousID(ctx context.Context, id string) (*model.UserBadgeSwap, error) {
	ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()

	req := ePB.EsKeyword{
		Value: id,
	}

	res, err := r.eventService.GetUserBadgeSwapByPreviousID(ctx, &req)

	if err != nil {
		return nil, err
	}

	return &model.UserBadgeSwap{
		ID:         res.Id,
		BadgeID:    res.BadgeId,
		From:       res.From,
		To:         &res.To,
		PreviousID: &res.PreviousId,
		City:       &res.City,
		Content:    &res.Content,
		Status:     int(res.Status),
		CreateTime: int(res.CreateTime),
	}, nil
}

// UserBadgeSwapByFrom is the resolver for the userBadgeSwapByFrom field.
func (r *queryResolver) UserBadgeSwapByFrom(ctx context.Context, id string) ([]*model.UserBadgeSwap, error) {
	ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()

	req := ePB.EsKeyword{
		Value: id,
	}

	res, err := r.eventService.GetUserBadgeSwapByFrom(ctx, &req)

	if err != nil {
		return nil, err
	}

	results := make([]*model.UserBadgeSwap, 0)
	for _, s := range res.Data {
		results = append(results, &model.UserBadgeSwap{
			ID:         s.Id,
			BadgeID:    s.BadgeId,
			From:       s.From,
			To:         &s.To,
			PreviousID: &s.PreviousId,
			City:       &s.City,
			Content:    &s.Content,
			Status:     int(s.Status),
			CreateTime: int(s.CreateTime),
		})
	}

	return results, err
}

// UserBadgeSwapByTo is the resolver for the userBadgeSwapByTo field.
func (r *queryResolver) UserBadgeSwapByTo(ctx context.Context, id string) ([]*model.UserBadgeSwap, error) {
	ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()

	req := ePB.EsKeyword{
		Value: id,
	}

	res, err := r.eventService.GetUserBadgeSwapByTo(ctx, &req)

	if err != nil {
		return nil, err
	}

	results := make([]*model.UserBadgeSwap, 0)
	for _, s := range res.Data {
		results = append(results, &model.UserBadgeSwap{
			ID:         s.Id,
			BadgeID:    s.BadgeId,
			From:       s.From,
			To:         &s.To,
			PreviousID: &s.PreviousId,
			City:       &s.City,
			Content:    &s.Content,
			Status:     int(s.Status),
			CreateTime: int(s.CreateTime),
		})
	}

	return results, err
}

// PassportSet is the resolver for the passportSet field.
func (r *queryResolver) PassportSet(ctx context.Context, id string) (*model.PassportSet, error) {
	ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()

	req := ePB.EsKeyword{
		Value: id,
	}

	res, err := r.eventService.GetPassportSet(ctx, &req)

	if err != nil {
		return nil, err
	}

	return &model.PassportSet{
		ID:       res.Id,
		EventID:  res.EventId,
		Name:     res.Name,
		Status:   int(res.Status),
		Quantity: int(res.Quantity),
		Issued:   int(res.Issued),
	}, nil
}

// PassportSetByName is the resolver for the passportSetByName field.
func (r *queryResolver) PassportSetByName(ctx context.Context, name string) (*model.PassportSet, error) {
	ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()

	req := ePB.EsKeyword{
		Value: name,
	}

	res, err := r.eventService.GetPassportSetByName(ctx, &req)

	if err != nil {
		return nil, err
	}

	return &model.PassportSet{
		ID:       res.Id,
		EventID:  res.EventId,
		Name:     res.Name,
		Status:   int(res.Status),
		Quantity: int(res.Quantity),
		Issued:   int(res.Issued),
	}, nil
}

// PassportSets is the resolver for the passportSets field.
func (r *queryResolver) PassportSets(ctx context.Context, eventID string) ([]*model.PassportSet, error) {
	ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()

	req := ePB.EsKeyword{
		Value: eventID,
	}

	res, err := r.eventService.GetPassportSetByEventID(ctx, &req)

	if err != nil {
		return nil, err
	}

	results := make([]*model.PassportSet, 0)
	for _, s := range res.Data {
		results = append(results, &model.PassportSet{
			ID:       s.Id,
			EventID:  s.EventId,
			Name:     s.Name,
			Status:   int(s.Status),
			Quantity: int(s.Quantity),
			Issued:   int(s.Issued),
		})
	}

	return results, err
}

// Passport is the resolver for the passport field.
func (r *queryResolver) Passport(ctx context.Context, id string) (*model.Passport, error) {
	ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()

	pass, err := r.eventService.GetPassport(ctx, &ePB.EsKeyword{Value: id})
	if err != nil {
		return nil, err
	}
	ps, err := r.eventService.GetPassportSet(ctx, &ePB.EsKeyword{Value: pass.PassportSetId})
	if err != nil {
		return nil, err
	}

	return &model.Passport{
		ID:            pass.Id,
		PassportSetID: pass.PassportSetId,
		EventID:       ps.EventId,
		Code:          pass.Code,
		Status:        int(pass.Status),
	}, nil
}

// PassportByCode is the resolver for the passportByCode field.
func (r *queryResolver) PassportByCode(ctx context.Context, code string) (*model.Passport, error) {
	ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()

	out, err := r.eventService.GetPassportByCode(ctx, &ePB.EsKeyword{Value: code})
	if err != nil {
		return nil, err
	}

	ps, err := r.eventService.GetPassportSet(ctx, &ePB.EsKeyword{Value: out.PassportSetId})
	if err != nil {
		return nil, err
	}

	return &model.Passport{
		ID:            out.Id,
		PassportSetID: out.PassportSetId,
		EventID:       ps.EventId,
		Code:          out.Code,
		Status:        int(out.Status),
	}, nil
}

// Passports is the resolver for the passports field.
func (r *queryResolver) Passports(ctx context.Context, first *int, after *string, last *int, before *string, eventID string, code *string) (*model.PassportConnection, error) {
	afterCursor, err := DecodedCursor(after)
	if err != nil {
		return nil, err
	}

	beforeCursor, err := DecodedCursor(before)
	if err != nil {
		return nil, err
	}

	edges := make([]*model.PassportEdge, *first)
	count := 0
	currentPage := false

	if afterCursor == "" && beforeCursor == "" {
		currentPage = true
	}

	startCursor := ""
	endCursor := ""
	hasPreviousPage := false
	hasNextPage := false

	in := &ePB.PassportRequest{EventId: eventID}
	if code != nil {
		in.Code = *code
	}
	out, err := r.eventService.GetPassports(ctx, in)
	if err != nil {
		return nil, err
	}
	results := out.Data

	if afterCursor == "" && len(beforeCursor) > 0 {
		for i, v := range results {
			if v.Id == beforeCursor {
				currentPage = true
			}
			if currentPage && *last > 0 {
				m, n := i-*last, i
				if m < 0 {
					m = 0
				}
				for _, v := range results[m:n] {
					edges[count] = &model.PassportEdge{
						Cursor: EncodeToCursor(v.Id),
						Node:   r.NewPassport(v),
					}
					count++
				}

				hasPreviousPage = i-count > 0
				hasNextPage = i < len(results)-1
				break
			}
		}
	} else {
		for i, v := range results {
			if currentPage && count < *first {
				edges[count] = &model.PassportEdge{
					Cursor: EncodeToCursor(v.Id),
					Node:   r.NewPassport(v),
				}
				count++
			}

			if v.Id == afterCursor {
				currentPage = true
			}

			if hasPreviousPage == false {
				hasPreviousPage = i-count >= 0
			}

			if count == *first {
				hasNextPage = i < len(results)-1
				break
			}
		}
	}

	if count > 0 {
		startCursor = EncodeToCursor(edges[0].Node.ID)
		endCursor = EncodeToCursor(edges[count-1].Node.ID)
	}

	conn := model.PassportConnection{
		TotalCount: len(results),
		Edges:      edges[:count],
		PageInfo: &model.PageInfo{
			StartCursor:     startCursor,
			EndCursor:       endCursor,
			HasPreviousPage: &hasPreviousPage,
			HasNextPage:     &hasNextPage,
		},
	}

	return &conn, nil
}

// PassportSearch is the resolver for the passportSearch field.
func (r *queryResolver) PassportSearch(ctx context.Context, input model.PassportSearchInput) ([]*model.PassportSearchResult, error) {
	in := &ePB.SearchPassportRequest{Search: string(input.Search), Value: input.Value, Limit: 20}
	out, err := r.eventService.SearchPassports(ctx, in)
	if err != nil {
		return nil, err
	}

	events := make(map[string]*model.Event)
	event := func(id string) *model.Event {
		if v, ok := events[id]; ok {
			return v
		}
		if out, err := r.eventService.GetEvent(ctx, &ePB.EsKeyword{Value: id}); err == nil {
			v := r.NewEvent(out)
			events[out.Id] = v
			return v
		}
		return &model.Event{}
	}

	result := make([]*model.PassportSearchResult, len(out.Data))
	for i, v := range out.Data {
		result[i] = &model.PassportSearchResult{
			ID:            v.Id,
			Code:          v.Code,
			Event:         event(v.EventId),
			Name:          &v.RealName,
			Nric:          &v.Nric,
			Phone:         &v.Phone,
			GuardianName:  &v.GuardianName,
			GuardianNric:  &v.GuardianNric,
			GuardianPhone: &v.GuardianPhone,
		}
	}
	return result, nil
}

// UserPassport is the resolver for the userPassport field.
func (r *queryResolver) UserPassport(ctx context.Context, id string) (*model.UserPassport, error) {
	ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()

	res, err := r.eventService.GetUserPassport(ctx, &ePB.UserPassport{Id: id})
	if err != nil {
		return nil, err
	}

	return &model.UserPassport{
		UserID:         res.UserId,
		EventID:        res.EventId,
		PassportCode:   &res.PassportCode,
		RealName:       &res.RealName,
		Nric:           &res.Nric,
		Phone:          &res.Phone,
		Gender:         &res.Gender,
		Profession:     &res.Profession,
		ClaimCode:      &res.ClaimCode,
		Authentication: &res.Authentication,
		GuardianName:   &res.GuardianName,
		GuardianNric:   &res.GuardianNric,
		GuardianPhone:  &res.GuardianPhone,
		ClaimTime:      int(res.ClaimTime),
		Status:         int(res.Status),
	}, nil
}

// UserPassportByPassportID is the resolver for the userPassportByPassportID field.
func (r *queryResolver) UserPassportByPassportCode(ctx context.Context, passportCode string) (*model.UserPassport, error) {
	ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()

	req := ePB.EsKeyword{
		Value: passportCode,
	}

	res, err := r.eventService.GetUserPassportByPassportID(ctx, &req)

	if err != nil {
		return nil, err
	}

	return &model.UserPassport{
		ID:             res.Id,
		UserID:         res.UserId,
		EventID:        res.EventId,
		PassportCode:   &res.PassportCode,
		RealName:       &res.RealName,
		Nric:           &res.Nric,
		Phone:          &res.Phone,
		Gender:         &res.Gender,
		Profession:     &res.Profession,
		ClaimCode:      &res.ClaimCode,
		Authentication: &res.Authentication,
		GuardianName:   &res.GuardianName,
		GuardianNric:   &res.GuardianNric,
		GuardianPhone:  &res.GuardianPhone,
		ClaimTime:      int(res.ClaimTime),
		Status:         int(res.Status),
	}, nil
}

// UserPassportByUserID is the resolver for the userPassportByUserID field.
func (r *queryResolver) UserPassportByUserID(ctx context.Context, userID string) ([]*model.UserPassport, error) {
	ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()

	req := ePB.EsKeyword{
		Value: userID,
	}

	res, err := r.eventService.GetUserPassportByUserID(ctx, &req)

	if err != nil {
		return nil, err
	}

	results := make([]*model.UserPassport, 0)
	for _, s := range res.Data {
		results = append(results, &model.UserPassport{
			ID:             s.Id,
			UserID:         s.UserId,
			EventID:        s.EventId,
			PassportCode:   &s.PassportCode,
			RealName:       &s.RealName,
			Nric:           &s.Nric,
			Phone:          &s.Phone,
			Gender:         &s.Gender,
			Profession:     &s.Profession,
			ClaimCode:      &s.ClaimCode,
			Authentication: &s.Authentication,
			GuardianName:   &s.GuardianName,
			GuardianNric:   &s.GuardianNric,
			GuardianPhone:  &s.GuardianPhone,
			ClaimTime:      int(s.ClaimTime),
			Status:         int(s.Status),
		})
	}

	return results, err
}

// UserPassportByGuardianName is the resolver for the userPassportByGuardianName field.
func (r *queryResolver) UserPassportByGuardianName(ctx context.Context, guardianName string) ([]*model.UserPassport, error) {
	ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()

	req := ePB.EsKeyword{
		Value: guardianName,
	}

	res, err := r.eventService.GetUserPassportByGuardianName(ctx, &req)

	if err != nil {
		return nil, err
	}

	results := make([]*model.UserPassport, 0)
	for _, s := range res.Data {
		results = append(results, &model.UserPassport{
			ID:             s.Id,
			UserID:         s.UserId,
			EventID:        s.EventId,
			PassportCode:   &s.PassportCode,
			RealName:       &s.RealName,
			Nric:           &s.Nric,
			Phone:          &s.Phone,
			Gender:         &s.Gender,
			Profession:     &s.Profession,
			ClaimCode:      &s.ClaimCode,
			Authentication: &s.Authentication,
			GuardianName:   &s.GuardianName,
			GuardianNric:   &s.GuardianNric,
			GuardianPhone:  &s.GuardianPhone,
			ClaimTime:      int(s.ClaimTime),
			Status:         int(s.Status),
		})
	}

	return results, err
}

// PickupCodeInfo is the resolver for the pickupCodeInfo field.
func (r *queryResolver) PickupCodeInfo(ctx context.Context, id string) (*model.PickupCodeRes, error) {
	ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()

	req := ePB.EsKeyword{
		Value: id,
	}

	res, err := r.eventService.GetPickupCodeInfo(ctx, &req)

	if err != nil {
		return nil, err
	}

	return &model.PickupCodeRes{
		UserID:         res.UserId,
		RealName:       res.RealName,
		Nric:           res.Nric,
		Phone:          res.Phone,
		Authentication: res.Authentication,
		Status:         int(res.Status),
	}, nil
}

// Camp is the resolver for the camp field.
func (r *queryResolver) Camp(ctx context.Context, id string) (*model.Camp, error) {
	ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()

	req := ePB.EsKeyword{
		Value: id,
	}

	res, err := r.eventService.GetCamp(ctx, &req)

	if err != nil {
		return nil, err
	}

	return &model.Camp{
		ID:           res.Id,
		EventID:      res.EventId,
		Name:         res.Name,
		Introduction: &res.Introduction,
		Images:       &res.Images,
		Points:       int(res.Points),
		Status:       int(res.Status),
		CategoryID:   &res.CategoryId,
	}, nil
}

// Camps is the resolver for the camps field.
func (r *queryResolver) Camps(ctx context.Context, eventID string) ([]*model.Camp, error) {
	ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()

	req := ePB.EsKeyword{
		Value: eventID,
	}

	res, err := r.eventService.GetCampByEventID(ctx, &req)

	if err != nil {
		return nil, err
	}

	results := make([]*model.Camp, 0)
	for _, s := range res.Data {
		results = append(results, &model.Camp{
			ID:           s.Id,
			EventID:      s.EventId,
			Name:         s.Name,
			Introduction: &s.Introduction,
			Images:       &s.Images,
			Points:       int(s.Points),
			Status:       int(s.Status),
			CategoryID:   &s.CategoryId,
		})
	}

	return results, err
}

// Honour is the resolver for the honour field.
func (r *queryResolver) Honour(ctx context.Context, id string) (*model.Honour, error) {
	ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()

	srv := r.eventService

	out, err := srv.GetHonour(ctx, &ePB.EsKeyword{Value: id})
	if err != nil {
		return nil, err
	}
	if out == nil {
		return nil, nil
	}

	camp, err := srv.GetCamp(ctx, &ePB.EsKeyword{Value: out.CampId})
	if err != nil {
		return nil, err
	}
	if camp == nil {
		return nil, nil
	}

	return &model.Honour{
		ID:        out.Id,
		CampID:    camp.Id,
		CampName:  camp.Name,
		Name:      out.Name,
		Images:    &out.Images,
		MinPoints: int(out.MinPoints),
		MaxPoints: int(out.MaxPoints),
		Status:    int(out.Status),
	}, nil
}

// Honours is the resolver for the honours field.
func (r *queryResolver) Honours(ctx context.Context, campID string) ([]*model.Honour, error) {
	ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()

	srv := r.eventService

	camp, err := srv.GetCamp(ctx, &ePB.EsKeyword{Value: campID})
	if err != nil {
		return nil, err
	}
	if camp == nil {
		return []*model.Honour{}, nil
	}

	res, err := srv.GetHonourByCampID(ctx, &ePB.EsKeyword{Value: campID})
	if err != nil {
		return nil, err
	}

	results := make([]*model.Honour, 0)
	for _, s := range res.Data {
		results = append(results, &model.Honour{
			ID:        s.Id,
			CampID:    s.CampId,
			CampName:  camp.Name,
			Name:      s.Name,
			Images:    &s.Images,
			MinPoints: int(s.MinPoints),
			MaxPoints: int(s.MaxPoints),
			Status:    int(s.Status),
		})
	}

	return results, err
}

// EventHonours is the resolver for the eventHonours field.
func (r *queryResolver) EventHonours(ctx context.Context, eventID string) ([]*model.Honour, error) {
	ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()

	srv := r.eventService
	camps, err := srv.GetCampByEventID(ctx, &ePB.EsKeyword{Value: eventID})
	if err != nil {
		return nil, err
	}
	result := []*model.Honour{}
	for _, camp := range camps.Data {
		if honours, err := r.eventService.GetHonourByCampID(ctx, &ePB.EsKeyword{Value: camp.Id}); err == nil {
			for _, v := range honours.Data {
				result = append(result, &model.Honour{
					ID:        v.Id,
					CampID:    v.CampId,
					CampName:  camp.Name,
					Name:      v.Name,
					Images:    &v.Images,
					MinPoints: int(v.MinPoints),
					MaxPoints: int(v.MaxPoints),
					Status:    int(v.Status),
				})
			}
		}
	}

	return result, nil
}

// UserCamp is the resolver for the userCamp field.
func (r *queryResolver) UserCamp(ctx context.Context, id string) (*model.UserCamp, error) {
	ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()

	req := ePB.EsKeyword{
		Value: id,
	}

	res, err := r.eventService.GetUserCamp(ctx, &req)

	if err != nil {
		return nil, err
	}

	return &model.UserCamp{
		ID:         res.Id,
		UserID:     res.UserId,
		CampID:     res.CampId,
		Honour:     &res.Honour,
		Points:     int(res.Points),
		Status:     int(res.Status),
		CreateTime: int(res.CreateTime),
	}, nil
}

// UserCamps is the resolver for the userCamps field.
func (r *queryResolver) UserCamps(ctx context.Context, campID string) ([]*model.UserCamp, error) {
	ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()

	req := ePB.EsKeyword{
		Value: campID,
	}

	res, err := r.eventService.GetUserCampByCampID(ctx, &req)

	if err != nil {
		return nil, err
	}

	results := make([]*model.UserCamp, 0)
	for _, s := range res.Data {
		results = append(results, &model.UserCamp{
			ID:         s.Id,
			UserID:     s.UserId,
			CampID:     s.CampId,
			Honour:     &s.Honour,
			Points:     int(s.Points),
			Status:     int(s.Status),
			CreateTime: int(s.CreateTime),
		})
	}

	return results, err
}

// Notification is the resolver for the notification field.
func (r *queryResolver) Notification(ctx context.Context, id string) (*model.Notification, error) {
	ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()

	req := msgPB.MsgsKeyword{
		Value: id,
	}

	res, err := r.messageService.GetNotification(ctx, &req)

	if err != nil {
		return nil, err
	}

	return &model.Notification{
		ID:           res.Id,
		Name:         res.Name,
		CategoryID:   res.CategoryId,
		Content:      res.Content,
		Sender:       res.Sender,
		ReleaseTime:  int(res.ReleaseTime),
		BlockingTime: int(res.BlockingTime),
		CreateTime:   int(res.CreateTime),
	}, err
}

// Notifications is the resolver for the notifications field.
func (r *queryResolver) Notifications(ctx context.Context) ([]*model.Notification, error) {
	ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()

	req := msgPB.MsgsEmptyReq{}

	res, err := r.messageService.GetNotifications(ctx, &req)

	if err != nil {
		return nil, err
	}

	results := make([]*model.Notification, 0)
	for _, s := range res.Data {
		results = append(results, &model.Notification{
			ID:           s.Id,
			Name:         s.Name,
			CategoryID:   s.CategoryId,
			Content:      s.Content,
			Sender:       s.Sender,
			ReleaseTime:  int(s.ReleaseTime),
			BlockingTime: int(s.BlockingTime),
			CreateTime:   int(s.CreateTime),
		})
	}

	return results, err
}

// UserNotifications is the resolver for the userNotifications field.
func (r *queryResolver) UserNotifications(ctx context.Context, userID string) ([]*model.UserNotification, error) {
	ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()

	req := msgPB.MsgsKeyword{
		Value: userID,
	}

	res, err := r.messageService.GetUserNotifications(ctx, &req)

	if err != nil {
		return nil, err
	}

	results := make([]*model.UserNotification, 0)
	for _, s := range res.Data {
		results = append(results, &model.UserNotification{
			UserID:         s.UserId,
			NotificationID: s.NotificationId,
			Status:         int(s.Status),
		})
	}

	return results, err
}

// Conversation is the resolver for the conversation field.
func (r *queryResolver) Conversation(ctx context.Context, id string) (*model.Conversation, error) {
	ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()

	curr := auth.ForContext(ctx).User

	out, err := r.messageService.GetConversation(ctx, &msgPB.MsgsKeyword{Value: id})
	if err != nil {
		return nil, err
	}

	result := model.Conversation{
		ID:          out.Id,
		Participant: out.Participant,
		From:        out.From,
		UserID:      out.From,
		Content:     out.Content,
		SendTime:    int(out.SendTime),
		ReadTime:    int(out.ReadTime),
		HasNew:      out.To == curr.Id && out.ReadTime == 0,
	}
	if out.From == curr.Id {
		result.From = out.To
		result.ReadTime = int(out.SendTime)
	}

	if len(result.From) == 0 {
		result.UserName = ""
	} else {
		if acc, err := r.accountService.GetAccount(ctx, &aPB.AsKeyword{Value: result.UserID}); err == nil {
			if IsAdmin(acc) {
				result.UserName = ""
			} else {
				result.UserName = acc.WechatName
				result.UserAvatar = acc.WechatAvatar
			}
		}
	}

	return &result, err
}

// ConversationByParticipant is the resolver for the conversationByParticipant field.
func (r *queryResolver) ConversationByParticipant(ctx context.Context, participant string, from *string) ([]*model.Conversation, error) {
	ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()

	curr := auth.ForContext(ctx).User
	userId := curr.Id
	isSystem := participant == string(MessageFromSystem) ||
		participant == string(MessageFromCustomerService) ||
		participant == string(MessageFromReward)
	if ((isSystem && IsAdmin(curr)) || !isSystem) && from != nil {
		userId = *from
	}

	out, err := r.messageService.GetParticipantConversations(
		ctx,
		&msgPB.ParticipantConversationRequest{Participant: participant, From: userId, UserId: curr.Id},
	)
	if err != nil {
		return nil, err
	}

	result := []*model.Conversation{}
	for _, v := range out.Data {
		uc := &model.Conversation{
			ID:          v.Id,
			Participant: v.Participant,
			From:        v.From,
			UserID:      v.From,
			Content:     v.Content,
			SendTime:    int(v.SendTime),
			ReadTime:    int(v.ReadTime),
			HasNew:      v.To == curr.Id && v.ReadTime == 0,
		}
		if v.From == curr.Id {
			uc.From = v.To
			uc.ReadTime = int(v.SendTime)
		}

		if uc.Participant == string(MessageFromSystem) {
			uc.UserName = ""
		} else if uc.Participant == string(MessageFromReward) {
			uc.UserName = ""
		} else {
			if acc, err := r.accountService.GetAccount(ctx, &aPB.AsKeyword{Value: uc.UserID}); err == nil {
				if IsAdmin(acc) {
					uc.UserName = ""
					if IsAdmin(curr) {
						uc.UserName += fmt.Sprintf("(%s)", acc.LoginId)
					}
				} else {
					uc.UserName = acc.WechatName
					uc.UserAvatar = acc.WechatAvatar
				}
			}
		}

		result = append(result, uc)
	}

	if _, err := r.messageService.ClearUserUnreadMessage(
		ctx,
		&msgPB.ClearUserUnreadMessageReq{UserId: curr.Id, Type: ""},
	); err != nil {
		log.Println(err)
	}

	return result, err
}

// UserConversations is the resolver for the userConversations field.
func (r *queryResolver) UserConversations(ctx context.Context, userID string) ([]*model.Conversation, error) {
	curr := auth.ForContext(ctx).User

	if IsAdmin(curr) {
		out, err := r.messageService.GetServiceConversations(ctx, &msgPB.UserConversationRequest{UserId: userID})
		if err != nil {
			return nil, err
		}

		result := []*model.Conversation{}
		for _, v := range out.Data {
			if len(v.From) > 0 && len(v.To) > 0 {
				from, _ := r.accountService.GetAccount(ctx, &aPB.AsKeyword{Value: v.From})
				to, _ := r.accountService.GetAccount(ctx, &aPB.AsKeyword{Value: v.To})
				readTime := int(v.ReadTime)
				if v.From == curr.Id {
					readTime = int(v.SendTime)
				}
				uc := &model.Conversation{
					ID:          v.Id,
					Participant: v.Participant,
					Content:     v.Content,
					SendTime:    int(v.SendTime),
					ReadTime:    readTime,
					HasNew:      v.To == userID && v.ReadTime == 0,
				}
				if !IsAdmin(from) {
					uc.From = from.Id
					uc.UserID = from.Id
					uc.UserName = from.WechatName
					uc.UserAvatar = from.WechatAvatar
				} else {
					uc.Content += fmt.Sprintf(" - (%s)", from.LoginId)
				}

				if !IsAdmin(to) {
					uc.From = to.Id
					uc.UserID = to.Id
					uc.UserName = to.WechatName
					uc.UserAvatar = to.WechatAvatar
				}

				result = append(result, uc)
			}
		}

		return result, nil
	}

	out, err := r.messageService.GetUserConversations(ctx, &msgPB.UserConversationRequest{UserId: curr.Id})
	if err != nil {
		return nil, err
	}

	result := make([]*model.Conversation, len(out.Data))
	for i, v := range out.Data {
		uc := &model.Conversation{
			ID:          v.Id,
			Participant: v.Participant,
			From:        v.From,
			UserID:      v.From,
			Content:     v.Content,
			SendTime:    int(v.SendTime),
			ReadTime:    int(v.ReadTime),
			HasNew:      v.To == curr.Id && v.ReadTime == 0,
		}
		if v.From == curr.Id {
			uc.From = v.To
			uc.ReadTime = int(v.SendTime)
		}

		if uc.Participant == string(MessageFromSystem) {
			uc.UserName = ""
		} else if uc.Participant == string(MessageFromReward) {
			uc.UserName = ""
		} else {
			if acc, err := r.accountService.GetAccount(ctx, &aPB.AsKeyword{Value: uc.UserID}); err == nil {
				if IsAdmin(acc) {
					uc.UserName = ""
				} else {
					uc.UserName = acc.WechatName
					uc.UserAvatar = acc.WechatAvatar
				}
			}
		}

		result[i] = uc
	}

	return result, nil
}

// UserUnreadMessage is the resolver for the userUnreadMessage field.
func (r *queryResolver) UserUnreadMessage(ctx context.Context, userID string) (*model.UserUnreadMessage, error) {
	ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()

	res, err := r.messageService.GetUserUnreadMessage(ctx, &msgPB.MsgsKeyword{Value: userID})
	if err != nil {
		return nil, err
	}

	return &model.UserUnreadMessage{
		UserID:          res.UserId,
		Notification:    int(res.Notification),
		Conversation:    int(res.Conversation),
		Followers:       int(res.Followers),
		Like:            int(res.Like),
		System:          int(res.System),
		CustomerService: int(res.CustomerService),
		Reward:          int(res.Reward),
		Badge:           int(res.Badge),
	}, err
}

// UserLikeRecords is the resolver for the userLikeRecords field.
func (r *queryResolver) UserLikedRecords(ctx context.Context, userID string) ([]*model.UserLikeRecord, error) {
	ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()

	req := msgPB.MsgsKeyword{
		Value: userID,
	}

	res, err := r.messageService.GetUserLikedRecord(ctx, &req)

	if err != nil {
		return nil, err
	}

	results := make([]*model.UserLikeRecord, 0)
	for _, s := range res.Data {
		a, _ := r.accountService.GetAccount(ctx, &aPB.AsKeyword{
			Value: s.Liker,
		})

		results = append(results, &model.UserLikeRecord{
			ID:         s.Id,
			UserID:     s.UserId,
			Liker:      s.Liker,
			LikerName:  &a.WechatName,
			LikeAvatar: &a.WechatAvatar,
			LikeTweet:  s.LikeTweet,
			LikeTime:   int(s.LikeTime),
		})
	}

	return results, err
}

// UserLikesRecords is the resolver for the userLikesRecords field.
func (r *queryResolver) UserLikesRecords(ctx context.Context, userID string) ([]*model.UserLikeRecord, error) {
	ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()

	req := msgPB.MsgsKeyword{
		Value: userID,
	}

	res, err := r.messageService.GetUserLikesRecord(ctx, &req)

	if err != nil {
		return nil, err
	}

	results := make([]*model.UserLikeRecord, 0)
	for _, s := range res.Data {
		a, _ := r.accountService.GetAccount(ctx, &aPB.AsKeyword{
			Value: s.UserId,
		})

		results = append(results, &model.UserLikeRecord{
			ID:         s.Id,
			UserID:     s.UserId,
			Liker:      s.Liker,
			LikerName:  &a.WechatName,
			LikeAvatar: &a.WechatAvatar,
			LikeTweet:  s.LikeTweet,
			LikeTime:   int(s.LikeTime),
		})
	}

	return results, err
}

// Trek is the resolver for the trek field.
func (r *queryResolver) Trek(ctx context.Context, id string) (*model.Trek, error) {
	ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()

	req := tPB.TsKeyword{
		Value: id,
	}

	res, err := r.taskService.GetTrek(ctx, &req)

	if err != nil {
		return nil, err
	}

	return &model.Trek{
		ID:            res.Id,
		SceneryspotID: res.SceneryspotId,
		Name:          res.Name,
		Step:          int(res.Step),
		Points:        int(res.Points),
		Images:        res.Images,
		Introduction:  &res.Introduction,
		StartTime:     int(res.StartTime),
		EndTime:       int(res.EndTime),
		Necessary:     res.Necessary,
		Status:        int(res.Status),
		CreateTime:    int(res.CreateTime),
	}, err
}

// Treks is the resolver for the treks field.
func (r *queryResolver) Treks(ctx context.Context, sceneryspotID string, eventID *string) ([]*model.Trek, error) {
	ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()

	in := tPB.TaskRequest{
		Sceneryspots: []string{sceneryspotID},
		Necessary:    len(sceneryspotID) > 0,
	}
	if eventID != nil {
		in.EventId = *eventID
	}
	out, err := r.taskService.GetTreks(ctx, &in)
	if err != nil {
		return nil, err
	}

	results := make([]*model.Trek, 0)
	for _, s := range out.Data {
		results = append(results, &model.Trek{
			ID:            s.Id,
			SceneryspotID: s.SceneryspotId,
			Name:          s.Name,
			Step:          int(s.Step),
			Points:        int(s.Points),
			Images:        s.Images,
			Introduction:  &s.Introduction,
			StartTime:     int(s.StartTime),
			EndTime:       int(s.EndTime),
			Necessary:     s.Necessary,
			Status:        int(s.Status),
			CreateTime:    int(s.CreateTime),
			ElectricFence: &s.ElectricFence,
		})
	}

	return results, err
}

// Geocaching is the resolver for the geocaching field.
func (r *queryResolver) Geocaching(ctx context.Context, id string) (*model.Geocaching, error) {
	ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()

	req := tPB.TsKeyword{
		Value: id,
	}

	res, err := r.taskService.GetGeocaching(ctx, &req)

	if err != nil {
		return nil, err
	}

	return &model.Geocaching{
		ID:            res.Id,
		SceneryspotID: res.SceneryspotId,
		Name:          res.Name,
		Points:        int(res.Points),
		Images:        res.Images,
		Introduction:  &res.Introduction,
		StartTime:     int(res.StartTime),
		EndTime:       int(res.EndTime),
		Necessary:     res.Necessary,
		Status:        int(res.Status),
		CreateTime:    int(res.CreateTime),
		ElectricFence: &res.ElectricFence,
	}, err
}

// Geocachings is the resolver for the geocachings field.
func (r *queryResolver) Geocachings(ctx context.Context, sceneryspotID string, eventID *string) ([]*model.Geocaching, error) {
	ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()

	in := tPB.TaskRequest{
		Sceneryspots: []string{sceneryspotID},
		Necessary:    len(sceneryspotID) > 0,
	}
	if eventID != nil {
		in.EventId = *eventID
	}
	out, err := r.taskService.GetGeocachings(ctx, &in)
	if err != nil {
		return nil, err
	}

	results := make([]*model.Geocaching, 0)
	for _, s := range out.Data {
		results = append(results, &model.Geocaching{
			ID:            s.Id,
			SceneryspotID: s.SceneryspotId,
			Name:          s.Name,
			Points:        int(s.Points),
			Images:        s.Images,
			Introduction:  &s.Introduction,
			StartTime:     int(s.StartTime),
			EndTime:       int(s.EndTime),
			Necessary:     s.Necessary,
			Status:        int(s.Status),
			CreateTime:    int(s.CreateTime),
			ElectricFence: &s.ElectricFence,
		})
	}

	return results, err
}

// Screenshot is the resolver for the screenshot field.
func (r *queryResolver) Screenshot(ctx context.Context, id string) (*model.Screenshot, error) {
	ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()

	req := tPB.TsKeyword{
		Value: id,
	}

	res, err := r.taskService.GetScreenshot(ctx, &req)

	if err != nil {
		return nil, err
	}

	return &model.Screenshot{
		ID:            res.Id,
		SceneryspotID: res.SceneryspotId,
		Name:          res.Name,
		Points:        int(res.Points),
		Images:        res.Images,
		Introduction:  &res.Introduction,
		StartTime:     int(res.StartTime),
		EndTime:       int(res.EndTime),
		Necessary:     res.Necessary,
		Status:        int(res.Status),
		CreateTime:    int(res.CreateTime),
		ElectricFence: &res.ElectricFence,
	}, err
}

// Screenshots is the resolver for the screenshots field.
func (r *queryResolver) Screenshots(ctx context.Context, sceneryspotID string, eventID *string) ([]*model.Screenshot, error) {
	ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()

	in := tPB.TaskRequest{
		Sceneryspots: []string{sceneryspotID},
		Necessary:    len(sceneryspotID) > 0,
	}
	if eventID != nil {
		in.EventId = *eventID
	}
	out, err := r.taskService.GetScreenshots(ctx, &in)
	if err != nil {
		return nil, err
	}

	results := make([]*model.Screenshot, 0)
	for _, s := range out.Data {
		results = append(results, &model.Screenshot{
			ID:            s.Id,
			SceneryspotID: s.SceneryspotId,
			Name:          s.Name,
			Points:        int(s.Points),
			Images:        s.Images,
			Introduction:  &s.Introduction,
			StartTime:     int(s.StartTime),
			EndTime:       int(s.EndTime),
			Necessary:     s.Necessary,
			Status:        int(s.Status),
			CreateTime:    int(s.CreateTime),
			ElectricFence: &s.ElectricFence,
		})
	}

	return results, err
}

// Puzzle is the resolver for the puzzle field.
func (r *queryResolver) Puzzle(ctx context.Context, id string) (*model.Puzzle, error) {
	ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()

	req := tPB.TsKeyword{
		Value: id,
	}

	res, err := r.taskService.GetPuzzle(ctx, &req)

	if err != nil {
		return nil, err
	}

	return &model.Puzzle{
		ID:            res.Id,
		SceneryspotID: res.SceneryspotId,
		Name:          res.Name,
		Points:        int(res.Points),
		Images:        res.Images,
		Introduction:  &res.Introduction,
		StartTime:     int(res.StartTime),
		EndTime:       int(res.EndTime),
		Necessary:     res.Necessary,
		Status:        int(res.Status),
		CreateTime:    int(res.CreateTime),
		ElectricFence: &res.ElectricFence,
	}, err
}

// Puzzles is the resolver for the puzzles field.
func (r *queryResolver) Puzzles(ctx context.Context, sceneryspotID string, eventID *string) ([]*model.Puzzle, error) {
	ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()

	in := tPB.TaskRequest{
		Sceneryspots: []string{sceneryspotID},
		Necessary:    len(sceneryspotID) > 0,
	}
	if eventID != nil {
		in.EventId = *eventID
	}
	out, err := r.taskService.GetPuzzles(ctx, &in)
	if err != nil {
		return nil, err
	}

	results := make([]*model.Puzzle, 0)
	for _, s := range out.Data {
		results = append(results, &model.Puzzle{
			ID:            s.Id,
			SceneryspotID: s.SceneryspotId,
			Name:          s.Name,
			Points:        int(s.Points),
			Images:        s.Images,
			Introduction:  &s.Introduction,
			StartTime:     int(s.StartTime),
			EndTime:       int(s.EndTime),
			Necessary:     s.Necessary,
			Status:        int(s.Status),
			Countdown:     int(s.Countdown),
			CreateTime:    int(s.CreateTime),
			ElectricFence: &s.ElectricFence,
		})
	}

	return results, err
}

// QuestionBank is the resolver for the questionBank field.
func (r *queryResolver) QuestionBank(ctx context.Context, id string) (*model.QuestionBank, error) {
	ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()

	req := tPB.TsKeyword{
		Value: id,
	}

	res, err := r.taskService.GetQuestionBank(ctx, &req)

	if err != nil {
		return nil, err
	}

	return &model.QuestionBank{
		ID:            res.Id,
		EventID:       &res.EventId,
		SceneryspotID: res.SceneryspotId,
		Question:      res.Question,
		Options:       res.Options,
		Answer:        res.Answer,
		StartTime:     int(res.StartTime),
		EndTime:       int(res.EndTime),
		Necessary:     res.Necessary,
		Points:        int(res.Points),
		Status:        int(res.Status),
		ElectricFence: &res.ElectricFence,
	}, err
}

// QuestionBanks is the resolver for the questionBanks field.
func (r *queryResolver) QuestionBanks(ctx context.Context, sceneryspotID string, eventID *string) ([]*model.QuestionBank, error) {
	ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()

	in := tPB.TaskRequest{
		Sceneryspots: []string{sceneryspotID},
		Necessary:    len(sceneryspotID) > 0,
	}
	if eventID != nil {
		in.EventId = *eventID
	}
	out, err := r.taskService.GetQuestions(ctx, &in)
	if err != nil {
		return nil, err
	}

	results := make([]*model.QuestionBank, 0)
	for _, s := range out.Data {
		results = append(results, &model.QuestionBank{
			ID:            s.Id,
			EventID:       &s.EventId,
			SceneryspotID: s.SceneryspotId,
			Question:      s.Question,
			Options:       s.Options,
			Answer:        s.Answer,
			StartTime:     int(s.StartTime),
			EndTime:       int(s.EndTime),
			Necessary:     s.Necessary,
			Points:        int(s.Points),
			Status:        int(s.Status),
			ElectricFence: &s.ElectricFence,
		})
	}

	return results, err
}

// Question is the resolver for the question field.
func (r *queryResolver) Question(ctx context.Context, id string) (*model.Question, error) {
	ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()

	req := tPB.TsKeyword{
		Value: id,
	}

	res, err := r.taskService.GetQuestion(ctx, &req)

	if err != nil {
		return nil, err
	}

	return &model.Question{
		ID:            res.Id,
		SceneryspotID: res.SceneryspotId,
		Questions:     res.Questions,
		StartTime:     int(res.StartTime),
		EndTime:       int(res.EndTime),
		Points:        int(res.Points),
		Status:        int(res.Status),
		CreateTime:    int(res.CreateTime),
		ElectricFence: &res.ElectricFence,
	}, err
}

// Questions is the resolver for the questions field.
func (r *queryResolver) Questions(ctx context.Context, sceneryspotID string, eventID *string) ([]*model.Question, error) {
	ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()

	in := tPB.TaskRequest{
		Sceneryspots: []string{sceneryspotID},
		Necessary:    len(sceneryspotID) > 0,
	}
	if eventID != nil {
		in.EventId = *eventID
	}
	out, err := r.taskService.GetQuestions(ctx, &in)
	if err != nil {
		return nil, err
	}

	results := make([]*model.Question, 0)
	for _, s := range out.Data {
		results = append(results, &model.Question{
			ID:            s.Id,
			SceneryspotID: s.SceneryspotId,
			Questions:     s.Question,
			StartTime:     int(s.StartTime),
			EndTime:       int(s.EndTime),
			Points:        int(s.Points),
			Status:        int(s.Status),
			CreateTime:    int(s.CreateTime),
			ElectricFence: &s.ElectricFence,
		})
	}

	return results, err
}

// UserTask is the resolver for the userTask field.
func (r *queryResolver) UserTask(ctx context.Context, id string) (*model.UserTask, error) {
	ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()

	req := tPB.TsKeyword{
		Value: id,
	}

	res, err := r.taskService.GetUserTask(ctx, &req)

	if err != nil {
		return nil, err
	}

	return r.NewUserTask(res), err
}

// UserTasks is the resolver for the userTasks field.
func (r *queryResolver) UserTasks(ctx context.Context, first *int, after *string, last *int, before *string, eventID string, sceneryspotID *string, categoryID *string) (*model.UserTaskConnection, error) {
	afterCursor, err := DecodedCursor(after)
	if err != nil {
		return nil, err
	}

	beforeCursor, err := DecodedCursor(before)
	if err != nil {
		return nil, err
	}

	edges := make([]*model.UserTaskEdge, *first)
	count := 0
	currentPage := false

	if afterCursor == "" && beforeCursor == "" {
		currentPage = true
	}

	startCursor := ""
	endCursor := ""
	hasPreviousPage := false
	hasNextPage := false

	in := &tPB.UserTaskRequest{EventId: eventID}
	if sceneryspotID != nil {
		in.Sceneryspots = []string{*sceneryspotID}
	}
	if categoryID != nil {
		in.CategoryId = *categoryID
	}
	out, err := r.taskService.GetUserTasks(ctx, in)
	if err != nil {
		return nil, err
	}
	results := out.Data

	if afterCursor == "" && len(beforeCursor) > 0 {
		for i, v := range results {
			if v.Id == beforeCursor {
				currentPage = true
			}
			if currentPage && *last > 0 {
				m, n := i-*last, i
				if m < 0 {
					m = 0
				}
				for _, v := range results[m:n] {
					edges[count] = &model.UserTaskEdge{
						Cursor: EncodeToCursor(v.Id),
						Node:   r.NewUserTask(v),
					}
					count++
				}

				hasPreviousPage = i-count > 0
				hasNextPage = i < len(results)-1
				break
			}
		}
	} else {
		for i, v := range results {
			if currentPage && count < *first {
				edges[count] = &model.UserTaskEdge{
					Cursor: EncodeToCursor(v.Id),
					Node:   r.NewUserTask(v),
				}
				count++
			}

			if v.Id == afterCursor {
				currentPage = true
			}

			if hasPreviousPage == false {
				hasPreviousPage = i-count >= 0
			}

			if count == *first {
				hasNextPage = i < len(results)-1
				break
			}
		}
	}

	if count > 0 {
		startCursor = EncodeToCursor(edges[0].Node.ID)
		endCursor = EncodeToCursor(edges[count-1].Node.ID)
	}

	conn := model.UserTaskConnection{
		TotalCount: len(results),
		Edges:      edges[:count],
		PageInfo: &model.PageInfo{
			StartCursor:     startCursor,
			EndCursor:       endCursor,
			HasPreviousPage: &hasPreviousPage,
			HasNextPage:     &hasNextPage,
		},
	}

	return &conn, nil
}

// UserTaskByUserID is the resolver for the userTaskByUserID field.
func (r *queryResolver) UserTaskByUserID(ctx context.Context, userID string) ([]*model.UserTask, error) {
	ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()

	req := tPB.TsKeyword{
		Value: userID,
	}

	res, err := r.taskService.GetUserTaskByUserID(ctx, &req)

	if err != nil {
		return nil, err
	}

	results := make([]*model.UserTask, 0)
	for _, s := range res.Data {
		results = append(results, &model.UserTask{
			ID:            s.Id,
			UserID:        s.UserId,
			EventID:       s.EventId,
			CampID:        s.CampId,
			SceneryspotID: s.SceneryspotId,
			TaskID:        s.TaskId,
			TaskCategory:  s.TaskCategory,
			Result:        s.Result,
			Points:        int(s.Points),
			Status:        int(s.Status),
			Audit:         &s.Audit,
			CreateTime:    int(s.CreateTime),
		})
	}

	return results, err
}

// UserTaskByTaskID is the resolver for the userTaskByTaskID field.
func (r *queryResolver) UserTaskByTaskID(ctx context.Context, taskID string) ([]*model.UserTask, error) {
	ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()

	req := tPB.TsKeyword{
		Value: taskID,
	}

	res, err := r.taskService.GetUserTaskByTaskID(ctx, &req)

	if err != nil {
		return nil, err
	}

	results := make([]*model.UserTask, 0)
	for _, s := range res.Data {
		results = append(results, &model.UserTask{
			ID:            s.Id,
			UserID:        s.UserId,
			EventID:       s.EventId,
			CampID:        s.CampId,
			SceneryspotID: s.SceneryspotId,
			TaskID:        s.TaskId,
			TaskCategory:  s.TaskCategory,
			Result:        s.Result,
			Points:        int(s.Points),
			Status:        int(s.Status),
			Audit:         &s.Audit,
			CreateTime:    int(s.CreateTime),
		})
	}

	return results, err
}

// EventPassport is the resolver for the eventPassport field.
func (r *queryResolver) EventPassport(ctx context.Context, eventID string, userID string, phone string) (*model.EventPassport, error) {
	in := &ePB.UserEventPassportRequest{
		EventID: eventID,
		UserID:  userID,
		Phone:   phone,
	}
	out, err := r.eventService.GetUserEventPassport(ctx, in)
	if err != nil {
		return nil, err
	}
	if out.Data == nil && len(out.Data) == 0 {
		return nil, nil
	}
	data := out.Data[0]

	return &model.EventPassport{
		ID:            data.Id,
		Code:          data.PassportCode,
		UserID:        &data.UserId,
		UserCampID:    &data.UserCampId,
		EventID:       data.EventId,
		Name:          data.RealName,
		Nric:          data.Nric,
		Phone:         data.Phone,
		Gender:        &data.Gender,
		Profession:    &data.Profession,
		ClaimCode:     &data.ClaimCode,
		ClaimBy:       &data.ClaimBy,
		ClaimTime:     int(data.ClaimTime),
		GuardianName:  &data.GuardianName,
		GuardianNric:  &data.GuardianNric,
		GuardianPhone: &data.GuardianPhone,
		Status:        int(data.Status),
	}, nil
}

// PassportStocks is the resolver for the passportStocks field.
func (r *queryResolver) PassportStocks(ctx context.Context) ([]*model.PassportStock, error) {
	out, err := r.eventService.GetPassportStocks(ctx, &ePB.PassportStocksRequest{})
	if err != nil {
		return nil, err
	}

	result := make([]*model.PassportStock, len(out.Data))
	for i, v := range out.Data {
		result[i] = &model.PassportStock{
			EventID:        v.EventID,
			EventName:      v.EventName,
			Total:          int(v.Total),
			IssuedCount:    int(v.IssuedCount),
			UsedCount:      int(v.UsedCount),
			AvailableCount: int(v.AvailableCount),
		}
	}
	return result, nil
}

// PassportStock is the resolver for the passportStock field.
func (r *queryResolver) PassportStock(ctx context.Context, eventID string) (*model.PassportStock, error) {
	return &model.PassportStock{
		EventID:        "23879c43-7d52-422e-8428-54c40afb9b64",
		EventName:      "",
		Total:          5000,
		IssuedCount:    637,
		UsedCount:      621,
		AvailableCount: 4363,
	}, nil
}

// IssuedUserPassports is the resolver for the issuedUserPassports field.
func (r *queryResolver) IssuedUserPassports(ctx context.Context, first *int, after *string, last *int, before *string, filter *model.UserPassportFilter) (*model.UserPassportConnection, error) {
	afterCursor, err := DecodedCursor(after)
	if err != nil {
		return nil, err
	}

	beforeCursor, err := DecodedCursor(before)
	if err != nil {
		return nil, err
	}

	edges := make([]*model.UserPassportEdge, *first)
	count := 0
	currentPage := false

	if afterCursor == "" && beforeCursor == "" {
		currentPage = true
	}

	startCursor := ""
	endCursor := ""
	hasPreviousPage := false
	hasNextPage := false

	in := &ePB.UserPassportRequest{}
	if filter != nil {
		if filter.Type == model.UserPassportFilterTypeName {
			in.Name = filter.Search
		}
		if filter.Type == model.UserPassportFilterTypeIdcard {
			in.Nric = filter.Search
		}
		if filter.Type == model.UserPassportFilterTypePhone {
			in.Phone = filter.Search
		}
	}
	out, err := r.eventService.GetIssuedUserPassports(ctx, in)
	if err != nil {
		return nil, err
	}
	results := out.Data

	if afterCursor == "" && len(beforeCursor) > 0 {
		for i, v := range results {
			if v.Id == beforeCursor {
				currentPage = true
			}
			if currentPage && *last > 0 {
				m, n := i-*last, i
				if m < 0 {
					m = 0
				}
				for _, v := range results[m:n] {
					edges[count] = &model.UserPassportEdge{
						Cursor: EncodeToCursor(v.Id),
						Node: &model.UserPassport{
							ID:             v.Id,
							UserID:         v.UserId,
							EventID:        v.EventId,
							PassportCode:   &v.PassportCode,
							RealName:       &v.RealName,
							Nric:           &v.Nric,
							Phone:          &v.Phone,
							Gender:         &v.Gender,
							Profession:     &v.PassportCode,
							ClaimCode:      &v.ClaimCode,
							Authentication: &v.Authentication,
							GuardianName:   &v.GuardianName,
							GuardianNric:   &v.GuardianNric,
							GuardianPhone:  &v.GuardianPhone,
							ClaimTime:      int(v.ClaimTime),
							Status:         int(v.Status),
							CreateTime:     int(v.CreateTime),
						},
					}
					count++
				}

				hasPreviousPage = i-count > 0
				hasNextPage = i < len(results)-1
				break
			}
		}
	} else {
		for i, v := range results {
			if currentPage && count < *first {
				edges[count] = &model.UserPassportEdge{
					Cursor: EncodeToCursor(v.Id),
					Node: &model.UserPassport{
						ID:             v.Id,
						UserID:         v.UserId,
						EventID:        v.EventId,
						PassportCode:   &v.PassportCode,
						RealName:       &v.RealName,
						Nric:           &v.Nric,
						Phone:          &v.Phone,
						Gender:         &v.Gender,
						Profession:     &v.PassportCode,
						ClaimCode:      &v.ClaimCode,
						Authentication: &v.Authentication,
						GuardianName:   &v.GuardianName,
						GuardianNric:   &v.GuardianNric,
						GuardianPhone:  &v.GuardianPhone,
						ClaimTime:      int(v.ClaimTime),
						Status:         int(v.Status),
						CreateTime:     int(v.CreateTime),
					},
				}
				count++
			}

			if v.Id == afterCursor {
				currentPage = true
			}

			if hasPreviousPage == false {
				hasPreviousPage = i-count >= 0
			}

			if count == *first {
				hasNextPage = i < len(results)-1
				break
			}
		}
	}

	if count > 0 {
		startCursor = EncodeToCursor(edges[0].Node.ID)
		endCursor = EncodeToCursor(edges[count-1].Node.ID)
	}

	conn := model.UserPassportConnection{
		TotalCount: len(results),
		Edges:      edges[:count],
		PageInfo: &model.PageInfo{
			StartCursor:     startCursor,
			EndCursor:       endCursor,
			HasPreviousPage: &hasPreviousPage,
			HasNextPage:     &hasNextPage,
		},
	}

	return &conn, nil
}

// UsedUserPassports is the resolver for the usedUserPassports field.
func (r *queryResolver) UsedUserPassports(ctx context.Context, first *int, after *string, last *int, before *string, filter *model.UserPassportFilter) (*model.UserPassportConnection, error) {
	afterCursor, err := DecodedCursor(after)
	if err != nil {
		return nil, err
	}

	beforeCursor, err := DecodedCursor(before)
	if err != nil {
		return nil, err
	}

	edges := make([]*model.UserPassportEdge, *first)
	count := 0
	currentPage := false

	if afterCursor == "" && beforeCursor == "" {
		currentPage = true
	}

	startCursor := ""
	endCursor := ""
	hasPreviousPage := false
	hasNextPage := false

	in := &ePB.UserPassportRequest{}
	if filter != nil {
		if filter.Type == model.UserPassportFilterTypeName {
			in.Name = filter.Search
		}
		if filter.Type == model.UserPassportFilterTypeIdcard {
			in.Nric = filter.Search
		}
		if filter.Type == model.UserPassportFilterTypePhone {
			in.Phone = filter.Search
		}
	}
	out, err := r.eventService.GetUsedUserPassports(ctx, in)
	if err != nil {
		return nil, err
	}
	results := out.Data

	logger.Info(results)

	if afterCursor == "" && len(beforeCursor) > 0 {
		for i, v := range results {
			if v.Id == beforeCursor {
				currentPage = true
			}
			if currentPage && *last > 0 {
				m, n := i-*last, i
				if m < 0 {
					m = 0
				}
				for _, v := range results[m:n] {
					edges[count] = &model.UserPassportEdge{
						Cursor: EncodeToCursor(v.Id),
						Node:   r.NewUserPassport(v),
					}
					count++
				}

				hasPreviousPage = i-count > 0
				hasNextPage = i < len(results)-1
				break
			}
		}
	} else {
		for i, v := range results {
			if currentPage && count < *first {
				edges[count] = &model.UserPassportEdge{
					Cursor: EncodeToCursor(v.Id),
					Node:   r.NewUserPassport(v),
				}
				count++
			}

			if v.Id == afterCursor {
				currentPage = true
			}

			if hasPreviousPage == false {
				hasPreviousPage = i-count >= 0
			}

			if count == *first {
				hasNextPage = i < len(results)-1
				break
			}
		}
	}

	if count > 0 {
		startCursor = EncodeToCursor(edges[0].Node.ID)
		endCursor = EncodeToCursor(edges[count-1].Node.ID)
	}

	conn := model.UserPassportConnection{
		TotalCount: len(results),
		Edges:      edges[:count],
		PageInfo: &model.PageInfo{
			StartCursor:     startCursor,
			EndCursor:       endCursor,
			HasPreviousPage: &hasPreviousPage,
			HasNextPage:     &hasNextPage,
		},
	}

	return &conn, nil
}

// InactiveUserPassports is the resolver for the inactiveUserPassports field.
func (r *queryResolver) InactiveUserPassports(ctx context.Context, first *int, after *string, last *int, before *string, filter *model.UserPassportFilter) (*model.UserPassportConnection, error) {
	afterCursor, err := DecodedCursor(after)
	if err != nil {
		return nil, err
	}

	beforeCursor, err := DecodedCursor(before)
	if err != nil {
		return nil, err
	}

	edges := make([]*model.UserPassportEdge, *first)
	count := 0
	currentPage := false

	if afterCursor == "" && beforeCursor == "" {
		currentPage = true
	}

	startCursor := ""
	endCursor := ""
	hasPreviousPage := false
	hasNextPage := false

	in := &ePB.UserPassportRequest{}
	if filter != nil {
		if filter.Type == model.UserPassportFilterTypeName {
			in.Name = filter.Search
		}
		if filter.Type == model.UserPassportFilterTypeIdcard {
			in.Nric = filter.Search
		}
		if filter.Type == model.UserPassportFilterTypePhone {
			in.Phone = filter.Search
		}
	}
	out, err := r.eventService.GetInactiveUserPassports(ctx, in)
	if err != nil {
		return nil, err
	}
	results := out.Data

	if afterCursor == "" && len(beforeCursor) > 0 {
		for i, v := range results {
			if v.Id == beforeCursor {
				currentPage = true
			}
			if currentPage && *last > 0 {
				m, n := i-*last, i
				if m < 0 {
					m = 0
				}
				for _, v := range results[m:n] {
					edges[count] = &model.UserPassportEdge{
						Cursor: EncodeToCursor(v.Id),
						Node:   r.NewUserPassport(v),
					}
					count++
				}

				hasPreviousPage = i-count > 0
				hasNextPage = i < len(results)-1
				break
			}
		}
	} else {
		for i, v := range results {
			if currentPage && count < *first {
				edges[count] = &model.UserPassportEdge{
					Cursor: EncodeToCursor(v.Id),
					Node:   r.NewUserPassport(v),
				}
				count++
			}

			if v.Id == afterCursor {
				currentPage = true
			}

			if hasPreviousPage == false {
				hasPreviousPage = i-count >= 0
			}

			if count == *first {
				hasNextPage = i < len(results)-1
				break
			}
		}
	}

	if count > 0 {
		startCursor = EncodeToCursor(edges[0].Node.ID)
		endCursor = EncodeToCursor(edges[count-1].Node.ID)
	}

	conn := model.UserPassportConnection{
		TotalCount: len(results),
		Edges:      edges[:count],
		PageInfo: &model.PageInfo{
			StartCursor:     startCursor,
			EndCursor:       endCursor,
			HasPreviousPage: &hasPreviousPage,
			HasNextPage:     &hasNextPage,
		},
	}

	return &conn, nil
}

// EventUsers is the resolver for the eventUsers field.
func (r *queryResolver) EventUsers(ctx context.Context, first *int, after *string, last *int, before *string, eventID string, camps []string, sceneryspots []string) (*model.EventUserConnection, error) {
	afterCursor, err := DecodedCursor(after)
	if err != nil {
		return nil, err
	}

	beforeCursor, err := DecodedCursor(before)
	if err != nil {
		return nil, err
	}

	edges := make([]*model.EventUserEdge, *first)
	count := 0
	currentPage := false

	if afterCursor == "" && beforeCursor == "" {
		currentPage = true
	}

	startCursor := ""
	endCursor := ""
	hasPreviousPage := false
	hasNextPage := false

	in := &ePB.EventUserRequest{
		EventId:      eventID,
		Camps:        camps,
		Sceneryppots: sceneryspots,
	}

	out, err := r.eventService.GetEventUsers(ctx, in)
	if err != nil {
		return nil, err
	}
	results := out.Data

	if afterCursor == "" && len(beforeCursor) > 0 {
		for i, v := range results {
			if v.Id == beforeCursor {
				currentPage = true
			}
			if currentPage && *last > 0 {
				m, n := i-*last, i
				if m < 0 {
					m = 0
				}
				for _, v := range results[m:n] {
					edges[count] = &model.EventUserEdge{
						Cursor: EncodeToCursor(v.Id),
						Node:   r.NewEventUser(v),
					}
					count++
				}

				hasPreviousPage = i-count > 0
				hasNextPage = i < len(results)-1
				break
			}
		}
	} else {
		for i, v := range results {
			if currentPage && count < *first {
				edges[count] = &model.EventUserEdge{
					Cursor: EncodeToCursor(v.Id),
					Node:   r.NewEventUser(v),
				}
				count++
			}

			if v.Id == afterCursor {
				currentPage = true
			}

			if hasPreviousPage == false {
				hasPreviousPage = i-count >= 0
			}

			if count == *first {
				hasNextPage = i < len(results)-1
				break
			}
		}
	}

	if count > 0 {
		startCursor = EncodeToCursor(edges[0].Node.ID)
		endCursor = EncodeToCursor(edges[count-1].Node.ID)
	}

	conn := model.EventUserConnection{
		TotalCount: len(results),
		Edges:      edges[:count],
		PageInfo: &model.PageInfo{
			StartCursor:     startCursor,
			EndCursor:       endCursor,
			HasPreviousPage: &hasPreviousPage,
			HasNextPage:     &hasNextPage,
		},
	}

	return &conn, nil
}

// EventTasks is the resolver for the eventTasks field.
func (r *queryResolver) EventTasks(ctx context.Context, first *int, after *string, last *int, before *string, eventID string, camps []string, sceneryspots []string) (*model.EventTaskConnection, error) {
	afterCursor, err := DecodedCursor(after)
	if err != nil {
		return nil, err
	}

	beforeCursor, err := DecodedCursor(before)
	if err != nil {
		return nil, err
	}

	edges := make([]*model.EventTaskEdge, *first)
	count := 0
	currentPage := false

	if afterCursor == "" && beforeCursor == "" {
		currentPage = true
	}

	startCursor := ""
	endCursor := ""
	hasPreviousPage := false
	hasNextPage := false

	in := &ePB.EventTaskRequest{
		EventId:      eventID,
		Camps:        camps,
		Sceneryppots: sceneryspots,
	}

	out, err := r.eventService.GetEventTasks(ctx, in)
	if err != nil {
		return nil, err
	}
	results := out.Data

	if afterCursor == "" && len(beforeCursor) > 0 {
		for i, v := range results {
			if v.Id == beforeCursor {
				currentPage = true
			}
			if currentPage && *last > 0 {
				m, n := i-*last, i
				if m < 0 {
					m = 0
				}
				for _, v := range results[m:n] {
					edges[count] = &model.EventTaskEdge{
						Cursor: EncodeToCursor(v.Id),
						Node:   model.NewEventTask(v),
					}
					count++
				}

				hasPreviousPage = i-count > 0
				hasNextPage = i < len(results)-1
				break
			}
		}
	} else {
		for i, v := range results {
			if currentPage && count < *first {
				edges[count] = &model.EventTaskEdge{
					Cursor: EncodeToCursor(v.Id),
					Node:   model.NewEventTask(v),
				}
				count++
			}

			if v.Id == afterCursor {
				currentPage = true
			}

			if hasPreviousPage == false {
				hasPreviousPage = i-count >= 0
			}

			if count == *first {
				hasNextPage = i < len(results)-1
				break
			}
		}
	}

	if count > 0 {
		startCursor = EncodeToCursor(edges[0].Node.ID)
		endCursor = EncodeToCursor(edges[count-1].Node.ID)
	}

	conn := model.EventTaskConnection{
		TotalCount: len(results),
		Edges:      edges[:count],
		PageInfo: &model.PageInfo{
			StartCursor:     startCursor,
			EndCursor:       endCursor,
			HasPreviousPage: &hasPreviousPage,
			HasNextPage:     &hasNextPage,
		},
	}

	return &conn, nil
}

// Tasks is the resolver for the tasks field.
func (r *queryResolver) Tasks(ctx context.Context, userID string, eventID string, campID string, sceneryspotID string) ([]model.Task, error) {
	ucs, err := r.eventService.GetUserCampByCampID(ctx, &ePB.EsKeyword{Value: campID})
	if err != nil {
		logger.Error(err)
		return nil, err
	}
	if ucs.Data == nil || len(ucs.Data) == 0 {
		return nil, errors.New("")
	}
	var uc *ePB.UserCamp
	for _, v := range ucs.Data {
		if v.EventId == eventID && v.UserId == userID {
			uc = v
			break
		}
	}
	if uc == nil {
		return nil, errors.New("")
	}

	camp, err := r.eventService.GetCamp(ctx, &ePB.EsKeyword{Value: campID})
	if err != nil {
		logger.Error(err)
		return nil, err
	}
	if camp == nil {
		return nil, errors.New("")
	}

	category, err := r.managementService.GetCategoryByID(ctx, &mPB.MsKeyword{Value: camp.CategoryId})
	if err != nil {
		logger.Error(err)
		return nil, err
	}
	if category == nil {
		return []model.Task{}, nil
	}

	var userTasks []*tPB.UserTask
	in := tPB.UserTaskRequest{
		UserId:       userID,
		EventId:      eventID,
		Sceneryspots: []string{sceneryspotID},
	}
	if out, err := r.taskService.GetUserTasks(ctx, &in); err == nil {
		userTasks = out.Data
	}

	completedTask := func(v string) *tPB.UserTask {
		for _, task := range userTasks {
			if v == task.TaskId {
				return task
			}
		}
		return nil
	}

	result := []model.Task{}
	if treks, err := r.getTreks(ctx, camp.CategoryId, sceneryspotID, completedTask); err == nil {
		result = append(result, treks...)
	}
	if questions, err := r.getQuestions(ctx, camp.CategoryId, sceneryspotID, userTasks); err == nil {
		result = append(result, questions...)
	}
	if geocachings, err := r.getGeocachings(ctx, camp.CategoryId, sceneryspotID, completedTask); err == nil {
		result = append(result, geocachings...)
	}
	if screenshots, err := r.getScreenshots(ctx, camp.CategoryId, sceneryspotID, completedTask); err == nil {
		result = append(result, screenshots...)
	}
	if puzzles, err := r.getPuzzles(ctx, camp.CategoryId, sceneryspotID, completedTask); err == nil {
		result = append(result, puzzles...)
	}

	return result, nil
}

// TemporaryTasks is the resolver for the temporaryTasks field.
func (r *queryResolver) TemporaryTasks(ctx context.Context, userID string, eventID string, campID string) ([]model.Task, error) {
	var userTasks []*tPB.UserTask
	if out, err := r.taskService.GetUserTasks(
		ctx,
		&tPB.UserTaskRequest{
			UserId:  userID,
			EventId: eventID,
		},
	); err == nil {
		userTasks = out.Data
	}

	in := tPB.TaskRequest{EventId: eventID, Necessary: false, Status: 1}
	completedTask := func(v string) *tPB.UserTask {
		for _, task := range userTasks {
			if v == task.TaskId {
				return task
			}
		}
		return nil
	}

	result := []model.Task{}
	if treks, err := r.getTrekTasks(ctx, "", &in, completedTask); err == nil {
		result = append(result, treks...)
	}
	if questions, err := r.getQuestionTasks(ctx, "", &in, userTasks); err == nil {
		result = append(result, questions...)
	}
	if geocachings, err := r.getGeocachingTasks(ctx, "", &in, completedTask); err == nil {
		result = append(result, geocachings...)
	}
	if screenshots, err := r.getScreenshotTasks(ctx, "", &in, completedTask); err == nil {
		result = append(result, screenshots...)
	}
	if puzzles, err := r.getPuzzleTasks(ctx, "", &in, completedTask); err == nil {
		result = append(result, puzzles...)
	}

	return result, nil
}

// Task is the resolver for the task field.
func (r *queryResolver) Task(ctx context.Context, id string, categoryID string, userID string, eventID string, campID *string, sceneryspotID *string) (model.Task, error) {
	optional := true
	if camp, err := r.getUserCamp(ctx, userID, eventID); err == nil && camp != nil {
		optional = categoryID != camp.CategoryId
	}

	category, err := r.managementService.GetCategoryByID(ctx, &mPB.MsKeyword{Value: categoryID})
	if err != nil {
		logger.Error(err)
		return nil, err
	}
	if category == nil {
		return nil, nil
	}

	var userTasks []*tPB.UserTask
	if sceneryspotID != nil {
		if out, err := r.taskService.GetUserTasks(
			ctx,
			&tPB.UserTaskRequest{
				UserId:       userID,
				EventId:      eventID,
				Sceneryspots: []string{*sceneryspotID},
			},
		); err == nil {
			userTasks = out.Data
		}
	}

	completedTask := func(v string) *tPB.UserTask {
		for _, task := range userTasks {
			if v == task.TaskId {
				return task
			}
		}
		return nil
	}

	if category.Id == string(TaskCategoryTrek) {
		v, err := r.taskService.GetTrek(ctx, &tPB.TsKeyword{Value: id})
		if err != nil {
			return nil, err
		}
		timestamp := int(time.Now().Unix())
		var redone, completed bool
		if task := completedTask(v.Id); task != nil {
			timestamp = int(task.CreateTime)
			redone = len(task.Audit) == 0 && task.Result != fmt.Sprintf("%v", v.Step)
			completed = task.Status == int32(TaskStatusCompleted)
		}
		return &model.TrekTask{
			ID:            v.Id,
			Name:          v.Name,
			CategoryID:    category.Id,
			CategoryName:  category.Name,
			Points:        int(v.Points),
			Optional:      optional,
			Status:        int(v.Status),
			Timestamp:     timestamp,
			Redone:        &redone,
			Completed:     &completed,
			Step:          int(v.Step),
			Images:        v.Images,
			Introduction:  v.Introduction,
			ElectricFence: &v.ElectricFence,
		}, nil
	}

	if category.Id == string(TaskCategoryQuestion) {
		v, err := r.taskService.GetQuestionBank(ctx, &tPB.TsKeyword{Value: id})
		if err != nil {
			return nil, err
		}
		timestamp := int(time.Now().Unix())
		var redone, completed bool
		if task := completedTask(v.Id); task != nil {
			timestamp = int(task.CreateTime)
			redone = len(task.Audit) == 0 && task.Result != v.Answer
			completed = task.Status == int32(TaskStatusCompleted)
		}
		return &model.QuestionTask{
			ID:            v.Id,
			Name:          v.Question,
			CategoryID:    category.Id,
			CategoryName:  category.Name,
			Points:        int(v.Points),
			Optional:      optional,
			Status:        int(v.Status),
			Timestamp:     timestamp,
			Redone:        &redone,
			Completed:     &completed,
			Options:       strings.Split(v.Options, ";"),
			ElectricFence: &v.ElectricFence,
		}, nil
	}

	if category.Id == string(TaskCategoryGeocaching) {
		v, err := r.taskService.GetGeocaching(ctx, &tPB.TsKeyword{Value: id})
		if err != nil {
			return nil, err
		}
		timestamp := int(time.Now().Unix())
		var redone, completed bool
		if task := completedTask(v.Id); task != nil {
			timestamp = int(task.CreateTime)
			redone = len(task.Audit) == 0 && task.Result != v.Id
			completed = task.Status == int32(TaskStatusCompleted)
		}
		return &model.GeocachingTask{
			ID:            v.Id,
			Name:          v.Name,
			CategoryID:    category.Id,
			CategoryName:  category.Name,
			Points:        int(v.Points),
			Optional:      optional,
			Status:        int(v.Status),
			Timestamp:     timestamp,
			Redone:        &redone,
			Completed:     &completed,
			Images:        v.Images,
			Introduction:  v.Introduction,
			ElectricFence: &v.ElectricFence,
		}, nil
	}

	if category.Id == string(TaskCategoryScreenshot) {
		v, err := r.taskService.GetScreenshot(ctx, &tPB.TsKeyword{Value: id})
		if err != nil {
			return nil, err
		}
		timestamp := int(time.Now().Unix())
		var redone, completed bool
		if task := completedTask(v.Id); task != nil {
			timestamp = int(task.CreateTime)
			redone = len(task.Audit) == 0
			completed = true
		}
		return &model.ScreenshotTask{
			ID:            v.Id,
			Name:          v.Name,
			CategoryID:    category.Id,
			CategoryName:  category.Name,
			Points:        int(v.Points),
			Optional:      optional,
			Status:        int(v.Status),
			Timestamp:     timestamp,
			Redone:        &redone,
			Completed:     &completed,
			Images:        v.Images,
			Introduction:  v.Introduction,
			ElectricFence: &v.ElectricFence,
		}, nil
	}

	if category.Id == string(TaskCategoryPuzzle) {
		v, err := r.taskService.GetPuzzle(ctx, &tPB.TsKeyword{Value: id})
		if err != nil {
			return nil, err
		}
		timestamp := int(time.Now().Unix())
		var redone, completed bool
		if task := completedTask(v.Id); task != nil {
			timestamp = int(task.CreateTime)
			redone = len(task.Audit) == 0 && task.Result != v.Images
			completed = task.Status == int32(TaskStatusCompleted)
		}
		puzzles := strings.Split(v.Images, ",")
		return &model.PuzzleTask{
			ID:            v.Id,
			Name:          v.Name,
			CategoryID:    category.Id,
			CategoryName:  category.Name,
			Points:        int(v.Points),
			Optional:      optional,
			Status:        int(v.Status),
			Timestamp:     timestamp,
			Redone:        &redone,
			Completed:     &completed,
			Level:         len(puzzles),
			Countdown:     int(v.Countdown),
			Puzzles:       puzzles,
			Images:        v.Images,
			Introduction:  v.Introduction,
			ElectricFence: &v.ElectricFence,
		}, nil
	}

	return nil, nil
}

// CampRanks is the resolver for the campRanks field.
func (r *queryResolver) CampRanks(ctx context.Context, first *int, eventID string) ([]*model.CampRank, error) {
	out, err := r.eventService.GetCampRanks(ctx, &ePB.CampRankRequest{EventId: eventID})
	if err != nil {
		return nil, err
	}

	size := len(out.Data)
	if first != nil && *first < size {
		size = *first
	}

	result := make([]*model.CampRank, size)
	for i, v := range out.Data[:size] {
		result[i] = &model.CampRank{
			Rank:      i + 1,
			ID:        v.Id,
			Name:      v.Name,
			Points:    int(v.Points),
			Logo:      v.Images,
			UserCount: int(v.UserCount),
		}
	}

	return result, nil
}

// UserRanks is the resolver for the userRanks field.
func (r *queryResolver) UserRanks(ctx context.Context, first *int, eventID string) ([]*model.UserRank, error) {
	out, err := r.eventService.GetUserRanks(ctx, &ePB.UserRankRequest{EventId: eventID})
	if err != nil {
		return nil, err
	}

	size := len(out.Data)
	if first != nil && *first < size {
		size = *first
	}

	result := make([]*model.UserRank, size)
	for i, v := range out.Data[:size] {
		result[i] = &model.UserRank{
			Rank:       i + 1,
			ID:         v.Id,
			Name:       v.Name,
			Points:     int(v.Points),
			TripCount:  int(v.TripCount),
			HonourID:   v.HonourId,
			HonourName: v.HonourName,
			CampID:     v.CampId,
			CampName:   v.CampName,
		}
	}

	return result, nil
}

// UserEvents is the resolver for the userEvents field.
func (r *queryResolver) UserEvents(ctx context.Context, userID string, eventID *string, status *int) ([]*model.UserEvent, error) {
	srv := r.eventService
	in := ePB.UserEventRequest{UserId: userID}
	if eventID != nil {
		in.EventId = *eventID
	}
	if status != nil {
		in.Status = int32(*status)
	}
	out, err := srv.GetUserEvents(ctx, &in)
	if err != nil {
		return nil, err
	}

	size := len(out.Data)
	result := make([]*model.UserEvent, size)
	for i, v := range out.Data[:size] {
		result[i] = &model.UserEvent{
			ID:           v.Id,
			Name:         v.Name,
			Images:       v.Images,
			StartTime:    int(v.StartTime),
			EndTime:      int(v.EndTime),
			Status:       int(v.Status),
			PassportCode: v.PassportCode,
			CampID:       v.CampId,
			CampName:     v.CampName,
			CampPoints:   int(v.CampPoints),
			CampRanking:  int(v.CampRanking),
			UserPoints:   int(v.UserPoints),
			UserRanking:  int(v.UserRanking),
			UserHonour:   v.UserHonour,
		}
	}

	return result, nil
}

// UserSceneryspots is the resolver for the userSceneryspots field.
func (r *queryResolver) UserSceneryspots(ctx context.Context, userID string) ([]*model.Sceneryspot, error) {
	srv := r.sceneryspotService
	out, err := srv.GetUserSceneryspots(ctx, &sPB.UserSceneryspotRequest{UserId: userID})
	if err != nil {
		return nil, err
	}

	results := make([]*model.Sceneryspot, len(out.Data))
	for i, v := range out.Data {
		points := int(v.Points)
		status := int(v.Status)
		createtime := int(v.CreateTime)
		results[i] = &model.Sceneryspot{
			ID:                v.Id,
			Code:              v.Code,
			Name:              v.Name,
			Address:           &v.Address,
			Points:            &points,
			Images:            &v.Images,
			Coordinate:        &v.Coordinate,
			ElectricFence:     &v.ElectricFence,
			Introduction:      &v.Introduction,
			CategoryID:        &v.CategoryId,
			PositionTolerance: &v.PositionTolerance,
			PassportLink:      &v.PassportLink,
			HealthCodeLink:    &v.HealthCodeLink,
			Status:            &status,
			CreateTime:        &createtime,
		}
	}

	return results, nil
}

// UserPhoneNumber is the resolver for the userPhoneNumber field.
func (r *queryResolver) UserPhoneNumber(ctx context.Context, userID string, code string) (*model.PhoneInfo, error) {
	info, err := r.WX.PhoneNumber(code)
	if err != nil {
		return nil, err
	}

	if v, err := r.accountService.GetProfileByUserID(
		ctx,
		&aPB.AsKeyword{Value: userID},
	); err == nil && len(v.Phone) == 0 {
		r.accountService.UpdateProfile(ctx, &aPB.Profile{Id: v.Id, Phone: info.PhoneNumber})
	}

	return &model.PhoneInfo{PhoneNumber: info.PhoneNumber, CountryCode: info.CountryCode}, nil
}

// UserIndivIdentity is the resolver for the userIndivIdentity field.
func (r *queryResolver) UserIndivIdentity(ctx context.Context, userID string, name string, idNumber string, phoneNumber string, email string) (*model.IndivIdentity, error) {
	srv := r.accountService
	uid := utils.Sha1(fmt.Sprintf("%s\n%s\n%s\n%s\n%s", userID, name, idNumber, phoneNumber, email))
	acc, err := srv.GetIndivIdentityAccount(ctx, &aPB.IndivIdentityAccountRequest{UserId: uid})
	if err != nil {
		return nil, err
	}

	var accountID string
	if acc.Data != nil {
		accountID = acc.Data.AccountId
	} else {
		info := esign.PersonInfo{
			ThirdPartyUserID: uid,
			Name:             name,
			IDType:           esign.IDTypeIDCard,
			IDNumber:         idNumber,
			Mobile:           phoneNumber,
			Email:            email,
		}
		id, err := esign.CreateByThirdPartyUserId(info)
		if err != nil {
			return nil, err
		}
		accountID = id
	}

	flowID, shortLink, URL, err := esign.IndivIdentityUrl(
		accountID,
		&esign.IndivInfo{
			Name:     name,
			CertType: esign.CertTypeIDCard,
			CertNo:   idNumber,
			MobileNo: phoneNumber,
		},
	)
	if err != nil {
		return nil, err
	}
	if len(flowID) == 0 || len(shortLink) == 0 || len(URL) == 0 {
		return nil, nil
	}

	id, _ := uuid.NewV4()
	ii, err := r.accountService.CreateIndivIdentity(
		ctx,
		&aPB.IndivIdentity{
			Id:         id.String(),
			UserId:     uid,
			AccountId:  accountID,
			FlowId:     flowID,
			ShortLink:  shortLink,
			Url:        URL,
			CreateTime: time.Now().Unix(),
		},
	)
	if err != nil {
		return nil, err
	}
	data := ii.Data

	return &model.IndivIdentity{AccountID: data.AccountId, FlowID: data.FlowId, ShortLink: data.ShortLink, URL: data.Url}, nil
}

// UserIdentityAuthDetail is the resolver for the userIdentityAuthDetail field.
func (r *queryResolver) UserIdentityAuthDetail(ctx context.Context, flowID string) (map[string]any, error) {
	ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()

	return esign.AuthDetail(flowID)
}

// Photos is the resolver for the photos field.
func (r *queryResolver) Photos(ctx context.Context, first *int, after *string, last *int, before *string, status int, eventID *string, sceneryspots []string) (*model.PhotoConnection, error) {
	afterCursor, err := DecodedCursor(after)
	if err != nil {
		return nil, err
	}

	beforeCursor, err := DecodedCursor(before)
	if err != nil {
		return nil, err
	}

	edges := make([]*model.PhotoEdge, *first)
	count := 0
	currentPage := false

	if afterCursor == "" && beforeCursor == "" {
		currentPage = true
	}

	startCursor := ""
	endCursor := ""
	hasPreviousPage := false
	hasNextPage := false

	in := msgPB.TweetRequest{
		Status:       int32(status),
		Sceneryspots: sceneryspots,
	}
	if eventID != nil {
		in.EventId = *eventID
	}
	out, err := r.messageService.GetTweets(ctx, &in)
	if err != nil {
		return nil, err
	}
	results := out.Data

	sceneryspotMap := map[string]*model.Sceneryspot{}
	getSceneryspot := func(id string) *model.Sceneryspot {
		if v, ok := sceneryspotMap[id]; ok {
			return v
		}
		if v, err := r.Sceneryspot(ctx, id); err == nil {
			sceneryspotMap[v.ID] = v
			return v
		}

		return nil
	}

	accountMap := map[string]*aPB.Account{}
	getAccount := func(id string) *aPB.Account {
		if v, ok := accountMap[id]; ok {
			return v
		}
		if v, err := r.accountService.GetAccount(ctx, &aPB.AsKeyword{Value: id}); err == nil {
			accountMap[v.Id] = v
			return v
		}

		return nil
	}

	if afterCursor == "" && len(beforeCursor) > 0 {
		for i, v := range results {
			if v.Id == beforeCursor {
				currentPage = true
			}
			if currentPage && *last > 0 {
				m, n := i-*last, i
				if m < 0 {
					m = 0
				}
				for _, v := range results[m:n] {
					edges[count] = &model.PhotoEdge{
						Cursor: EncodeToCursor(v.Id),
						Node:   r.NewPhoto(v, getAccount(v.UserId), getSceneryspot(v.SceneryspotId)),
					}
					count++
				}

				hasPreviousPage = i-count > 0
				hasNextPage = i < len(results)-1
				break
			}
		}
	} else {
		for i, v := range results {
			if currentPage && count < *first {
				edges[count] = &model.PhotoEdge{
					Cursor: EncodeToCursor(v.Id),
					Node:   r.NewPhoto(v, getAccount(v.UserId), getSceneryspot(v.SceneryspotId)),
				}
				count++
			}

			if v.Id == afterCursor {
				currentPage = true
			}

			if hasPreviousPage == false {
				hasPreviousPage = i-count >= 0
			}

			if count == *first {
				hasNextPage = i < len(results)-1
				break
			}
		}
	}

	if count > 0 {
		startCursor = EncodeToCursor(edges[0].Node.ID)
		endCursor = EncodeToCursor(edges[count-1].Node.ID)
	}

	conn := model.PhotoConnection{
		TotalCount: len(results),
		Edges:      edges[:count],
		PageInfo: &model.PageInfo{
			StartCursor:     startCursor,
			EndCursor:       endCursor,
			HasPreviousPage: &hasPreviousPage,
			HasNextPage:     &hasNextPage,
		},
	}

	return &conn, nil
}

// Auditings is the resolver for the auditings field.
func (r *queryResolver) Auditings(ctx context.Context, first *int, after *string, last *int, before *string, filter *model.AuditingFilter) (*model.AuditingConnection, error) {
	afterCursor, err := DecodedCursor(after)
	if err != nil {
		return nil, err
	}

	beforeCursor, err := DecodedCursor(before)
	if err != nil {
		return nil, err
	}

	edges := make([]*model.AuditingEdge, *first)
	count := 0
	currentPage := false

	if afterCursor == "" && beforeCursor == "" {
		currentPage = true
	}

	startCursor := ""
	endCursor := ""
	hasPreviousPage := false
	hasNextPage := false

	in := mPB.AuditingRequest{}
	if filter != nil {
		if filter.Code != nil {
			in.Code = *filter.Code
		}
		if filter.CreatedBy != nil {
			in.CreatedBy = *filter.CreatedBy
		}
		if filter.StartTime != nil {
			in.StartTime = int32(*filter.StartTime)
		}
		if filter.EndTime != nil {
			in.EndTime = int32(*filter.EndTime)
		}
	}
	out, err := r.managementService.GetAuditings(ctx, &in)
	if err != nil {
		return nil, err
	}
	results := out.Data

	if afterCursor == "" && len(beforeCursor) > 0 {
		for i, v := range results {
			if v.Id == beforeCursor {
				currentPage = true
			}
			if currentPage && *last > 0 {
				m, n := i-*last, i
				if m < 0 {
					m = 0
				}
				for _, v := range results[m:n] {
					edges[count] = &model.AuditingEdge{
						Cursor: EncodeToCursor(v.Id),
						Node:   r.NewAuditing(v),
					}
					count++
				}

				hasPreviousPage = i-count > 0
				hasNextPage = i < len(results)-1
				break
			}
		}
	} else {
		for i, v := range results {
			if currentPage && count < *first {
				edges[count] = &model.AuditingEdge{
					Cursor: EncodeToCursor(v.Id),
					Node:   r.NewAuditing(v),
				}
				count++
			}

			if v.Id == afterCursor {
				currentPage = true
			}

			if hasPreviousPage == false {
				hasPreviousPage = i-count >= 0
			}

			if count == *first {
				hasNextPage = i < len(results)-1
				break
			}
		}
	}

	if count > 0 {
		startCursor = EncodeToCursor(edges[0].Node.ID)
		endCursor = EncodeToCursor(edges[count-1].Node.ID)
	}

	conn := model.AuditingConnection{
		TotalCount: len(results),
		Edges:      edges[:count],
		PageInfo: &model.PageInfo{
			StartCursor:     startCursor,
			EndCursor:       endCursor,
			HasPreviousPage: &hasPreviousPage,
			HasNextPage:     &hasNextPage,
		},
	}

	return &conn, nil
}

// UserSwap is the resolver for the userSwap field.
func (r *queryResolver) UserSwap(ctx context.Context, id string) (*model.UserSwap, error) {
	srv := r.eventService
	out, err := srv.GetUserSwaps(ctx, &ePB.UserSwapRequest{Id: id})
	if err != nil {
		return nil, err
	}
	if len(out.Data) > 0 {
		return r.NewUserSwap(out.Data[0]), nil
	}

	return nil, nil
}

// UserSwaps is the resolver for the userSwaps field.
func (r *queryResolver) UserSwaps(ctx context.Context, first *int, after *string, last *int, before *string, filter *model.UserSwapFilter) (*model.UserSwapConnection, error) {
	afterCursor, err := DecodedCursor(after)
	if err != nil {
		return nil, err
	}

	beforeCursor, err := DecodedCursor(before)
	if err != nil {
		return nil, err
	}

	edges := make([]*model.UserSwapEdge, *first)
	count := 0
	currentPage := false

	if afterCursor == "" && beforeCursor == "" {
		currentPage = true
	}

	startCursor := ""
	endCursor := ""
	hasPreviousPage := false
	hasNextPage := false

	srv := r.eventService
	in := ePB.UserSwapRequest{}
	if filter != nil {
		if filter.ID != nil {
			in.Id = *filter.ID
		}
		if filter.UserID != nil {
			in.UserId = *filter.UserID
		}
		if filter.EventID != nil {
			in.EventId = *filter.EventID
		}
		if filter.Status != nil {
			in.Status = int32(*filter.Status)
		}
		if filter.City != nil {
			in.City = *filter.City
		}
	}
	out, err := srv.GetUserSwaps(ctx, &in)
	if err != nil {
		return nil, err
	}
	results := out.Data

	if afterCursor == "" && len(beforeCursor) > 0 {
		for i, v := range results {
			if v.Id == beforeCursor {
				currentPage = true
			}
			if currentPage && *last > 0 {
				m, n := i-*last, i
				if m < 0 {
					m = 0
				}
				for _, v := range results[m:n] {
					edges[count] = &model.UserSwapEdge{
						Cursor: EncodeToCursor(v.Id),
						Node:   r.NewUserSwap(v),
					}
					count++
				}

				hasPreviousPage = i-count > 0
				hasNextPage = i < len(results)-1
				break
			}
		}
	} else {
		for i, v := range results {
			if currentPage && count < *first {
				edges[count] = &model.UserSwapEdge{
					Cursor: EncodeToCursor(v.Id),
					Node:   r.NewUserSwap(v),
				}
				count++
			}

			if v.Id == afterCursor {
				currentPage = true
			}

			if hasPreviousPage == false {
				hasPreviousPage = i-count >= 0
			}

			if count == *first {
				hasNextPage = i < len(results)-1
				break
			}
		}
	}

	if count > 0 {
		startCursor = EncodeToCursor(edges[0].Node.ID)
		endCursor = EncodeToCursor(edges[count-1].Node.ID)
	}

	conn := model.UserSwapConnection{
		TotalCount: len(results),
		Edges:      edges[:count],
		PageInfo: &model.PageInfo{
			StartCursor:     startCursor,
			EndCursor:       endCursor,
			HasPreviousPage: &hasPreviousPage,
			HasNextPage:     &hasNextPage,
		},
	}

	return &conn, nil
}

// EventSettings is the resolver for the eventSettings field.
func (r *queryResolver) EventSettings(ctx context.Context, id string) (map[string]any, error) {
	out, err := r.eventService.GetEventSettings(ctx, &ePB.EventSettingsRequest{Id: id})
	if err != nil {
		return nil, err
	}
	result := make(map[string]interface{})
	data := out.Data
	if data != nil {
		if len(data.Menus) > 0 {
			result["menus"] = data.Menus
		} else {
			result["menus"] = []string{}
		}
		if len(data.MarkBackgrouds) > 0 {
			result["markBackgrouds"] = data.MarkBackgrouds
		} else {
			result["markBackgrouds"] = []string{}
		}
	}
	return result, nil
}

// EventAwards is the resolver for the eventAwards field.
func (r *queryResolver) EventAwards(ctx context.Context, first *int, after *string, last *int, before *string, eventID *string, sceneryspotID *string, code *string) (*model.EventAwardConnection, error) {
	afterCursor, err := DecodedCursor(after)
	if err != nil {
		return nil, err
	}

	beforeCursor, err := DecodedCursor(before)
	if err != nil {
		return nil, err
	}

	edges := make([]*model.EventAwardEdge, *first)
	count := 0
	currentPage := false

	if afterCursor == "" && beforeCursor == "" {
		currentPage = true
	}

	startCursor := ""
	endCursor := ""
	hasPreviousPage := false
	hasNextPage := false

	srv := r.eventService
	in := ePB.EventAwardRequest{}
	if eventID != nil {
		in.EventId = *eventID
	}
	if sceneryspotID != nil {
		in.SceneryspotId = *sceneryspotID
	}
	if code != nil {
		in.Code = *code
	}
	out, err := srv.GetEventAwards(ctx, &in)
	if err != nil {
		return nil, err
	}
	results := out.Data

	if afterCursor == "" && len(beforeCursor) > 0 {
		for i, v := range results {
			if v.Id == beforeCursor {
				currentPage = true
			}
			if currentPage && *last > 0 {
				m, n := i-*last, i
				if m < 0 {
					m = 0
				}
				for _, v := range results[m:n] {
					edges[count] = &model.EventAwardEdge{
						Cursor: EncodeToCursor(v.Id),
						Node:   r.NewEventAward(v),
					}
					count++
				}

				hasPreviousPage = i-count > 0
				hasNextPage = i < len(results)-1
				break
			}
		}
	} else {
		for i, v := range results {
			if currentPage && count < *first {
				edges[count] = &model.EventAwardEdge{
					Cursor: EncodeToCursor(v.Id),
					Node:   r.NewEventAward(v),
				}
				count++
			}

			if v.Id == afterCursor {
				currentPage = true
			}

			if hasPreviousPage == false {
				hasPreviousPage = i-count >= 0
			}

			if count == *first {
				hasNextPage = i < len(results)-1
				break
			}
		}
	}

	if count > 0 {
		startCursor = EncodeToCursor(edges[0].Node.ID)
		endCursor = EncodeToCursor(edges[count-1].Node.ID)
	}

	conn := model.EventAwardConnection{
		TotalCount: len(results),
		Edges:      edges[:count],
		PageInfo: &model.PageInfo{
			StartCursor:     startCursor,
			EndCursor:       endCursor,
			HasPreviousPage: &hasPreviousPage,
			HasNextPage:     &hasNextPage,
		},
	}

	return &conn, nil
}

// UserEventAward is the resolver for the userEventAward field.
func (r *queryResolver) UserEventAward(ctx context.Context, input model.EventAwardInput) (*model.EventAward, error) {
	sceneryspots, err := r.getSceneryspotIDs(ctx, input.EventID)
	if err != nil {
		return nil, err
	}

	out, err := r.sceneryspotService.GetUserStamp(
		ctx,
		&sPB.UserStampRequest{
			UserId:        input.UserID,
			EventId:       input.EventID,
			SceneryspotId: input.SceneryspotID,
		},
	)
	if err != nil {
		return nil, err
	}
	if len(sceneryspots) != len(out.Data) {
		return nil, nil
	}

	awards, err := r.eventService.GetUserEventAwards(
		ctx,
		&ePB.UserEventAwardRequest{
			UserId:        input.UserID,
			EventId:       input.EventID,
			SceneryspotId: input.SceneryspotID,
			Location:      input.Location,
		},
	)
	if err != nil {
		return nil, err
	}
	if len(awards.Data) == 0 {
		return nil, errors.New("")
	}

	return r.NewEventAward(awards.Data[0]), nil
}

// ClaimPassports is the resolver for the claimPassports field.
func (r *queryResolver) ClaimPassports(ctx context.Context, first *int, after *string, last *int, before *string, userID *string, eventID *string) (*model.ClaimPassportConnection, error) {
	cur := auth.ForContext(ctx).User
	afterCursor, err := DecodedCursor(after)
	if err != nil {
		return nil, err
	}

	beforeCursor, err := DecodedCursor(before)
	if err != nil {
		return nil, err
	}

	edges := make([]*model.ClaimPassportEdge, *first)
	count := 0
	currentPage := false

	if afterCursor == "" && beforeCursor == "" {
		currentPage = true
	}

	startCursor := ""
	endCursor := ""
	hasPreviousPage := false
	hasNextPage := false

	srv := r.eventService
	in := ePB.ActivateUserEventPassportRequest{ClaimBy: cur.Id}
	if (cur.Role == string(model.RoleAdmin) || cur.Role == string(model.RoleRoot)) && userID != nil {
		in.ClaimBy = *userID
	}
	if eventID != nil {
		in.EvnetId = *eventID
	}
	out, err := srv.GetClaimEventPassports(ctx, &in)
	if err != nil {
		return nil, err
	}
	results := out.Data

	account := func(id string) *aPB.Account {
		if out, err := r.accountService.GetAccount(ctx, &aPB.AsKeyword{Value: id}); err == nil {
			return out
		}
		return nil
	}

	if afterCursor == "" && len(beforeCursor) > 0 {
		for i, v := range results {
			if v.Id == beforeCursor {
				currentPage = true
			}
			if currentPage && *last > 0 {
				m, n := i-*last, i
				if m < 0 {
					m = 0
				}
				for _, v := range results[m:n] {
					edges[count] = &model.ClaimPassportEdge{
						Cursor: EncodeToCursor(v.Id),
						Node:   r.NewClaimPassport(v, account(v.UserId)),
					}
					count++
				}

				hasPreviousPage = i-count > 0
				hasNextPage = i < len(results)-1
				break
			}
		}
	} else {
		for i, v := range results {
			if currentPage && count < *first {
				edges[count] = &model.ClaimPassportEdge{
					Cursor: EncodeToCursor(v.Id),
					Node:   r.NewClaimPassport(v, account(v.UserId)),
				}
				count++
			}

			if v.Id == afterCursor {
				currentPage = true
			}

			if hasPreviousPage == false {
				hasPreviousPage = i-count >= 0
			}

			if count == *first {
				hasNextPage = i < len(results)-1
				break
			}
		}
	}

	if count > 0 {
		startCursor = EncodeToCursor(edges[0].Node.ID)
		endCursor = EncodeToCursor(edges[count-1].Node.ID)
	}

	conn := model.ClaimPassportConnection{
		TotalCount: len(results),
		Edges:      edges[:count],
		PageInfo: &model.PageInfo{
			StartCursor:     startCursor,
			EndCursor:       endCursor,
			HasPreviousPage: &hasPreviousPage,
			HasNextPage:     &hasNextPage,
		},
	}

	return &conn, nil
}

// UserPoints is the resolver for the userPoints field.
func (r *queryResolver) UserPoints(ctx context.Context, first *int, after *string, last *int, before *string, userID string, eventID *string, timestamp *int) (*model.UserPointsConnection, error) {
	afterCursor, err := DecodedCursor(after)
	if err != nil {
		return nil, err
	}

	beforeCursor, err := DecodedCursor(before)
	if err != nil {
		return nil, err
	}

	edges := make([]*model.UserPointsEdge, *first)
	count := 0
	currentPage := false

	if afterCursor == "" && beforeCursor == "" {
		currentPage = true
	}

	startCursor := ""
	endCursor := ""
	hasPreviousPage := false
	hasNextPage := false

	in := aPB.UserPointsRequest{UserId: userID}
	if eventID != nil {
		in.EventId = *eventID
	}
	if timestamp != nil {
		in.Timestamp = int32(*timestamp)
	}
	out, err := r.accountService.GetUserPoints(ctx, &in)
	if err != nil {
		return nil, err
	}
	results := out.Data

	if afterCursor == "" && len(beforeCursor) > 0 {
		for i, v := range results {
			if v.Id == beforeCursor {
				currentPage = true
			}
			if currentPage && *last > 0 {
				m, n := i-*last, i
				if m < 0 {
					m = 0
				}
				for _, v := range results[m:n] {
					edges[count] = &model.UserPointsEdge{
						Cursor: EncodeToCursor(v.Id),
						Node:   r.NewUserPoints(v),
					}
					count++
				}

				hasPreviousPage = i-count > 0
				hasNextPage = i < len(results)-1
				break
			}
		}
	} else {
		for i, v := range results {
			if currentPage && count < *first {
				edges[count] = &model.UserPointsEdge{
					Cursor: EncodeToCursor(v.Id),
					Node:   r.NewUserPoints(v),
				}
				count++
			}

			if v.Id == afterCursor {
				currentPage = true
			}

			if hasPreviousPage == false {
				hasPreviousPage = i-count >= 0
			}

			if count == *first {
				hasNextPage = i < len(results)-1
				break
			}
		}
	}

	if count > 0 {
		startCursor = EncodeToCursor(edges[0].Node.ID)
		endCursor = EncodeToCursor(edges[count-1].Node.ID)
	}

	conn := model.UserPointsConnection{
		TotalCount: len(results),
		Edges:      edges[:count],
		PageInfo: &model.PageInfo{
			StartCursor:     startCursor,
			EndCursor:       endCursor,
			HasPreviousPage: &hasPreviousPage,
			HasNextPage:     &hasNextPage,
		},
	}

	return &conn, nil
}

// WeRunData is the resolver for the weRunData field.
func (r *queryResolver) WeRunData(ctx context.Context, encryptedData string, iv string) (map[string]any, error) {
	session := auth.ForContext(ctx).WechetSession
	if session == nil {
		return nil, errors.New("missing session")
	}
	appID := os.Getenv("WECHAT_APPID")
	v, err := utils.WXBizDataCryptDecode(appID, session.SessionKey, encryptedData, iv)
	if err != nil {
		return nil, err
	}
	return v, nil
}

// Query returns generated.QueryResolver implementation.
func (r *Resolver) Query() generated.QueryResolver { return &queryResolver{r} }

type queryResolver struct{ *Resolver }
